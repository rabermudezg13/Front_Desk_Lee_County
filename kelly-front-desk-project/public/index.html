<!DOCTYPE html>
<!--
Copyright (c) 2025 Rodrigo Bermudez Cafe Cultura LLC
All rights reserved.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Kelly Education Lee County Front Desk - v2.2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-auth-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-firestore-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <link rel="stylesheet" href="persistent-checklist.css">
    <link rel="stylesheet" href="queue-manager.css">
    <link rel="stylesheet" href="admin-dashboard.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            background: white;
            color: #333;
            margin-bottom: 40px;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: none;
        }

        .header .kelly {
            color: #4CAF50;
        }

        .registration-only-element {
            display: none;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        .update-flash {
            animation: flash 0.5s ease-in-out;
        }

        @keyframes flash {
            0% { background-color: inherit; }
            50% { background-color: #ffd700; }
            100% { background-color: inherit; }
        }

        .header .education {
            color: #333;
        }

        .nav-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .nav-btn {
            background: rgba(255,255,255,0.9);
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            color: #333;
        }

        .nav-btn:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .nav-btn.active {
            background: #4CAF50;
            color: white;
        }

        .screen {
            display: none;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            min-height: 500px;
        }

        .screen.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            border-color: #4CAF50;
            outline: none;
        }

        /* Time Slot Selection Styles */
        .time-slot-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .time-slot {
            background: white;
            border: 2px solid #ddd;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .time-slot:hover {
            border-color: #4CAF50;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(76, 175, 80, 0.2);
        }

        .time-slot.selected {
            border-color: #4CAF50;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .time-slot .time-text {
            display: block;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .time-slot .session-desc {
            display: block;
            font-size: 14px;
            opacity: 0.8;
        }

        @media (max-width: 768px) {
            .time-slot-container {
                grid-template-columns: 1fr;
            }
        }

        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #4CAF50;
        }

        .btn-success:hover {
            background: #45a049;
        }

        .btn-danger {
            background: #f44336;
        }

        .btn-danger:hover {
            background: #da190b;
        }

        .visit-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .visit-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .visit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .visit-time {
            color: #666;
            font-size: 0.9rem;
        }

        .login-form {
            max-width: 400px;
            margin: 0 auto;
        }

        .checkbox-group {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #c3e6cb;
            position: relative;
            z-index: 1000;
            display: block;
            width: 100%;
            box-sizing: border-box;
            font-weight: bold;
            text-align: center;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .two-column {
                grid-template-columns: 1fr;
            }
            
            .nav-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .nav-btn {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><span class="kelly">Kelly</span> <span class="education">Education</span> Lee County</h1>
            <p>Front Desk - Visit Registration & Management</p>
        </div>

        <!-- Navigation -->
        <div class="nav-buttons">
            <button class="nav-btn active" onclick="showScreen('visitor')">Register Visit</button>
            <button class="nav-btn" onclick="showScreen('login')">Staff Login</button>
            <button class="nav-btn" onclick="showScreen('admin-login')">Admin Login</button>
        </div>

        <!-- Visitor Screen -->
        <div id="visitor" class="screen active">
            <h2 style="text-align: center; margin-bottom: 30px;">Select Visit Type</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                <div class="visit-card" style="cursor: pointer;" onclick="showVisitForm('team')">
                    <h3>üè¢ Team Visit</h3>
                    <p>Recruiting Team or Talent Team</p>
                </div>
                <div class="visit-card" style="cursor: pointer;" onclick="showVisitForm('info-session')">
                    <h3>üìã Info Session</h3>
                    <p>Information sessions</p>
                </div>
                <div class="visit-card" style="cursor: pointer;" onclick="showVisitForm('fingerprints')">
                    <h3>üëÜ Fingerprints</h3>
                    <p>Fingerprint scanning</p>
                </div>
                <div class="visit-card" style="cursor: pointer;" onclick="showVisitForm('badge')">
                    <h3>üÜî Badge</h3>
                    <p>Badge processing and pickup</p>
                </div>
                <div class="visit-card" style="cursor: pointer;" onclick="showVisitForm('new-hire-orientation')">
                    <h3>üéØ New Hire Orientation</h3>
                    <p>New employee orientation session</p>
                </div>
                <div class="visit-card" style="cursor: pointer;" onclick="window.location.href='#document-completion-form'">
                    <h3>üìÑ Document Completion</h3>
                    <p>Complete your document preparation process</p>
                </div>
            </div>
        </div>

        <!-- Team Visit Form -->
        <div id="team-visit-form" class="screen">
            <h2>Team Visit</h2>
            <form onsubmit="submitTeamVisit(event)">
                <div class="two-column">
                    <div class="form-group">
                        <label>Full Name *</label>
                        <input type="text" id="team-name" required>
                    </div>
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="team-email">
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Team to Visit *</label>
                    <select id="team-select" required onchange="updateTeamMembers()">
                        <option value="">Select a team</option>
                        <option value="recruiting">Recruiting Team</option>
                        <option value="talent">Talent Team</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Team Member *</label>
                    <select id="team-member" required>
                        <option value="">First select a team</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Visit Reason *</label>
                    <textarea id="visit-reason" required rows="3" placeholder="Briefly describe the reason for your visit..."></textarea>
                </div>

                <div style="text-align: center;">
                    <button type="button" class="btn" onclick="showScreen('visitor')">Cancel</button>
                    <button type="submit" class="btn btn-success">Register Visit</button>
                </div>
            </form>
        </div>

        <!-- Info Session Form -->
        <div id="info-session-form" class="screen">
            <h2>Info Session Registration</h2>
            <p style="text-align: center; color: #666; margin-bottom: 30px;">
                üìÖ You are registering for TODAY's info session
            </p>
            
            <form onsubmit="submitInfoSession(event)">
                <div class="two-column">
                    <div class="form-group">
                        <label>First Name *</label>
                        <input type="text" id="info-first-name" required placeholder="Enter your first name">
                    </div>
                    <div class="form-group">
                        <label>Last Name *</label>
                        <input type="text" id="info-last-name" required placeholder="Enter your last name">
                    </div>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label>Email Address *</label>
                        <input type="email" id="info-email" required placeholder="Enter your email address">
                    </div>
                    <div class="form-group">
                        <label>Phone Number *</label>
                        <input type="tel" id="info-phone" required placeholder="Enter your phone number">
                    </div>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label>Type *</label>
                        <select id="info-session-type" required>
                            <option value="">Select session type</option>
                            <option value="new-hire" selected>New Hire</option>
                            <option value="reactivation">Reactivation</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label id="info-time-label">Available Time Slots for TODAY *</label>
                        <div class="time-slot-container">
                            <div class="time-slot" data-time="8:30" onclick="selectTimeSlot('8:30', this)">
                                <span class="time-text">8:30 AM</span>
                                <span class="session-desc">Morning Session</span>
                            </div>
                            <div class="time-slot" data-time="1:30" onclick="selectTimeSlot('1:30', this)">
                                <span class="time-text">1:30 PM</span>
                                <span class="session-desc">Afternoon Session</span>
                            </div>
                        </div>
                        <input type="hidden" id="info-time" required>
                    </div>
                </div>

                <!-- Document Status Section - Staff Only -->
                <div id="info-session-document-status" class="staff-only" style="background: #f0f8ff; border: 1px solid #b3d9ff; border-radius: 8px; padding: 20px; margin: 20px 0; display: none;">
                    <h4 style="margin: 0 0 15px 0; color: #0066cc;">üìã Document Status (Staff Only)</h4>
                    
                    <div class="checkbox-group" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="checkbox-item">
                            <input type="checkbox" id="info-ob365-sent">
                            <label for="info-ob365-sent">‚úÖ OB365 Sent</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="info-i9-sent">
                            <label for="info-i9-sent">üìù I9 Sent</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="info-existing-i9">
                            <label for="info-existing-i9">üìÑ Existing I9</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="info-ineligible">
                            <label for="info-ineligible">‚ùå Inelegible</label>
                        </div>
                    </div>
                    
                    <div style="margin-top: 10px;">
                        <small style="color: #666; font-style: italic;">
                            üí° Check the applicable boxes for document status tracking
                        </small>
                    </div>
                </div>
                
                <div style="background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 6px; padding: 15px; margin: 15px 0;">
                    <p style="margin: 0; color: #0066cc; font-size: 14px; text-align: center; font-weight: bold;">
                        üìÖ You are registering for TODAY's info session
                    </p>
                    <p style="margin: 5px 0 0 0; color: #0066cc; font-size: 12px; text-align: center;">
                        Registration date and time will be automatically recorded
                    </p>
                </div>

                <div style="text-align: center;">
                    <button type="button" class="btn" onclick="showScreen('visitor')">Cancel</button>
                    <button type="submit" class="btn btn-success">Register Info Session</button>
                </div>
            </form>
        </div>

        <!-- Fingerprints Form -->
        <div id="fingerprints-form" class="screen">
            <h2>Fingerprints</h2>
            <form onsubmit="submitFingerprints(event)">
                <div class="two-column">
                    <div class="form-group">
                        <label>Full Name *</label>
                        <input type="text" id="finger-name" required>
                    </div>
                    <div class="form-group">
                        <label>Email *</label>
                        <input type="email" id="finger-email" required>
                    </div>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label id="finger-time-label">Appointment Time for TODAY *</label>
                        <input type="time" id="finger-time" required>
                    </div>
                    <div class="form-group">
                        <label>Fingerprint Type *</label>
                        <select id="finger-type" required>
                            <option value="">Select type</option>
                            <option value="regular">üìã Regular</option>
                            <option value="dcf">üèõÔ∏è DCF</option>
                        </select>
                    </div>
                </div>

                <div style="background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 6px; padding: 15px; margin: 15px 0;">
                    <p style="margin: 0; color: #0066cc; font-size: 14px; text-align: center; font-weight: bold;">
                        üìÖ You are scheduling for TODAY's fingerprints
                    </p>
                    <p style="margin: 5px 0 0 0; color: #0066cc; font-size: 12px; text-align: center;">
                        Registration date and time will be automatically recorded
                    </p>
                </div>

                <div style="text-align: center;">
                    <button type="button" class="btn" onclick="showScreen('visitor')">Cancel</button>
                    <button type="submit" class="btn btn-success">Register Fingerprints</button>
                </div>
            </form>
        </div>

        <!-- Badge Form -->
        <div id="badge-form" class="screen">
            <h2>Badge Processing</h2>
            <form onsubmit="submitBadge(event)">
                <div class="two-column">
                    <div class="form-group">
                        <label>Full Name *</label>
                        <input type="text" id="badge-name" required>
                    </div>
                    <div class="form-group">
                        <label>Email *</label>
                        <input type="email" id="badge-email" required>
                    </div>
                </div>

                <div class="form-group">
                    <label>Phone *</label>
                    <input type="tel" id="badge-phone" required>
                </div>

                <div class="form-group">
                    <label id="badge-time-label">Appointment Time for TODAY *</label>
                    <input type="time" id="badge-time" required>
                </div>

                <div style="background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 6px; padding: 15px; margin: 15px 0;">
                    <p style="margin: 0; color: #0066cc; font-size: 14px; text-align: center; font-weight: bold;">
                        üìÖ You are scheduling for TODAY's badge processing
                    </p>
                    <p style="margin: 5px 0 0 0; color: #0066cc; font-size: 12px; text-align: center;">
                        Registration date and time will be automatically recorded
                    </p>
                </div>

                <div style="text-align: center;">
                    <button type="button" class="btn" onclick="showScreen('visitor')">Cancel</button>
                    <button type="submit" class="btn btn-success">Register Badge Appointment</button>
                </div>
            </form>
        </div>

        <!-- New Hire Orientation Form -->
        <div id="new-hire-orientation-form" class="screen">
            <h2>New Hire Orientation Registration</h2>
            <p style="text-align: center; color: #666; margin-bottom: 30px;">
                üìÖ You are registering for TODAY's orientation
            </p>
            
            <form onsubmit="submitNewHireOrientation(event)">
                <div class="two-column">
                    <div class="form-group">
                        <label>First Name *</label>
                        <input type="text" id="nho-first-name" required placeholder="Enter your first name">
                    </div>
                    <div class="form-group">
                        <label>Last Name *</label>
                        <input type="text" id="nho-last-name" required placeholder="Enter your last name">
                    </div>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label>Email Address *</label>
                        <input type="email" id="nho-email" required placeholder="Enter your email address">
                    </div>
                    <div class="form-group">
                        <label>Phone Number *</label>
                        <input type="tel" id="nho-phone" required placeholder="Enter your phone number">
                    </div>
                </div>

                <div class="form-group">
                    <label id="nho-time-label">Available Orientation Sessions for TODAY *</label>
                    <div class="time-slot-container">
                        <div class="time-slot" data-time="9:00-12:00" onclick="selectNHOTimeSlot('9:00-12:00', this)">
                            <span class="time-text">9:00 AM - 12:00 PM</span>
                            <span class="session-desc">Morning Session</span>
                        </div>
                        <div class="time-slot" data-time="1:30-4:00" onclick="selectNHOTimeSlot('1:30-4:00', this)">
                            <span class="time-text">1:30 PM - 4:00 PM</span>
                            <span class="session-desc">Afternoon Session</span>
                        </div>
                    </div>
                    <input type="hidden" id="nho-time" required>
                </div>

                <div style="background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 6px; padding: 15px; margin: 15px 0;">
                    <p style="margin: 0; color: #0066cc; font-size: 14px; text-align: center; font-weight: bold;">
                        üìÖ You are registering for TODAY's orientation
                    </p>
                    <p style="margin: 5px 0 0 0; color: #0066cc; font-size: 12px; text-align: center;">
                        Registration date and time will be automatically recorded
                    </p>
                </div>


                <div style="text-align: center;">
                    <button type="button" class="btn" onclick="showScreen('visitor')">Cancel</button>
                    <button type="submit" class="btn btn-success">Register New Hire Orientation</button>
                </div>
            </form>
        </div>

        <div id="document-completion-form" class="screen">
            <div style="max-width: 600px; margin: 20px auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                <h2 style="text-align: center; margin-bottom: 30px; color: #4CAF50;">üìÑ Document Completion Process</h2>
                
                <form id="direct-completion-form">
                    <div style="margin-bottom: 25px;">
                        <label for="direct-name" style="display: block; color: #333; font-weight: 600; margin-bottom: 8px; font-size: 16px;">Your Full Name *</label>
                        <input type="text" id="direct-name" required placeholder="Enter your complete name" style="width: 100%; padding: 15px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #333; margin-bottom: 15px; font-size: 18px;">üìã Document Completion Steps</h3>
                        <p style="color: #666; margin-bottom: 20px; font-size: 14px;">Check off each step as you complete it:</p>
                        
                        <div style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="direct-drug-screening" style="margin-right: 12px; transform: scale(1.2);">
                                <div>
                                    <strong style="color: #333;">üß™ Drug Screening</strong>
                                    <p style="margin: 5px 0 0 0; color: #666; font-size: 14px;">Please fill out the paper you have in front of you, only the yellow fields and your phone number on the back side. Wait for instructions from Kelly representatives to do drug screening.</p>
                                </div>
                            </label>
                        </div>
                        
                        <div style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="direct-onboarding-365" style="margin-right: 12px; transform: scale(1.2);">
                                <div>
                                    <strong style="color: #333;">üíº Onboarding 365</strong>
                                    <p style="margin: 5px 0 0 0; color: #666; font-size: 14px;">Please search in your email for an email that says "First Steps with Kelly", click on the blue link that says Onboarding 365. When you receive the congratulations window, you can continue to the next step.</p>
                                </div>
                            </label>
                        </div>
                        
                        <div style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="direct-i9-form" style="margin-right: 12px; transform: scale(1.2);">
                                <div>
                                    <strong style="color: #333;">üìù Form I-9</strong>
                                    <p style="margin: 5px 0 0 0; color: #666; font-size: 14px;">Look for an email from Kelly with the title "Gryphon HR", fill out the information.</p>
                                </div>
                            </label>
                        </div>
                        
                        <div style="margin-bottom: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="direct-fieldprint" style="margin-right: 12px; transform: scale(1.2);">
                                <div>
                                    <strong style="color: #333;">üëÜ Fingerprints</strong>
                                    <p style="margin: 5px 0 0 0; color: #666; font-size: 14px;">If you haven't done fingerprints before, please only create the account by scanning the QR code that has the title "Fingerprints". You will schedule appointment, sign up, fill out the information. When it asks for Verification code, the system sends it to your email. When it asks for Fieldprint code, you stop there. Check the submit box and wait for us to call you.</p>
                                </div>
                            </label>
                        </div>
                    </div>
                    
                    <button type="submit" id="direct-submit-btn" style="background: #4CAF50; color: white; padding: 15px 40px; border: none; border-radius: 8px; font-size: 18px; font-weight: 600; cursor: pointer; width: 100%;">
                        ‚úÖ Submit Document Completion
                    </button>
                </form>
                
                <div id="direct-status" style="margin-top: 20px;"></div>
                
                <script>
                    document.getElementById('direct-completion-form').addEventListener('submit', async function(event) {
                        event.preventDefault();
                        console.log('üöÄ Form submitted!');
                        
                        const submitBtn = document.getElementById('direct-submit-btn');
                        const name = document.getElementById('direct-name').value.trim();
                        const statusDiv = document.getElementById('direct-status');
                        
                        if (!name) {
                            statusDiv.innerHTML = '<div style="background: #f8d7da; color: #721c24; padding: 15px; border-radius: 8px;">Please enter your full name</div>';
                            return;
                        }
                        
                        submitBtn.disabled = true;
                        submitBtn.textContent = '‚è≥ Processing...';
                        statusDiv.innerHTML = '';
                        
                        try {
                            const now = new Date();
                            const queueNumber = Math.floor(now.getTime() / 1000) % 10000;
                            
                            const submissionData = {
                                type: 'document-completion',
                                name: name,
                                queueNumber: queueNumber,
                                timestamp: now.toISOString(),
                                date: now.toISOString().split('T')[0],
                                time: now.toLocaleString(),
                                status: 'pending-recruiter-contact',
                                assignedRecruiter: 'Front Desk Administrator',
                                recruiterEmail: 'admin@kellyeducation.com',
                                drugScreening: document.getElementById('direct-drug-screening')?.checked || false,
                                onboarding365: document.getElementById('direct-onboarding-365')?.checked || false,
                                i9Form: document.getElementById('direct-i9-form')?.checked || false,
                                fieldprint: document.getElementById('direct-fieldprint')?.checked || false,
                                completedAt: now.toISOString(),
                                source: 'direct-document-completion-form'
                            };
                            
                            console.log('üìù Sending to document-queue:', submissionData);
                            
                            let db;
                            if (window.db) {
                                db = window.db;
                            } else if (typeof firebase !== 'undefined' && firebase.firestore) {
                                db = firebase.firestore();
                            } else {
                                throw new Error('Firebase not available');
                            }
                            
                            const docRef = await db.collection('document-queue').add(submissionData);
                            console.log('‚úÖ SUCCESS! Document ID:', docRef.id);
                            
                            statusDiv.innerHTML = `
                                <div style="background: #d4edda; color: #155724; padding: 15px; border-radius: 8px;">
                                    <h3>üéâ Success!</h3>
                                    <p><strong>${name}</strong></p>
                                    <p>Your queue number is: <strong>#${queueNumber}</strong></p>
                                    <p style="margin-top: 15px; font-weight: bold;">Please proceed to the front desk.</p>
                                </div>
                            `;
                            
                            document.getElementById('direct-completion-form').reset();
                            
                        } catch (error) {
                            console.error('‚ùå Error:', error);
                            statusDiv.innerHTML = `
                                <div style="background: #f8d7da; color: #721c24; padding: 15px; border-radius: 8px;">
                                    ‚ùå Error: ${error.message}
                                </div>
                            `;
                        } finally {
                            submitBtn.disabled = false;
                            submitBtn.textContent = '‚úÖ Submit Document Completion';
                        }
                    });
                </script>
            </div>
        </div>
        <!-- Document Completion Success -->
        <div id="document-completion-success" class="screen">
            <div style="text-align: center; padding: 40px 20px; min-height: 100vh; background: white; position: relative; z-index: 1000;">
                <div style="font-size: 80px; color: #28a745; margin-bottom: 30px;">‚úÖ</div>
                <h1 style="color: #28a745; margin-bottom: 30px; font-size: 32px;">Document Completion Confirmed!</h1>
                <p style="font-size: 12px; color: #666; margin-bottom: 20px;">System Version: 2.2 - Cache Force Update</p>
                
                <div style="background: #f8f9fa; padding: 40px; border-radius: 15px; margin: 30px auto; border: 3px solid #28a745; max-width: 600px; box-shadow: 0 8px 20px rgba(0,0,0,0.1);">
                    <div style="text-align: center; margin-bottom: 30px;">
                        <div style="font-size: 48px; color: #28a745; margin-bottom: 15px;">üé´</div>
                        <h2 style="color: #28a745; margin: 0; font-size: 28px;">Your Queue Number</h2>
                    </div>
                    
                    <div style="background: white; padding: 30px; border-radius: 10px; margin: 20px 0; text-align: center; border: 2px dashed #28a745;">
                        <div style="font-size: 72px; font-weight: bold; color: #28a745; margin-bottom: 10px;" id="completion-queue"></div>
                        <p style="margin: 0; font-size: 18px; color: #666;">Queue Number</p>
                    </div>
                    
                    <div style="text-align: left; font-size: 18px; line-height: 1.8; background: white; padding: 25px; border-radius: 10px;">
                        <p><strong>üë§ Name:</strong> <span id="completion-name" style="color: #28a745; font-weight: bold;"></span></p>
                        <p><strong>üïí Time:</strong> <span id="completion-time"></span></p>
                        
                        <div style="margin-top: 30px; padding: 20px; background: #e7f3ff; border-radius: 10px; border-left: 6px solid #007bff;">
                            <h3 style="color: #0056b3; margin: 0 0 15px 0; font-size: 20px;">üìã Important - Next Steps</h3>
                            <ul style="margin: 0; padding-left: 20px; color: #495057;">
                                <li style="margin-bottom: 10px;">Please keep this queue number visible</li>
                                <li style="margin-bottom: 10px;">Wait in the designated area</li>
                                <li style="margin-bottom: 10px;">You will be called when it's your turn</li>
                                <li style="margin: 0;">Do not leave the premises without checking with staff</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Queue Position Info (Live) -->
                <div id="queue-position-info" class="visit-card" style="margin: 20px auto; max-width: 500px; background: #e3f2fd; border: 2px solid #2196f3;">
                    <h3 style="margin-bottom: 15px; color: #1976d2;">üöÄ Your Position in Queue</h3>
                    <div style="text-align: center;">
                        <div style="font-size: 48px; color: #1976d2; font-weight: bold; margin: 15px 0;" id="position-display">#?</div>
                        <div id="position-text" style="font-size: 18px; color: #1565c0; font-weight: bold; margin: 10px 0;">Checking your position...</div>
                        <div id="wait-time" style="font-size: 14px; color: #1976d2; margin: 10px 0;">Estimated wait time: Calculating...</div>
                        <div style="font-size: 12px; color: #1976d2; margin-top: 15px; opacity: 0.8;">
                            üîÑ Updates automatically ‚Ä¢ Last updated: <span id="position-last-update">Now</span>
                        </div>
                    </div>
                </div>

                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h4 style="color: #856404; margin-bottom: 15px;">‚ö†Ô∏è IMPORTANT - Do Not Close This Window</h4>
                    <p style="color: #856404; margin: 0; font-weight: bold; font-size: 16px;">
                        Please keep this window open until you are with your recruiter. 
                        Your recruiter will contact you shortly.
                    </p>
                </div>

                <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h4 style="color: #155724; margin-bottom: 10px;">üìû Next Steps</h4>
                    <p style="color: #155724; margin: 0;">
                        A recruiter has been notified of your completion and will contact you soon.
                        Please wait for their call or for them to come find you.
                    </p>
                </div>

                <!-- Registration-only mode button -->
                <div style="margin-top: 30px;" id="registration-only-actions" class="registration-only-element">
                    <button class="btn" onclick="window.location.reload()" style="background: #6c757d; color: white; padding: 12px 24px;">
                        ‚Üª Submit Another Registration
                    </button>
                </div>

                <!-- Return to main menu button -->
                <div style="margin-top: 40px; text-align: center;">
                    <button type="button" onclick="returnToMainFromSuccess()" 
                            style="background: #007bff; color: white; border: none; padding: 20px 40px; font-size: 18px; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                        ‚Üê Return to Main Menu
                    </button>
                    <p style="margin-top: 15px; color: #666; font-size: 14px;">
                        Click only if you need to register someone else
                    </p>
                </div>

            </div>
        </div>


        <!-- Event Registration Form -->
        <div id="event-registration-form" class="screen">
            <h2 id="event-form-title">Event Registration</h2>
            <p style="text-align: center; color: #666; margin-bottom: 30px;" id="event-form-subtitle">
                Please fill out the form below to register for this event
            </p>
            
            <form onsubmit="submitEventRegistration(event)">
                <div class="two-column">
                    <div class="form-group">
                        <label>Full Name *</label>
                        <input type="text" id="event-name" required placeholder="Enter your full name">
                    </div>
                    <div class="form-group">
                        <label>Email *</label>
                        <input type="email" id="event-email" required placeholder="Enter your email">
                    </div>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label>Phone Number *</label>
                        <input type="tel" id="event-phone" required placeholder="Enter your phone number">
                    </div>
                    <div class="form-group">
                        <label>Zip Code *</label>
                        <input type="text" id="event-zipcode" required placeholder="Enter your zip code" pattern="[0-9]{5}(-[0-9]{4})?" title="Enter a valid 5-digit zip code (e.g., 12345 or 12345-6789)">
                    </div>
                </div>

                <div class="form-group">
                    <label>Candidate Type *</label>
                    <select id="event-candidate-type" required style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px;">
                        <option value="">Select candidate type</option>
                        <option value="new-hire">New Hire</option>
                        <option value="reactivation">Reactivation</option>
                    </select>
                </div>

                <div class="form-group">
                    <h4 style="margin-bottom: 15px; color: #333;">üìã Requirements</h4>
                    <div class="checkbox-group" style="display: block; margin-bottom: 20px;">
                        <div class="checkbox-item" style="margin-bottom: 15px;">
                            <input type="checkbox" id="event-english">
                            <label for="event-english" style="font-size: 16px;">üó£Ô∏è I speak and understand English</label>
                        </div>
                        <div class="checkbox-item" style="margin-bottom: 15px;">
                            <input type="checkbox" id="event-college-credits">
                            <label for="event-college-credits" style="font-size: 16px;">üéì I have 60+ college credits or Associate Degree</label>
                        </div>
                    </div>
                </div>

                <div style="text-align: center;">
                    <button type="button" class="btn" onclick="showScreen('visitor')">Cancel</button>
                    <button type="submit" class="btn btn-success" style="font-size: 18px; padding: 15px 30px;">
                        ‚úÖ Register for Event
                    </button>
                </div>
            </form>
        </div>

        <!-- Event Registration Success -->
        <div id="event-registration-success" class="screen">
            <div style="text-align: center; padding: 40px 20px;">
                <div style="font-size: 60px; color: #28a745; margin-bottom: 20px;">‚úÖ</div>
                <h2 style="color: #28a745; margin-bottom: 30px;">Registration Complete!</h2>
                
                <div style="background: linear-gradient(135deg, #d4edda, #c3e6cb); border: 1px solid #c3e6cb; border-radius: 12px; padding: 30px; margin: 30px auto; max-width: 600px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                    <h3 style="color: #155724; margin-bottom: 20px; text-align: center;">üéâ Thank You Very Much!</h3>
                    <p style="color: #155724; margin: 0 0 15px 0; font-size: 18px; line-height: 1.6; text-align: center;">
                        Your information has been successfully saved to our system.
                    </p>
                    <p style="color: #155724; margin: 0; font-size: 16px; line-height: 1.6; text-align: center;">
                        üìß We will send you the paperwork and next steps to your email address shortly.
                    </p>
                </div>
                
                <div class="visit-card" style="margin: 30px auto; max-width: 600px; border: 2px solid #28a745;">
                    <h4 style="margin-bottom: 20px; color: #28a745; text-align: center;">üìã Your Registration Details</h4>
                    <div style="text-align: left; background: #f8f9fa; padding: 25px; border-radius: 8px; border: 1px solid #e9ecef;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <p style="margin: 12px 0;"><strong>üë§ Name:</strong><br><span id="success-name" style="color: #28a745; font-weight: 600; font-size: 16px;"></span></p>
                                <p style="margin: 12px 0;"><strong>üìß Email:</strong><br><span id="success-email" style="color: #28a745; font-weight: 600; font-size: 16px;"></span></p>
                                <p style="margin: 12px 0;"><strong>üì± Phone:</strong><br><span id="success-phone" style="color: #28a745; font-weight: 600; font-size: 16px;"></span></p>
                            </div>
                            <div>
                                <p style="margin: 12px 0;"><strong>üìç Zip Code:</strong><br><span id="success-zipcode" style="color: #28a745; font-weight: 600; font-size: 16px;"></span></p>
                                <p style="margin: 12px 0;"><strong>üìÖ Preferred Date:</strong><br><span id="success-date" style="color: #28a745; font-weight: 600; font-size: 16px;"></span></p>
                                <p style="margin: 12px 0;"><strong>üè∑Ô∏è Type:</strong><br><span id="success-candidate-type" style="color: #28a745; font-weight: 600; font-size: 16px;"></span></p>
                            </div>
                        </div>
                        <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e9ecef;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; text-align: center;">
                                <div style="padding: 15px; background: #e8f5e8; border-radius: 8px; border: 1px solid #c3e6cb;">
                                    <p style="margin: 0; font-size: 14px; color: #666; font-weight: 500;">üó£Ô∏è English Speaker</p>
                                    <p style="margin: 8px 0 0 0; font-size: 18px; font-weight: 700;"><span id="success-english" style="color: #28a745;"></span></p>
                                </div>
                                <div style="padding: 15px; background: #e8f5e8; border-radius: 8px; border: 1px solid #c3e6cb;">
                                    <p style="margin: 0; font-size: 14px; color: #666; font-weight: 500;">üéì College Credits</p>
                                    <p style="margin: 8px 0 0 0; font-size: 18px; font-weight: 700;"><span id="success-credits" style="color: #28a745;"></span></p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 40px;">
                    <button class="btn" onclick="resetEventRegistrationForm(); showScreen('event-registration-form');" style="background: #007bff; color: white; padding: 15px 30px; font-size: 16px; margin-right: 15px; border-radius: 8px;">
                        üë• Register Another Person
                    </button>
                    <button class="btn" onclick="showScreen('visitor')" style="background: #6c757d; color: white; padding: 15px 30px; font-size: 16px; border-radius: 8px;">
                        üè† Back to Home
                    </button>
                </div>
            </div>
        </div>

        <!-- Login Screen -->
        <div id="login" class="screen">
            <div class="login-form">
                <h2 style="text-align: center; margin-bottom: 30px;">Staff Login</h2>
                <form onsubmit="staffLogin(event)">
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="login-email" required>
                    </div>
                    <div class="form-group">
                        <label>Password</label>
                        <input type="password" id="login-password" required>
                    </div>
                    <div style="text-align: center;">
                        <button type="submit" class="btn btn-success">Login</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Admin Login Screen -->
        <div id="admin-login" class="screen">
            <div class="login-form">
                <h2 style="text-align: center; margin-bottom: 30px;">Administrator Login</h2>
                <form onsubmit="adminLogin(event)">
                    <div class="form-group">
                        <label>Admin Email</label>
                        <input type="email" id="admin-login-email" required>
                    </div>
                    <div class="form-group">
                        <label>Admin Password</label>
                        <input type="password" id="admin-login-password" required>
                    </div>
                    <div style="text-align: center;">
                        <button type="submit" class="btn btn-success">Admin Login</button>
                    </div>
                </form>
            </div>
        </div>


        <!-- Staff Dashboard -->
        <div id="dashboard" class="screen">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <h2>Control Panel</h2>
                <div>
                    <button class="btn" onclick="playNotificationSound()" style="margin-right: 10px;">üîä Test Sound</button>
                    <button class="btn" onclick="testTabNotification()" style="margin-right: 10px;">üì± Test Tab Notification</button>
                    <button class="btn btn-danger" onclick="logout()">Logout</button>
                </div>
            </div>
            
            
            <!-- STAFF ONLY BUTTONS -->
            <div style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="btn" onclick="adminResetQueue()" style="background: #dc3545; color: white; font-weight: bold; padding: 12px 24px; display: none;">üîÑ Reset Queue Numbers</button>
                <button class="btn" onclick="testPCRRStatus()" style="background: #ffc107; color: black; font-weight: bold; padding: 12px 24px;">üîç Test PC/RR Check</button>
                <button class="btn" onclick="debugOrientationCounts()" style="background: #6f42c1; color: white; font-weight: bold; padding: 12px 24px; display: none;">üîç Debug Counts</button>
                <button class="btn" onclick="checkRecruiterPermissions()" style="background: #17a2b8; color: white; font-weight: bold; padding: 12px 24px; display: none;">üë§ Fix Recruiter Perms</button>
                <button class="btn" onclick="debugDocumentQueue()" style="background: #dc3545; color: white; font-weight: bold; padding: 12px 24px; display: none;">üîç Debug Queue</button>
                <button class="btn" onclick="debugDocumentCompletions()" style="background: #e83e8c; color: white; font-weight: bold; padding: 12px 24px; display: none;">üìã Debug Data</button>
            </div>
            
            <div class="nav-buttons">
                <button class="nav-btn" id="my-visits-btn" onclick="showDashboardSection('my-visits')">My Visits <span id="visits-indicator" style="display: none; background: red; color: white; border-radius: 50%; width: 8px; height: 8px; margin-left: 5px; font-size: 8px;">‚óè</span></button>
                <button class="nav-btn" id="document-completions-btn" onclick="showDashboardSection('document-completions')" style="background: linear-gradient(135deg, #ff6b6b, #ee5a24); color: white; font-weight: bold;">üìã Document Queue <span id="completions-indicator" style="display: none; background: white; color: #ff6b6b; border-radius: 50%; padding: 4px 8px; margin-left: 8px; font-size: 12px; font-weight: bold;">0</span></button>
                <button class="nav-btn" id="info-sessions-btn" onclick="showDashboardSection('info-sessions')" style="display: none;">Info Sessions</button>
                <button class="nav-btn" id="new-hire-orientations-btn" onclick="showDashboardSection('new-hire-orientations')" style="display: none;">New Hire Orientations</button>
                <button class="nav-btn" id="advanced-analytics-btn" onclick="showDashboardSection('advanced-analytics-staff')" style="display: none; background: linear-gradient(135deg, #667eea, #764ba2); color: white; font-weight: bold;">üìä Advanced Analytics</button>
                <button class="nav-btn" onclick="showDashboardSection('fingerprints-admin')">Fingerprints</button>
                <button class="nav-btn" onclick="showDashboardSection('badges-staff')">Badges</button>
                <button class="nav-btn" onclick="showDashboardSection('pc-rr-check')">PC, RR Check</button>
                <button class="nav-btn" onclick="showDashboardSection('old-visits')">Old Visits</button>
                <button class="nav-btn" onclick="showDashboardSection('booking-counts')">Booking Counts</button>
                <button class="nav-btn" onclick="showDashboardSection('daily-statistics-staff')">Daily Statistics</button>
                <button class="nav-btn" id="recruiter-status-btn" onclick="showDashboardSection('recruiter-status')" style="display: block; background: #28a745; color: white; font-weight: bold;">üìä My Status</button>
                <button class="nav-btn" id="recruiter-events-btn" onclick="showDashboardSection('recruiter-events')" style="display: none;">My Events</button>
            </div>

            <!-- My Visits -->
            <div id="my-visits" class="dashboard-section">
                <h3>My Pending Visits</h3>
                <div id="visits-list"></div>
                
                <!-- DOCUMENT COMPLETIONS - SIMPLE LIST -->
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 10px; padding: 20px; margin: 30px 0;">
                    <h3 style="color: #856404; margin: 0 0 15px 0;">üìã Document Completions - Ready for Contact</h3>
                    <div id="simple-completions-display">
                        <p style="color: #856404; margin: 0;">Loading...</p>
                    </div>
                </div>
                
                <!-- MANUAL SAVE BUTTON - ONLY IN MY VISITS -->
                <div style="display: flex; justify-content: center; margin: 20px 0;">
                    <button class="btn" onclick="saveCurrentSession()" style="background: #28a745; color: white; font-weight: bold; padding: 12px 24px;">üíæ Manual Save</button>
                </div>
            </div>
            

            <!-- Info Sessions (recruiting only) -->
            <div id="info-sessions" class="dashboard-section" style="display: none;">
                <h3>Registered Info Sessions</h3>
                <div id="info-sessions-list"></div>
            </div>

            <!-- New Hire Orientations (recruiting only) -->
            <div id="new-hire-orientations" class="dashboard-section" style="display: none;">
                <h3>New Hire Orientations</h3>
                
                <!-- Search Passed List -->
                <div class="visit-card" style="margin-bottom: 30px; background: linear-gradient(135deg, #f3e5f5, #e1bee7);">
                    <h4 style="color: #7b1fa2; margin-bottom: 15px;">üîç Search Passed List</h4>
                    
                    <div style="display: flex; gap: 15px; align-items: end; flex-wrap: wrap;">
                        <div class="form-group" style="flex: 1; min-width: 200px;">
                            <label>First Name:</label>
                            <input type="text" id="search-first-name" placeholder="e.g., Daniela" onkeyup="searchPassedList()">
                        </div>
                        <div class="form-group" style="flex: 1; min-width: 200px;">
                            <label>Last Name:</label>
                            <input type="text" id="search-last-name" placeholder="e.g., Perez" onkeyup="searchPassedList()">
                        </div>
                        <button class="btn" onclick="searchPassedList()" style="height: fit-content;">üîç Search</button>
                        <button class="btn btn-secondary" onclick="clearSearch()" style="height: fit-content;">Clear</button>
                    </div>
                    
                    <div style="margin-top: 10px;">
                        <small style="color: #666; font-style: italic;">
                            üí° Tip: You can search by first name only, last name only, or both. The search works with partial names (e.g., "Dani" will find "Daniela")
                        </small>
                    </div>
                    
                    <!-- Search Results -->
                    <div id="search-results" style="margin-top: 20px; display: none;">
                        <h5 style="color: #7b1fa2; margin-bottom: 10px;">Search Results:</h5>
                        <div id="search-results-content"></div>
                    </div>
                </div>
                
                <div id="staff-orientations-list"></div>
            </div>

            <!-- Fingerprints Admin -->
            <div id="fingerprints-admin" class="dashboard-section" style="display: none;">
                <h3>Scheduled Fingerprints</h3>
                <div id="fingerprints-list"></div>
            </div>

            <!-- Badges Staff -->
            <div id="badges-staff" class="dashboard-section" style="display: none;">
                <h3>Scheduled Badge Appointments</h3>
                <div id="staff-badges-list"></div>
            </div>

            <!-- PC, RR Check -->
            <div id="pc-rr-check" class="dashboard-section" style="display: none;">
                <h3>üîç PC, RR Check</h3>
                <div class="visit-card">
                    <h4>Exclusion List Verification</h4>
                    <p style="color: #666; margin-bottom: 20px;">Enter first and last name to check against the exclusion list</p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div class="form-group">
                            <label for="check-first-name">First Name *</label>
                            <input type="text" id="check-first-name" placeholder="Enter first name" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px;">
                        </div>
                        <div class="form-group">
                            <label for="check-last-name">Last Name *</label>
                            <input type="text" id="check-last-name" placeholder="Enter last name" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px;">
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-bottom: 20px;">
                        <button class="btn btn-primary" onclick="checkPCRRExclusion()" style="padding: 12px 30px; font-size: 16px;">
                            üîç Check Exclusion List
                        </button>
                    </div>
                    
                    <div id="exclusion-check-result"></div>
                </div>
            </div>

            <!-- Advanced Analytics (Staff) -->
            <div id="advanced-analytics-staff" class="dashboard-section" style="display: none;">
                <div id="staff-analytics-container">
                    <!-- Advanced analytics dashboard will be rendered here by JavaScript -->
                </div>
            </div>

            <!-- Old Visits -->
            <div id="old-visits" class="dashboard-section" style="display: none;">
                <h3>üìÅ Old Visits Archive</h3>
                <div class="visit-card">
                    <h4>Daily Archives</h4>
                    <p style="color: #666; margin-bottom: 20px;">Historical data is preserved permanently - no automatic deletion</p>
                    
                    <div style="margin-bottom: 20px;">
                        <label for="archive-date-select">Select Date:</label>
                        <input type="date" id="archive-date-select" onchange="loadOldVisitsForDate()" style="margin-left: 10px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <button class="btn" onclick="loadTodaysOldVisits()" style="margin-left: 10px;">Today</button>
                        <button class="btn" onclick="loadYesterdaysOldVisits()" style="margin-left: 10px;">Yesterday</button>
                        <br><br>
                        <button class="btn" onclick="checkCurrentData()" style="background: #17a2b8; color: white; margin-right: 10px;">üìä Check Current Data</button>
                        <button class="btn" onclick="performDailyArchive()" style="background: #ffc107; color: black;">üì¶ Manual Archive</button>
                    </div>
                    
                    <div id="old-visits-content">
                        <p style="text-align: center; color: #666;">Select a date to view archived visits</p>
                    </div>
                </div>
            </div>

            <!-- Booking Counts -->
            <div id="booking-counts" class="dashboard-section" style="display: none;">
                <h3>Booking Counts by Session & Day</h3>
                <div id="booking-counts-list"></div>
            </div>

            <!-- Daily Statistics Staff -->
            <div id="daily-statistics-staff" class="dashboard-section" style="display: none;">
                <h3>Daily Statistics</h3>
                <div style="margin-bottom: 20px;">
                    <label for="staff-stats-date">Select Date:</label>
                    <input type="date" id="staff-stats-date" onchange="loadStaffDailyStatistics()">
                    <button class="btn" onclick="loadStaffTodayStatistics()">Today</button>
                    <button class="btn" onclick="loadStaffWeeklyStatistics()">This Week</button>
                    <button class="btn" onclick="loadStaffMonthlyStatistics()">This Month</button>
                </div>
                <div id="staff-daily-statistics-list"></div>
            </div>

            <!-- Recruiter Status -->
            <div id="recruiter-status" class="dashboard-section" style="display: none;">
                <h3>My Recruiter Status</h3>
                
                <div class="visit-card">
                    <h4>üìç Daily Check-in Status</h4>
                    <div style="display: flex; align-items: center; gap: 15px; margin: 20px 0;">
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 16px;">
                            <input type="checkbox" id="present-today-toggle" onchange="updatePresentStatus()" style="transform: scale(1.5);">
                            <span id="present-status-text">üè† Present Today</span>
                        </label>
                    </div>
                    
                    <div id="availability-controls" style="display: none;">
                        <h5>üéØ Current Availability</h5>
                        <div style="display: flex; align-items: center; gap: 15px; margin: 15px 0;">
                            <span id="current-status-display" style="font-size: 16px; font-weight: bold;"></span>
                            <button class="btn btn-success" id="mark-free-btn" onclick="markAsFree()" style="display: none;">
                                ‚úÖ Mark as Free
                            </button>
                        </div>
                        
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 15px;">
                            <h6>üìä Today's Stats</h6>
                            <p><strong>Assignments completed:</strong> <span id="completed-assignments">0</span></p>
                            <p><strong>Current assignment:</strong> <span id="current-assignment-info">None</span></p>
                        </div>
                    </div>
                </div>
                
                <!-- Document Completions Queue -->
                <div class="visit-card" style="margin-top: 20px; border: 3px solid #28a745; background: linear-gradient(135deg, #f8fff9 0%, #e8f8e8 100%);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h4 style="color: #28a745; font-size: 20px; margin: 0;">üìã Document Completions Queue</h4>
                        <span id="status-completions-indicator" style="background: #dc3545; color: white; border-radius: 50%; padding: 8px 16px; font-size: 16px; font-weight: bold; display: none; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">0</span>
                    </div>
                    
                    <div style="background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <p style="color: #0056b3; margin: 0; font-size: 14px;">
                            üìù Candidates who have completed all required documents and are ready for your contact.
                        </p>
                    </div>
                    
                    <div id="status-document-completions-list">
                        <p style="color: #666; text-align: center; margin: 20px 0;">Loading document completions...</p>
                    </div>
                </div>

            </div>

            <!-- Recruiter Events -->
            <div id="recruiter-events" class="dashboard-section" style="display: none;">
                <h3>My Events</h3>
                
                <!-- Event Settings -->
                <div class="visit-card">
                    <h4>üéØ Event Configuration</h4>
                    <div class="form-group">
                        <label for="event-name-input">Event Name</label>
                        <input type="text" id="event-name-input" placeholder="Enter event name" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    </div>
                    <div style="margin: 15px 0;">
                        <button class="btn" onclick="updateEventName()">Update Name</button>
                        <button class="btn btn-success" onclick="copyEventLink()" style="margin-left: 10px;">üìã Copy Link</button>
                        <button class="btn btn-primary" onclick="generateEventQR()" style="margin-left: 10px;">üì± Generate QR</button>
                    </div>
                    <div id="event-link-display" style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-top: 10px; display: none;">
                        <p style="margin: 0; font-size: 12px; color: #666;">Event Link:</p>
                        <p style="margin: 5px 0 0 0; word-break: break-all; font-family: monospace; font-size: 12px;" id="event-link-text"></p>
                    </div>
                    <div id="event-qr-display" style="background: #f8f9fa; padding: 15px; border-radius: 4px; margin-top: 10px; display: none; text-align: center;">
                        <p style="margin: 0 0 10px 0; font-size: 12px; color: #666;">QR Code for Event Registration:</p>
                        <div id="event-qr-code"></div>
                    </div>
                </div>

                <!-- Event Statistics -->
                <div class="visit-card">
                    <h4>üìä Event Statistics</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px;">
                        <div style="text-align: center;">
                            <h3 id="total-registrations" style="color: #007bff; margin: 0;">0</h3>
                            <p style="margin: 5px 0 0 0; color: #666;">Total Registrations</p>
                        </div>
                        <div style="text-align: center;">
                            <h3 id="english-speakers" style="color: #28a745; margin: 0;">0</h3>
                            <p style="margin: 5px 0 0 0; color: #666;">English Speakers</p>
                        </div>
                        <div style="text-align: center;">
                            <h3 id="college-credits" style="color: #fd7e14; margin: 0;">0</h3>
                            <p style="margin: 5px 0 0 0; color: #666;">60+ Credits</p>
                        </div>
                    </div>
                </div>


                <!-- Event Registrations -->
                <div id="event-registrations-list"></div>
            </div>


            <!-- Document Completions -->
            <div id="document-completions" class="dashboard-section" style="display: none;">
                <h3>Document Completions Queue</h3>
                <div style="background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <h4 style="color: #0056b3; margin-bottom: 10px;">üìã Queue Information</h4>
                    <p style="color: #0056b3; margin: 0;">These candidates have completed all required documents and are ready for next steps.</p>
                </div>
                
                <!-- View Tabs -->
                <div style="margin-bottom: 20px; text-align: center;">
                    <div style="display: flex; justify-content: center; background: #f8f9fa; border-radius: 25px; padding: 4px; gap: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-width: 500px; margin: 0 auto;">
                        <button id="queue-tab-new" onclick="switchQueueView('new')" style="display: none; background: #4CAF50; color: white; border: none; padding: 12px 24px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: all 0.3s; min-width: 150px;">
                            üî¢ Document Queue
                        </button>
                        <button id="queue-tab-legacy" onclick="switchQueueView('legacy')" style="background: #4CAF50; color: white; border: none; padding: 12px 24px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: all 0.3s; min-width: 150px;">
                            üìã Legacy View
                        </button>
                    </div>
                </div>
                
                <!-- New Document Queue View -->
                <div id="queue-view-new" style="display: none;">
                    <div id="sequential-queue-container">
                        <!-- Sequential queue will be rendered here -->
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <div class="spinner" style="display: inline-block; width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid #4CAF50; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 10px;"></div>
                            Loading sequential queue...
                        </div>
                    </div>
                </div>
                
                <!-- Legacy View -->
                <div id="queue-view-legacy" style="display: block;">
                    <!-- Filter Buttons -->
                    <div style="margin-bottom: 20px; text-align: center;">
                        <div style="display: inline-flex; background: #f8f9fa; border-radius: 25px; padding: 4px; gap: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <button class="filter-btn" id="filter-all" onclick="filterDocumentCompletions('all')" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: all 0.3s;">
                                üìã All
                            </button>
                            <button class="filter-btn" id="filter-pending" onclick="filterDocumentCompletions('pending')" style="background: transparent; color: #666; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: all 0.3s;">
                                ‚è≥ Pending
                            </button>
                            <button class="filter-btn" id="filter-contacted" onclick="filterDocumentCompletions('contacted')" style="background: transparent; color: #666; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: all 0.3s;">
                                üìû Contacted
                            </button>
                            <button class="filter-btn" id="filter-attended" onclick="filterDocumentCompletions('attended')" style="background: transparent; color: #666; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: all 0.3s;">
                                ‚úÖ Attended
                            </button>
                        </div>
                    </div>
                    
                    <div id="document-completions-list"></div>
                </div>
            </div>
        </div>

        <!-- Admin Dashboard -->
        <div id="admin-dashboard" class="screen">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <h2>Administrator Panel</h2>
                <button class="btn btn-danger" onclick="adminLogout()">Logout</button>
            </div>
            
            <div class="nav-buttons">
                <button class="nav-btn" onclick="showAdminSection('manage-staff')">Manage Staff</button>
                <button class="nav-btn" onclick="showAdminSection('manage-users')">Create Users</button>
                <button class="nav-btn" onclick="showAdminSection('manage-recruiters')">Manage Recruiters</button>
                <button class="nav-btn" onclick="showAdminSection('exclusion-list')">Exclusion List</button>
                <button class="nav-btn" onclick="showAdminSection('queue-management')">Queue Management</button>
                <button class="nav-btn" onclick="showAdminSection('daily-archive')">Daily Archive</button>
                <button class="nav-btn" onclick="showAdminSection('all-visits')">All Visits</button>
                <button class="nav-btn" onclick="showAdminSection('all-info-sessions')">All Info Sessions</button>
                <button class="nav-btn" onclick="showAdminSection('all-fingerprints')">All Fingerprints</button>
                <button class="nav-btn" onclick="showAdminSection('all-badges')">All Badges</button>
                <button class="nav-btn" onclick="showAdminSection('all-orientations')">All Orientations</button>
                <button class="nav-btn" onclick="showAdminSection('admin-booking-counts')">Booking Counts</button>
                <button class="nav-btn" onclick="showAdminSection('daily-statistics')">Daily Statistics</button>
                <button class="nav-btn" onclick="showAdminSection('advanced-analytics')" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white;">üìä Advanced Analytics</button>
            </div>

            <!-- Manage Staff -->
            <div id="manage-staff" class="dashboard-section">
                <h3>Staff Management</h3>
                
                <!-- Add New Staff -->
                <div class="visit-card">
                    <h4>Add New Staff Member</h4>
                    <form onsubmit="addStaffMember(event)">
                        <div class="two-column">
                            <div class="form-group">
                                <label>Full Name *</label>
                                <input type="text" id="new-staff-name" required>
                            </div>
                            <div class="form-group">
                                <label>Email *</label>
                                <input type="email" id="new-staff-email" required>
                            </div>
                        </div>
                        <div class="two-column">
                            <div class="form-group">
                                <label>Team *</label>
                                <select id="new-staff-team" required>
                                    <option value="">Select team</option>
                                    <option value="recruiting">Recruiting Team</option>
                                    <option value="talent">Talent Team</option>
                                    <option value="management">Management Team</option>
                                    <option value="front-desk">Front Desk Team</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Title *</label>
                                <input type="text" id="new-staff-title" required>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Initial Password *</label>
                            <input type="password" id="new-staff-password" required>
                        </div>
                        <div style="text-align: center;">
                            <button type="submit" class="btn btn-success">Add Staff Member</button>
                        </div>
                    </form>
                </div>

                <!-- Current Staff List -->
                <div style="margin-top: 30px;">
                    <h4>Current Staff Members</h4>
                    <div id="staff-list"></div>
                </div>
            </div>

            <!-- All Visits -->
            <div id="all-visits" class="dashboard-section" style="display: none;">
                <h3>All Team Visits</h3>
                <div id="admin-visits-list"></div>
            </div>

            <!-- All Info Sessions -->
            <div id="all-info-sessions" class="dashboard-section" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3>All Info Sessions</h3>
                    <div>
                        <button class="btn" onclick="selectAllInfoSessions()" id="select-all-info-sessions-btn">Select All</button>
                        <button class="btn btn-danger" onclick="deleteSelectedInfoSessions()" id="delete-selected-info-sessions-btn" disabled>Delete Selected</button>
                    </div>
                </div>
                <div id="admin-info-sessions-list"></div>
            </div>

            <!-- All Fingerprints -->
            <div id="all-fingerprints" class="dashboard-section" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3>All Fingerprints</h3>
                    <div>
                        <button class="btn" onclick="selectAllFingerprints()" id="select-all-fingerprints-btn">Select All</button>
                        <button class="btn btn-danger" onclick="deleteSelectedFingerprints()" id="delete-selected-fingerprints-btn" disabled>Delete Selected</button>
                    </div>
                </div>
                <div id="admin-fingerprints-list"></div>
            </div>

            <!-- All Badges -->
            <div id="all-badges" class="dashboard-section" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3>All Badge Appointments</h3>
                    <div>
                        <button class="btn" onclick="selectAllBadges()" id="select-all-badges-btn">Select All</button>
                        <button class="btn btn-danger" onclick="deleteSelectedBadges()" id="delete-selected-badges-btn" disabled>Delete Selected</button>
                    </div>
                </div>
                <div id="admin-badges-list"></div>
            </div>

            <!-- All Orientations -->
            <div id="all-orientations" class="dashboard-section" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3>All New Hire Orientations</h3>
                    <div>
                        <button class="btn" onclick="selectAllOrientations()" id="select-all-orientations-btn">Select All</button>
                        <button class="btn btn-danger" onclick="deleteSelectedOrientations()" id="delete-selected-orientations-btn" disabled>Delete Selected</button>
                    </div>
                </div>
                
                <!-- Passed List Management -->
                <div class="visit-card" style="margin-bottom: 30px; background: linear-gradient(135deg, #e3f2fd, #bbdefb);">
                    <h4 style="color: #1976d2; margin-bottom: 15px;">üìã Passed List Management</h4>
                    
                    <!-- Current List Info -->
                    <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.7); border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span id="passed-list-count">Current List: Loading...</span>
                            <button class="btn btn-info" onclick="downloadPassedListTemplate()" style="font-size: 12px; padding: 6px 12px;">üì• Download Template</button>
                        </div>
                    </div>
                    
                    <!-- Upload Options -->
                    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                        <div class="form-group" style="flex: 1; min-width: 250px;">
                            <label>üì§ Add New People (Excel File):</label>
                            <input type="file" id="passed-list-add-file" accept=".xlsx,.xls" onchange="handlePassedListAdd()">
                            <small style="color: #666;">Upload Excel file with new names to ADD to existing list</small>
                        </div>
                        
                        <div class="form-group" style="flex: 1; min-width: 250px;">
                            <label>üîÑ Replace Entire List (Excel File):</label>
                            <input type="file" id="passed-list-replace-file" accept=".xlsx,.xls" onchange="handlePassedListReplace()">
                            <small style="color: #666;">Upload Excel file to REPLACE the entire list</small>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <button class="btn btn-warning" onclick="clearPassedList()" style="font-size: 14px;">üóëÔ∏è Clear All Data</button>
                        <button class="btn btn-success" onclick="exportPassedList()" style="font-size: 14px;">üìä Export Current List</button>
                    </div>
                </div>
                
                <div id="admin-orientations-list"></div>
            </div>

            <!-- Admin Booking Counts -->
            <div id="admin-booking-counts" class="dashboard-section" style="display: none;">
                <h3>All Booking Counts by Session & Day</h3>
                <div id="admin-booking-counts-list"></div>
            </div>

            <!-- Daily Statistics -->
            <div id="daily-statistics" class="dashboard-section" style="display: none;">
                <h3>üìä Daily Statistics - All Historical Data</h3>
                
                <!-- Enhanced Controls -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                        <div>
                            <label for="stats-date" style="font-weight: bold;">üìÖ Select Date:</label>
                            <input type="date" id="stats-date" onchange="loadDailyStatistics()" style="margin-left: 8px; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                        </div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn" onclick="loadTodayStatistics()" style="background: #28a745; color: white;">üìÖ Today</button>
                            <button class="btn" onclick="loadWeeklyStatistics()" style="background: #007bff; color: white;">üìÖ This Week</button>
                            <button class="btn" onclick="loadMonthlyStatistics()" style="background: #6f42c1; color: white;">üìÖ This Month</button>
                            <button class="btn" onclick="loadHistoricalDataFrame()" style="background: #fd7e14; color: white;">üìä Complete History</button>
                            <button class="btn" onclick="debugCurrentDate()" style="background: #dc3545; color: white; font-size: 12px;">üîç Debug Selected Date</button>
                            <button class="btn" onclick="debugDateData('2024-09-10')" style="background: #17a2b8; color: white; font-size: 12px;">üîç Debug 9/10/24</button>
                        </div>
                    </div>
                    <div style="color: #666; font-size: 14px;">
                        üí° <strong>All data preserved:</strong> This shows live data from all collections. Historical records are never deleted.
                    </div>
                </div>
                
                <div id="daily-statistics-list">
                    <p style="text-align: center; color: #666; padding: 40px 0;">Select a date to view statistics</p>
                </div>
            </div>

            <!-- Advanced Analytics Dashboard -->
            <div id="advanced-analytics" class="dashboard-section" style="display: none;">
                <div id="admin-dashboard-container">
                    <!-- Advanced analytics dashboard will be rendered here by JavaScript -->
                </div>
            </div>

            <!-- Manage Users -->
            <div id="manage-users" class="dashboard-section" style="display: none;">
                <h3>User Management</h3>
                
                <!-- Create New User -->
                <div class="visit-card">
                    <h4>Create New User Account</h4>
                    <form onsubmit="createNewUser(event)">
                        <div class="two-column">
                            <div class="form-group">
                                <label>Full Name *</label>
                                <input type="text" id="new-user-name" required>
                            </div>
                            <div class="form-group">
                                <label>Email *</label>
                                <input type="email" id="new-user-email" required>
                            </div>
                        </div>
                        <div class="two-column">
                            <div class="form-group">
                                <label>User Type *</label>
                                <select id="new-user-type" required onchange="updateUserTypeFields()">
                                    <option value="">Select user type</option>
                                    <option value="staff">Staff Member</option>
                                    <option value="admin">Administrator</option>
                                </select>
                            </div>
                            <div class="form-group" id="team-field" style="display: none;">
                                <label>Team</label>
                                <select id="new-user-team">
                                    <option value="">Select team</option>
                                    <option value="recruiting">Recruiting Team</option>
                                    <option value="talent">Talent Team</option>
                                </select>
                            </div>
                        </div>
                        <div class="two-column">
                            <div class="form-group" id="title-field" style="display: none;">
                                <label>Job Title</label>
                                <input type="text" id="new-user-title" placeholder="e.g. Recruiter, HR Manager">
                            </div>
                            <div class="form-group">
                                <label>Initial Password *</label>
                                <input type="password" id="new-user-password" required>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="send-welcome-email" checked>
                                Send welcome email with login instructions
                            </label>
                        </div>
                        <div style="text-align: center;">
                            <button type="submit" class="btn btn-success">Create User Account</button>
                        </div>
                    </form>
                </div>

                <!-- All Users List -->
                <div style="margin-top: 30px;">
                    <h4>All User Accounts</h4>
                    <div id="all-users-list"></div>
                </div>
            </div>

            <!-- Manage Recruiters -->
            <div id="manage-recruiters" class="dashboard-section" style="display: none;">
                <h3>üë• Recruiter Availability Management</h3>
                
                <!-- Today's Recruiter Status -->
                <div class="visit-card">
                    <h4>üìÖ Today's Recruiter Status</h4>
                    <p style="color: #666; margin-bottom: 20px;">Manage which recruiters are present and available for document completion assignments today.</p>
                    
                    <div id="todays-recruiter-status" style="margin-bottom: 20px;">
                        <p style="text-align: center; color: #666;">Loading recruiters...</p>
                    </div>
                    
                    <div style="text-align: center;">
                        <button class="btn btn-success" onclick="refreshRecruitersStatus()">üîÑ Refresh Status</button>
                    </div>
                </div>

                <!-- Add New Recruiter Availability -->
                <div class="visit-card" style="margin-top: 30px;">
                    <h4>‚ûï Set Recruiter Availability</h4>
                    <form onsubmit="setRecruiterAvailability(event)">
                        <div class="two-column">
                            <div class="form-group">
                                <label>Select Recruiter *</label>
                                <select id="recruiter-select" required>
                                    <option value="">Loading recruiters...</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Date *</label>
                                <input type="date" id="availability-date" required>
                            </div>
                        </div>
                        <div class="two-column">
                            <div class="form-group">
                                <label>Status *</label>
                                <select id="availability-status" required>
                                    <option value="">Select status</option>
                                    <option value="present-free">Present & Free</option>
                                    <option value="present-busy">Present & Busy</option>
                                    <option value="not-present">Not Present</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Notes (optional)</label>
                                <input type="text" id="availability-notes" placeholder="Meeting, interview, etc.">
                            </div>
                        </div>
                        <div style="text-align: center;">
                            <button type="submit" class="btn btn-success">üíæ Set Availability</button>
                        </div>
                    </form>
                </div>

                <!-- All Recruiter Availability -->
                <div style="margin-top: 30px;">
                    <h4>üìã All Recruiter Availability Records</h4>
                    <div style="margin-bottom: 15px;">
                        <button class="btn" onclick="loadRecruitersAvailability('today')">Today</button>
                        <button class="btn" onclick="loadRecruitersAvailability('week')" style="margin-left: 10px;">This Week</button>
                        <button class="btn" onclick="loadRecruitersAvailability('all')" style="margin-left: 10px;">All Records</button>
                    </div>
                    <div id="all-recruiters-availability"></div>
                </div>
            </div>

            <!-- Exclusion List -->
            <div id="exclusion-list" class="dashboard-section" style="display: none;">
                <h3>PC/RR Exclusion List Management</h3>
                
                <!-- Upload Excel File -->
                <div class="visit-card">
                    <h4>üìÑ Upload Exclusion List (Excel)</h4>
                    <p style="margin-bottom: 15px; color: #666;">Upload an Excel file with columns: Name, SSN (last 4 digits), Status (PC/RR)</p>
                    
                    <div class="form-group">
                        <label>Select Excel File *</label>
                        <input type="file" id="exclusion-file" accept=".xlsx,.xls" onchange="loadExclusionFile(event)">
                    </div>
                    
                    <div id="file-status" style="margin: 15px 0;"></div>
                    
                    <div style="text-align: center;">
                        <button type="button" class="btn btn-success" onclick="saveExclusionList()" id="save-exclusion-btn" disabled>Save Exclusion List</button>
                        <button type="button" class="btn" onclick="clearExclusionList()" style="margin-left: 10px;">Clear Current List</button>
                    </div>
                </div>

                <!-- Current Exclusion List -->
                <div style="margin-top: 30px;">
                    <h4>Current Exclusion List</h4>
                    <div id="current-exclusion-list"></div>
                </div>
            </div>

            <!-- Queue Management (admin only) -->
            <div id="queue-management" class="dashboard-section" style="display: none;">
                <h3>üî¢ Queue Management</h3>
                <div class="visit-card">
                    <h4>Document Completion Queue Control</h4>
                    <p style="color: #666; margin-bottom: 20px;">Manage the daily queue numbers for document completions. Queue numbers reset automatically each day, but you can manually reset them if needed.</p>
                    
                    <div id="current-queue-status" style="background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                        <h5 style="color: #0056b3; margin: 0 0 10px 0;">üìä Current Queue Status</h5>
                        <div id="queue-status-info" style="color: #0056b3;">Loading...</div>
                    </div>
                    
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                        <h5 style="margin: 0 0 10px 0; color: #856404;">‚ö†Ô∏è Reset Queue Numbers</h5>
                        <p style="margin: 0 0 15px 0; color: #856404;">
                            This will reset today's document completion queue numbers back to 1. 
                            Use this if you need to restart the numbering for any reason.
                        </p>
                        <button class="btn btn-warning" onclick="confirmResetQueue()" style="color: black;">
                            üîÑ Reset Today's Queue Numbers
                        </button>
                    </div>
                    
                    <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 15px;">
                        <h5 style="margin: 0 0 10px 0; color: #721c24;">üóëÔ∏è Clear All Document Completions</h5>
                        <p style="margin: 0 0 15px 0; color: #721c24;">
                            This will permanently delete ALL document completion records for today. 
                            This action cannot be undone!
                        </p>
                        <button class="btn btn-danger" onclick="confirmClearCompletions()">
                            üóëÔ∏è Clear Today's Document Completions
                        </button>
                    </div>
                </div>
            </div>

            <!-- Daily Archive (admin only) -->
            <div id="daily-archive" class="dashboard-section" style="display: none;">
                <h3>üìÅ Daily Archive Management</h3>
                <div class="visit-card">
                    <h4>Automated Archive System</h4>
                    <p style="color: #666; margin-bottom: 20px;">All data is now preserved permanently - automatic deletion has been disabled</p>
                    
                    <div style="background: #d1ecf1; border: 1px solid #bee5eb; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                        <h5 style="margin: 0 0 10px 0; color: #0c5460;">üìÅ Manual Archive (Optional)</h5>
                        <p style="margin: 0 0 15px 0; color: #0c5460;">
                            Create a snapshot backup of current data. All original records will remain preserved permanently.
                            This is now optional since automatic deletion is disabled.
                        </p>
                        <button class="btn" onclick="confirmManualArchive()" style="background: #17a2b8; color: white;">
                            üì¶ Create Archive Backup
                        </button>
                    </div>
                    
                    <div>
                        <h5>Archive Status</h5>
                        <p id="last-archive-info">Checking last archive...</p>
                        <button class="btn" onclick="checkArchiveStatus()">Refresh Status</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Edit Staff Modal -->
        <div id="edit-staff-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; width: 90%; max-width: 500px;">
                <h3>Edit Staff Member</h3>
                <form onsubmit="updateStaffMember(event)">
                    <input type="hidden" id="edit-staff-id">
                    <div class="form-group">
                        <label>Full Name *</label>
                        <input type="text" id="edit-staff-name" required>
                    </div>
                    <div class="form-group">
                        <label>Email *</label>
                        <input type="email" id="edit-staff-email" required>
                    </div>
                    <div class="form-group">
                        <label>Team *</label>
                        <select id="edit-staff-team" required>
                            <option value="recruiting">Recruiting Team</option>
                            <option value="talent">Talent Team</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Title *</label>
                        <input type="text" id="edit-staff-title" required>
                    </div>
                    <div class="form-group">
                        <label>New Password (leave blank to keep current)</label>
                        <input type="password" id="edit-staff-password">
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button type="button" class="btn" onclick="closeEditModal()">Cancel</button>
                        <button type="submit" class="btn btn-success">Update Staff</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Update Orientation Status Modal -->
        <div id="orientation-status-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; width: 90%; max-width: 500px;">
                <h3>Update Orientation Status</h3>
                <form onsubmit="saveOrientationStatus(event)">
                    <input type="hidden" id="orientation-id">
                    <div class="form-group">
                        <h4 id="orientation-name-display" style="margin-bottom: 15px; color: #333;"></h4>
                    </div>
                    
                    <div class="checkbox-group" style="display: block; margin-bottom: 15px;">
                        <div class="checkbox-item" style="margin-bottom: 10px;">
                            <input type="checkbox" id="modal-badge-printed">
                            <label for="modal-badge-printed">üÜî Badge Printed</label>
                        </div>
                        <div class="checkbox-item" style="margin-bottom: 10px;">
                            <input type="checkbox" id="modal-pending-steps" onchange="toggleModalPendingStepsField()">
                            <label for="modal-pending-steps">‚è≥ Has Pending Steps</label>
                        </div>
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label for="modal-fingerprint-status">üëÜ Fingerprint Status</label>
                            <select id="modal-fingerprint-status" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="pending">‚è≥ Pending</option>
                                <option value="ready">‚úÖ Ready/Completed</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-group" id="modal-pending-steps-field" style="display: none;">
                        <label>Pending Steps Details</label>
                        <textarea id="modal-pending-details" rows="3" placeholder="Describe the pending steps..."></textarea>
                    </div>

                    <div style="text-align: center; margin-top: 20px;">
                        <button type="button" class="btn" onclick="closeOrientationStatusModal()">Cancel</button>
                        <button type="submit" class="btn btn-success">Update Status</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script>
        // üî• CONFIGURACI√ìN FIREBASE - Kelly Education Lee County
        const firebaseConfig = {
            apiKey: "AIzaSyAzja8bLslbkepHrIzyYtOE2cxaMvjMzFk",
            authDomain: "kelly-education-lee-coun-a4aae.firebaseapp.com",
            projectId: "kelly-education-lee-coun-a4aae",
            storageBucket: "kelly-education-lee-coun-a4aae.firebasestorage.app",
            messagingSenderId: "1091308170337",
            appId: "1:1091308170337:web:7024863cfbeb63526a4e20",
            measurementId: "G-15JH7LT5S9"
        };

        // Inicializar Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        // GLOBAL MOBILE DETECTION VARIABLES - TO FIX isMobile undefined errors
        // Global mobile detection - used throughout the application
        window.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        window.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        window.isAndroid = /Android/i.test(navigator.userAgent);
        window.isChrome = /Chrome/i.test(navigator.userAgent);

        let currentUser = null;
        let isAdmin = false;
        let realtimeListeners = []; // Para almacenar los listeners activos
        let audioContext = null; // Para el contexto de audio
        let audioEnabled = false; // Para saber si el audio est√° habilitado
        let exclusionListData = []; // Para almacenar la lista de exclusi√≥n
        let tempExclusionData = []; // Para datos temporales del Excel antes de guardar

        // Helper function to get or create staff record
        async function getStaffRecord() {
            if (!currentUser) {
                throw new Error('No user is logged in');
            }
            
            try {
                const staffSnapshot = await db.collection('staff')
                    .where('email', '==', currentUser.email)
                    .get();
                    
                if (!staffSnapshot.empty) {
                    // Staff record found
                    const staffData = staffSnapshot.docs[0].data();
                    const staffId = staffSnapshot.docs[0].id;
                    console.log('‚úÖ Staff record found:', staffData.name);
                    return { staffData, staffId };
                }
                
                // Staff record not found - create one
                console.log('‚ö†Ô∏è  Staff record not found for:', currentUser.email);
                console.log('üîÑ Creating staff record...');
                
                const newStaffData = {
                    name: currentUser.displayName || currentUser.email.split('@')[0],
                    email: currentUser.email,
                    team: 'staff', // Default team
                    title: 'Staff Member',
                    createdAt: new Date().toISOString(),
                    autoCreated: true
                };
                
                const docRef = await db.collection('staff').add(newStaffData);
                console.log('‚úÖ Staff record created with ID:', docRef.id);
                
                showSuccessMessage(`Staff record created for ${newStaffData.name}! You now have access to all features.`);
                
                return { 
                    staffData: newStaffData, 
                    staffId: docRef.id 
                };
                
            } catch (error) {
                console.error('‚ùå Error getting/creating staff record:', error);
                throw error;
            }
        }

        // Cargar lista de exclusi√≥n al iniciar la aplicaci√≥n
        async function loadExclusionListData() {
            try {
                const exclusionDoc = await db.collection('settings').doc('exclusion-list').get();
                if (exclusionDoc.exists) {
                    exclusionListData = exclusionDoc.data().data || [];
                    console.log('Exclusion list loaded:', exclusionListData.length, 'records');
                }
            } catch (error) {
                console.error('Error loading exclusion list:', error);
            }
        }

        // Cargar lista al inicializar
        loadExclusionListData();

        // Check exclusion list function for PC, RR Check section
        function checkPCRRExclusion() {
            console.log('checkPCRRExclusion called');
            const firstName = document.getElementById('check-first-name').value.trim();
            const lastName = document.getElementById('check-last-name').value.trim();
            const resultDiv = document.getElementById('exclusion-check-result');
            
            console.log('Names entered:', firstName, lastName);
            console.log('Exclusion list data length:', exclusionListData.length);
            
            if (!firstName || !lastName) {
                resultDiv.innerHTML = '<div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 15px; color: #856404;"><p>‚ö†Ô∏è Please enter both first and last name</p></div>';
                return;
            }
            
            // Search exclusion list
            const searchName = `${firstName.toLowerCase()} ${lastName.toLowerCase()}`;
            const foundExclusions = exclusionListData.filter(record => {
                const recordName = record.name ? record.name.toLowerCase() : '';
                return recordName.includes(firstName.toLowerCase()) && recordName.includes(lastName.toLowerCase());
            });
            
            if (foundExclusions.length === 0) {
                resultDiv.innerHTML = `
                    <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 20px; color: #155724;">
                        <h4 style="margin: 0 0 10px 0; color: #155724;">‚úÖ CLEAR</h4>
                        <p style="margin: 0; font-size: 16px;"><strong>${firstName} ${lastName}</strong> is NOT found in the exclusion list</p>
                        <p style="margin: 10px 0 0 0; font-size: 14px; opacity: 0.8;">Safe to proceed with employment process</p>
                    </div>
                `;
            } else {
                let alertHtml = `
                    <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 20px; color: #721c24;">
                        <h4 style="margin: 0 0 15px 0; color: #721c24;">üö® EXCLUSION ALERT</h4>
                        <p style="margin: 0 0 15px 0; font-size: 16px; font-weight: bold;"><strong>${firstName} ${lastName}</strong> found in exclusion list:</p>
                `;
                
                foundExclusions.forEach((record, index) => {
                    const ssnDisplay = record.ssn ? `***${record.ssn.slice(-4)}` : 'N/A';
                    alertHtml += `
                        <div style="background: white; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; margin-bottom: 10px;">
                            <p style="margin: 0 0 5px 0; font-weight: bold;">Match ${index + 1}:</p>
                            <p style="margin: 0 0 5px 0;"><strong>Name:</strong> ${record.name || 'N/A'}</p>
                            <p style="margin: 0 0 5px 0;"><strong>Code:</strong> ${record.code || 'N/A'}</p>
                            <p style="margin: 0;"><strong>SSN:</strong> ${ssnDisplay}</p>
                        </div>
                    `;
                });
                
                alertHtml += `
                        <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 10px; margin-top: 15px;">
                            <p style="margin: 0; font-size: 14px; color: #856404;">
                                <strong>‚ö†Ô∏è WARNING:</strong> Verify identity and consult with management before proceeding
                            </p>
                        </div>
                    </div>
                `;
                
                resultDiv.innerHTML = alertHtml;
            }
            
            // Clear form fields
            document.getElementById('check-first-name').value = '';
            document.getElementById('check-last-name').value = '';
        }

        // Navegaci√≥n entre pantallas
        // Update forms with today's date
        function updateFormDates() {
            try {
                const today = new Date();
                const shortDate = today.toISOString().split('T')[0];
                
                // Update new hire orientation label
                const nhoLabel = document.getElementById('nho-time-label');
                if (nhoLabel) {
                    nhoLabel.textContent = `Orientation Schedule for TODAY (${shortDate}) *`;
                }
                
                // Update info session label
                const infoLabel = document.getElementById('info-time-label');
                if (infoLabel) {
                    infoLabel.textContent = `Info Session Time for TODAY (${shortDate}) *`;
                }
                
                // Update badge label
                const badgeLabel = document.getElementById('badge-time-label');
                if (badgeLabel) {
                    badgeLabel.textContent = `Appointment Time for TODAY (${shortDate}) *`;
                }
                
                // Update fingerprints label
                const fingerLabel = document.getElementById('finger-time-label');
                if (fingerLabel) {
                    fingerLabel.textContent = `Appointment Time for TODAY (${shortDate}) *`;
                }
                
                console.log('üìÖ Updated all form dates to:', shortDate);
            } catch (error) {
                console.error('Error updating form dates:', error);
            }
        }

        function showScreen(screenId) {
            console.log(`üîÑ showScreen called with screenId: ${screenId}`);
            
            // Clean up any active real-time listeners when switching screens
            if (eventRegistrationsListener) {
                eventRegistrationsListener();
                eventRegistrationsListener = null;
            }
            
            console.log(`üîÑ Removing active class from all screens...`);
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            console.log(`üîÑ Looking for target screen: ${screenId}`);
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                console.log(`üîÑ Found target screen, adding active class...`);
                targetScreen.classList.add('active');
                console.log(`‚úÖ Successfully showed screen: ${screenId}`);
                
                // Force visibility check
                const isVisible = targetScreen.classList.contains('active');
                console.log(`üîç Screen visibility check - has active class: ${isVisible}`);
            } else {
                console.error(`‚ùå Screen with id '${screenId}' not found!`);
                return;
            }
        }
        
        // Simplified mobile screen navigation
        function showScreenMobile(screenId) {
            // Use global mobile detection variables
            const debugDiv = document.getElementById('mobile-debug');
            
            function mobileLog(message) {
                console.log(message);
                if ((window.isIOS || (window.isAndroid && window.isChrome)) && debugDiv) {
                    debugDiv.innerHTML += message + '<br>';
                    debugDiv.scrollTop = debugDiv.scrollHeight;
                }
            }
            
            mobileLog(`üì± showScreenMobile called with screenId: ${screenId}`);
            
            // Clean up any active real-time listeners when switching screens
            if (eventRegistrationsListener) {
                eventRegistrationsListener();
                eventRegistrationsListener = null;
            }
            
            mobileLog(`üì± Mobile: Removing active class from all screens...`);
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            mobileLog(`üì± Mobile: Looking for target screen: ${screenId}`);
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                mobileLog(`üì± Mobile: Found target screen, showing...`);
                
                // Special handling for success screen - ensure it's at the top
                if (screenId === 'document-completion-success') {
                    mobileLog('üîÑ Special handling for success screen...');
                    // Force scroll to top immediately
                    window.scrollTo(0, 0);
                    document.body.scrollTop = 0;
                    document.documentElement.scrollTop = 0;
                }
                
                targetScreen.classList.add('active');
                
                // Force visibility check for mobile devices
                setTimeout(() => {
                    const isVisible = targetScreen.classList.contains('active');
                    mobileLog(`üì± Mobile: Screen visibility check: ${isVisible}`);
                    
                    if ((window.isIOS || (window.isAndroid && window.isChrome)) && debugDiv) {
                        debugDiv.innerHTML += `üîç Final check - Screen active: ${isVisible}<br>`;
                        if (isVisible) {
                            debugDiv.innerHTML += '‚úÖ SUCCESS: Screen should be visible!<br>';
                            // Force another scroll to top for success screen
                            if (screenId === 'document-completion-success') {
                                window.scrollTo(0, 0);
                                debugDiv.innerHTML += 'üîù Forced scroll to top<br>';
                            }
                            // Hide debug div after success
                            setTimeout(() => {
                                if (debugDiv && debugDiv.parentNode) {
                                    debugDiv.style.display = 'none';
                                }
                            }, 5000);
                        }
                    }
                }, 200);
                
                mobileLog(`‚úÖ Mobile: Successfully showed screen: ${screenId}`);
            } else {
                mobileLog(`‚ùå Mobile: Screen with id '${screenId}' not found!`);
            }
        }

        function showVisitForm(type) {
            const formMap = {
                'team': 'team-visit-form',
                'info-session': 'info-session-form',
                'fingerprints': 'fingerprints-form',
                'badge': 'badge-form',
                'new-hire-orientation': 'new-hire-orientation-form'
            };
            
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(formMap[type]).classList.add('active');
        }


        // Submit team visit
        async function submitTeamVisit(event) {
            event.preventDefault();
            
            try {
                const teamSelect = document.getElementById('team-select');
                const memberSelect = document.getElementById('team-member');
                
                if (!teamSelect || !teamSelect.value) {
                    throw new Error('Please select a team');
                }
                
                if (!memberSelect || !memberSelect.value) {
                    throw new Error('Please select a team member');
                }
                
                const selectedOption = memberSelect.options[memberSelect.selectedIndex];
                const visitorName = document.getElementById('team-name').value;
                const reason = document.getElementById('visit-reason').value;
                
                if (!visitorName.trim()) {
                    throw new Error('Please enter visitor name');
                }
                
                if (!reason.trim()) {
                    throw new Error('Please enter reason for visit');
                }
                
                const visitData = {
                    type: 'team-visit',
                    visitorName: visitorName,
                    visitorEmail: document.getElementById('team-email').value || '',
                    team: teamSelect.value,
                    teamMember: memberSelect.value,
                    teamMemberName: selectedOption.dataset.name,
                    teamMemberEmail: selectedOption.dataset.email,
                    reason: reason,
                    timestamp: new Date().toISOString(),
                    status: 'pending'
                };
                
                console.log('üîç Visit data to save:', visitData);

                await db.collection('visits').add(visitData);
                console.log('‚úÖ Visita registrada exitosamente');
                
                showSuccessMessage('Visit registered successfully! Team member will be notified.');
                playSuccessSound(); // Reproducir sonido de √©xito
                document.querySelector('#team-visit-form form').reset();
                setTimeout(() => showScreen('visitor'), 2000);
                
            } catch (error) {
                console.error('‚ùå Error registrando visita:', error);
                console.error('‚ùå Error stack:', error.stack);
                showErrorMessage(`Error registering visit: ${error.message}`);
            }
        }

        // Select time slot function
        function selectTimeSlot(time, element) {
            // Remove selected class from all time slots
            document.querySelectorAll('.time-slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            
            // Add selected class to clicked slot
            element.classList.add('selected');
            
            // Set the hidden input value
            document.getElementById('info-time').value = time;
            
            console.log('‚è∞ Time slot selected:', time);
        }

        // Select NHO time slot function
        function selectNHOTimeSlot(time, element) {
            // Remove selected class from all time slots
            document.querySelectorAll('.time-slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            
            // Add selected class to clicked slot
            element.classList.add('selected');
            
            // Set the hidden input value
            document.getElementById('nho-time').value = time;
            
            console.log('‚è∞ NHO Time slot selected:', time);
        }

        // Submit info session
        async function submitInfoSession(event) {
            event.preventDefault();
            
            console.log('üîç Iniciando registro de Info Session...');
            console.log('üîç Event:', event);
            console.log('üîç Firebase db:', typeof db, db);
            console.log('üîç Firebase auth:', firebase.auth().currentUser);
            
            // Detecci√≥n espec√≠fica de m√≥vil
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isChrome = /Chrome/i.test(navigator.userAgent);
            console.log('üì± Es m√≥vil:', isMobile);
            console.log('üåê Es Chrome:', isChrome);
            console.log('üîç User Agent:', navigator.userAgent);
            
            try {
                // Debugging espec√≠fico para Chrome m√≥vil - verificar preventDefault
                if (isMobile && isChrome) {
                    console.log('üì± Event preventDefault status:', event.defaultPrevented);
                    console.log('üì± Event type:', event.type);
                    console.log('üì± Event target:', event.target);
                    
                    // Intentar preventDefault otra vez por si acaso
                    if (!event.defaultPrevented) {
                        event.preventDefault();
                        console.log('üì± Aplicando preventDefault adicional');
                    }
                }
                
                // Get current date and time for registration
                const now = new Date();
                const registrationDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
                const registrationTime = now.toLocaleString(); // Local date and time string
                
                console.log('üìö Info Session Registration:', {
                    registrationDate,
                    registrationTime
                });
                
                // Verificar elementos del formulario (nuevos campos separados)
                const firstNameElement = document.getElementById('info-first-name');
                const lastNameElement = document.getElementById('info-last-name');
                const emailElement = document.getElementById('info-email');
                const phoneElement = document.getElementById('info-phone');
                const timeElement = document.getElementById('info-time');
                const sessionTypeElement = document.getElementById('info-session-type');
                
                console.log('üîç Elementos del formulario:', {
                    firstNameElement, lastNameElement, emailElement, phoneElement, timeElement, sessionTypeElement
                });
                
                if (!firstNameElement) throw new Error('First name field not found');
                if (!lastNameElement) throw new Error('Last name field not found');
                if (!emailElement) throw new Error('Email field not found');
                if (!phoneElement) throw new Error('Phone field not found');
                if (!timeElement) throw new Error('Time field not found');
                if (!sessionTypeElement) throw new Error('Session type field not found');
                
                const firstName = firstNameElement.value.trim();
                const lastName = lastNameElement.value.trim();
                const name = `${firstName} ${lastName}`;
                const email = emailElement.value.trim();
                const phone = phoneElement.value.trim();
                const time = timeElement.value;
                const sessionType = sessionTypeElement.value;
                
                console.log('üîç Valores del formulario:', {
                    firstName, lastName, name, email, phone, time, sessionType, registrationDate
                });
                
                // Validaciones
                if (!firstName) throw new Error('Please enter your first name');
                if (!lastName) throw new Error('Please enter your last name');
                if (!email) throw new Error('Please enter your email');
                if (!phone) throw new Error('Please enter your phone number');
                if (!time) throw new Error('Please select a time slot');
                if (!sessionType) throw new Error('Please select session type');
                
                // Validar formato de email
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(email)) {
                    throw new Error('Please enter a valid email address');
                }
                
                // Get document status checkboxes - only for staff/admin
                let ob365Sent = false;
                let i9Sent = false;
                let existingI9 = false;
                let ineligible = false;
                
                // Only capture checkbox values if user is authenticated (staff or admin)
                if (currentUser && (isAdmin || (currentUser.role === 'staff'))) {
                    console.log('üîë Staff/Admin user - capturing checkbox values');
                    ob365Sent = document.getElementById('info-ob365-sent').checked;
                    i9Sent = document.getElementById('info-i9-sent').checked;
                    existingI9 = document.getElementById('info-existing-i9').checked;
                    ineligible = document.getElementById('info-ineligible').checked;
                } else {
                    console.log('üë§ Public user - checkboxes not captured (defaults to false)');
                }
                
                const sessionData = {
                    type: 'info-session',
                    name: name,
                    email: email,
                    phone: phone,
                    date: registrationDate, // Auto-set to today's date
                    registrationDate: registrationDate, // Keep track of when they registered
                    registrationTime: registrationTime, // Full timestamp of when they registered
                    time: time,
                    sessionType: sessionType, // New field: 'new-hire' or 'reactivation'
                    timestamp: new Date().toISOString(),
                    submittedAt: new Date().toISOString(), // For consistency with other forms
                    // Document status checkboxes
                    ob365Sent: ob365Sent,
                    i9Sent: i9Sent,
                    existingI9: existingI9,
                    ineligible: ineligible
                };
                
                console.log('üîç Session data to save:', sessionData);

                // Manejo especial para Chrome m√≥vil
                if (isMobile && isChrome) {
                    console.log('üì± Intentando guardar en Chrome m√≥vil...');
                    
                    // Intentar con timeout m√°s largo para m√≥viles
                    const savePromise = db.collection('info-sessions').add(sessionData);
                    const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Timeout en m√≥vil - conexi√≥n lenta')), 15000)
                    );
                    
                    try {
                        await Promise.race([savePromise, timeoutPromise]);
                        console.log('‚úÖ Info Session registrada exitosamente en m√≥vil');
                    } catch (mobileError) {
                        console.error('üì± Error espec√≠fico en m√≥vil:', mobileError);
                        throw mobileError;
                    }
                } else {
                    await db.collection('info-sessions').add(sessionData);
                    console.log('‚úÖ Info Session registrada exitosamente');
                }
                
                showSuccessMessage('Info Session registered successfully!');
                playSuccessSound(); // Reproducir sonido de √©xito
                
                // Reset form and clear time slot selection
                document.querySelector('#info-session-form form').reset();
                document.querySelectorAll('.time-slot').forEach(slot => {
                    slot.classList.remove('selected');
                });
                
                setTimeout(() => showScreen('visitor'), 2000);
                
            } catch (error) {
                console.error('‚ùå Error registrando Info Session:', error);
                console.error('‚ùå Error stack:', error.stack);
                showErrorMessage(`Error registering info session: ${error.message}`);
            }
        }

        // Submit fingerprints
        async function submitFingerprints(event) {
            event.preventDefault();
            
            console.log('üëÜ Iniciando registro de Fingerprints...');
            
            try {
                // Get current date and time for registration
                const now = new Date();
                const registrationDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
                const registrationTime = now.toLocaleString(); // Local date and time string
                
                console.log('üëÜ Fingerprints Registration:', {
                    registrationDate,
                    registrationTime
                });
                
                const nameElement = document.getElementById('finger-name');
                const emailElement = document.getElementById('finger-email');
                const timeElement = document.getElementById('finger-time');
                const typeElement = document.getElementById('finger-type');
                
                if (!nameElement) throw new Error('Name field not found');
                if (!emailElement) throw new Error('Email field not found');
                if (!timeElement) throw new Error('Time field not found');
                if (!typeElement) throw new Error('Type field not found');
                
                const name = nameElement.value.trim();
                const email = emailElement.value.trim();
                const time = timeElement.value;
                const fingerprintType = typeElement.value;
                
                console.log('üîç Valores:', { name, email, time, fingerprintType, registrationDate });
                
                if (!name) throw new Error('Please enter your name');
                if (!email) throw new Error('Please enter your email');
                if (!time) throw new Error('Please select a time');
                if (!fingerprintType) throw new Error('Please select fingerprint type');
                
                const fingerprintsData = {
                    type: 'fingerprints',
                    name: name,
                    email: email,
                    date: registrationDate, // Auto-set to today's date
                    registrationDate: registrationDate, // Keep track of when they registered
                    registrationTime: registrationTime, // Full timestamp of when they registered
                    time: time,
                    fingerprintType: fingerprintType,
                    timestamp: new Date().toISOString(),
                    submittedAt: new Date().toISOString() // For consistency with other forms
                };
                
                console.log('üîç Fingerprints data to save:', fingerprintsData);

                await db.collection('fingerprints').add(fingerprintsData);
                console.log('‚úÖ Fingerprints registradas exitosamente');
                
                showSuccessMessage('Fingerprints registered successfully!');
                playSuccessSound(); // Reproducir sonido de √©xito
                document.querySelector('#fingerprints-form form').reset();
                setTimeout(() => showScreen('visitor'), 2000);
                
            } catch (error) {
                console.error('‚ùå Error registrando fingerprints:', error);
                showErrorMessage(`Error registering fingerprints: ${error.message}`);
            }
        }

        // Submit badge
        async function submitBadge(event) {
            event.preventDefault();
            
            console.log('üé´ Iniciando registro de Badge...');
            
            try {
                // Get current date and time for registration
                const now = new Date();
                const registrationDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
                const registrationTime = now.toLocaleString(); // Local date and time string
                
                console.log('üé´ Badge Registration:', {
                    registrationDate,
                    registrationTime
                });
                
                const badgeData = {
                    type: 'badge',
                    name: document.getElementById('badge-name').value,
                    email: document.getElementById('badge-email').value,
                    phone: document.getElementById('badge-phone').value,
                    date: registrationDate, // Auto-set to today's date
                    registrationDate: registrationDate, // Keep track of when they registered
                    registrationTime: registrationTime, // Full timestamp of when they registered
                    timeSlot: document.getElementById('badge-time').value,
                    timestamp: new Date().toISOString(),
                    submittedAt: new Date().toISOString() // For consistency with other forms
                };

                await db.collection('badges').add(badgeData);
                
                showSuccessMessage('Badge appointment registered successfully!');
                playSuccessSound();
                document.querySelector('#badge-form form').reset();
                setTimeout(() => showScreen('visitor'), 2000);
                
            } catch (error) {
                console.error('Error:', error);
                showErrorMessage('Error registering badge appointment. Please try again.');
            }
        }

        // Toggle pending steps field
        function togglePendingStepsField() {
            const checkbox = document.getElementById('nho-pending-steps');
            const field = document.getElementById('pending-steps-field');
            
            if (checkbox.checked) {
                field.style.display = 'block';
            } else {
                field.style.display = 'none';
                document.getElementById('nho-pending-details').value = '';
            }
        }

        // Submit new hire orientation
        async function submitNewHireOrientation(event) {
            event.preventDefault();
            
            try {
                // Get current date and time for registration
                const now = new Date();
                const registrationDate = now.toISOString().split('T')[0]; // YYYY-MM-DD
                const registrationTime = now.toLocaleString(); // Local date and time string
                
                console.log('üéØ New Hire Orientation Registration:', {
                    registrationDate,
                    registrationTime,
                    timeSlot: document.getElementById('nho-time').value
                });
                
                // Get form elements
                const firstNameElement = document.getElementById('nho-first-name');
                const lastNameElement = document.getElementById('nho-last-name');
                const emailElement = document.getElementById('nho-email');
                const phoneElement = document.getElementById('nho-phone');
                const timeElement = document.getElementById('nho-time');
                
                if (!firstNameElement) throw new Error('First name field not found');
                if (!lastNameElement) throw new Error('Last name field not found');
                if (!emailElement) throw new Error('Email field not found');
                if (!phoneElement) throw new Error('Phone field not found');
                if (!timeElement) throw new Error('Time field not found');
                
                const firstName = firstNameElement.value.trim();
                const lastName = lastNameElement.value.trim();
                const name = `${firstName} ${lastName}`;
                const email = emailElement.value.trim();
                const phone = phoneElement.value.trim();
                const timeSlot = timeElement.value;
                
                // Validations
                if (!firstName) throw new Error('Please enter your first name');
                if (!lastName) throw new Error('Please enter your last name');
                if (!email) throw new Error('Please enter your email');
                if (!phone) throw new Error('Please enter your phone number');
                if (!timeSlot) throw new Error('Please select an orientation session');
                
                const orientationData = {
                    type: 'new-hire-orientation',
                    name: name,
                    email: email,
                    phone: phone,
                    date: registrationDate, // Auto-set to today's date
                    registrationDate: registrationDate, // Keep track of when they registered
                    registrationTime: registrationTime, // Full timestamp of when they registered
                    timeSlot: timeSlot,
                    session: timeSlot, // For consistency with other code
                    // Process status fields (default values for public registration)
                    badgePrinted: false,
                    hasPendingSteps: false,
                    pendingStepsDetails: '',
                    waitingFingerprintResults: false,
                    fingerprintStatus: 'pending', // Default fingerprint status to pending
                    timestamp: new Date().toISOString(),
                    submittedAt: new Date().toISOString() // For consistency with other forms
                };

                await db.collection('new-hire-orientations').add(orientationData);
                
                showSuccessMessage('New Hire Orientation registered successfully!');
                playSuccessSound();
                
                // Reset form and clear time slot selection
                document.querySelector('#new-hire-orientation-form form').reset();
                document.querySelectorAll('.time-slot').forEach(slot => {
                    slot.classList.remove('selected');
                });
                
                setTimeout(() => showScreen('visitor'), 2000);
                
            } catch (error) {
                console.error('Error:', error);
                showErrorMessage('Error registering orientation. Please try again.');
            }
        }

        // Submit document completion - DISABLED - USING PERSISTENT CHECKLIST INSTEAD
        // Override any calls to submitDocumentCompletion to prevent the old function from running
        window.submitDocumentCompletion = function(event) {
            console.error('‚ùå DISABLED FUNCTION CALLED: submitDocumentCompletion should not be used');
            console.error('‚ùå Please use the Document Completion Checklist (persistent-checklist.js) instead');
            alert('This form method is disabled. Please refresh the page and use the Document Completion Checklist.');
            if (event) event.preventDefault();
            return false;
        };
        async function staffLogin(event) {
            event.preventDefault();
            console.log('Staff login attempt started');
            
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            
            console.log('Login with email:', email);
            
            try {
                const userCredential = await auth.signInWithEmailAndPassword(email, password);
                currentUser = userCredential.user;
                currentUser.role = 'staff'; // Add role property for staff members
                isAdmin = false;
                
                // Check if user is from recruiting, management, or front-desk team
                const staffDoc = await db.collection('staff').where('email', '==', email).get();
                let isRecruiting = false;
                let isManagement = false;
                let isFrontDesk = false;
                
                console.log('üë§ ===== STAFF PERMISSIONS CHECK =====');
                console.log('üë§ Checking staff permissions for:', email);
                console.log('üë§ Found', staffDoc.size, 'staff records');
                
                let userName = '';
                staffDoc.forEach(doc => {
                    const staffData = doc.data();
                    userName = staffData.name; // Store user name for greeting
                    console.log('üë§ Staff record found:');
                    console.log('   - Name:', staffData.name);
                    console.log('   - Email:', staffData.email);
                    console.log('   - Team:', staffData.team);
                    console.log('   - Title:', staffData.title);
                    
                    if (staffData.team === 'recruiting') {
                        isRecruiting = true;
                        console.log('‚úÖ ‚úÖ ‚úÖ User has RECRUITING permissions');
                    }
                    if (staffData.team === 'management') {
                        isManagement = true;
                        console.log('‚úÖ ‚úÖ ‚úÖ User has MANAGEMENT permissions');
                    }
                    if (staffData.team === 'front-desk') {
                        isFrontDesk = true;
                        console.log('‚úÖ ‚úÖ ‚úÖ User has FRONT-DESK permissions');
                    }
                });
                
                console.log('üë§ ===== PERMISSIONS SUMMARY =====');
                console.log('üë§ isRecruiting:', isRecruiting);
                console.log('üë§ isManagement:', isManagement);
                console.log('üë§ isFrontDesk:', isFrontDesk);
                console.log('üë§ ===============================');
                
                // All staff members can see info sessions and orientations
                console.log('üîî Showing standard buttons for all staff...');
                document.getElementById('info-sessions-btn').style.display = 'block';
                document.getElementById('new-hire-orientations-btn').style.display = 'block';
                document.getElementById('advanced-analytics-btn').style.display = 'block';
                console.log('‚úÖ Standard buttons shown');
                
                // Show staff-only elements
                console.log('üîë Showing staff-only form elements...');
                document.querySelectorAll('.staff-only').forEach(element => {
                    element.style.display = 'block';
                });
                console.log('‚úÖ Staff-only elements shown');
                
                // Auto-load document completions for staff
                console.log('üìã Auto-loading document completions for staff...');
                setTimeout(() => {
                    loadStaffDocumentCompletions();
                }, 1000); // Small delay to ensure DOM is ready
                
                // Setup real-time listener for document completions (background only)
                console.log('üîî ===== DOCUMENT COMPLETIONS SETUP =====');
                console.log('üîî Checking permissions for document completions...');
                console.log('üîî isRecruiting:', isRecruiting);
                console.log('üîî isManagement:', isManagement);
                console.log('üîî Should show button:', (isRecruiting || isManagement));
                
                if (isRecruiting || isManagement || isAdmin || email.includes('kellyeducation')) {
                    console.log('‚úÖ ‚úÖ ‚úÖ Setting up document completions (will show in My Status)');
                    setupDocumentCompletionsListener();
                    // Ensure the Document Queue button is visible
                    const docQueueBtn = document.getElementById('document-completions-btn');
                    if (docQueueBtn) {
                        docQueueBtn.style.display = 'block';
                        console.log('‚úÖ Document Queue button made visible');
                    }
                } else {
                    console.log('‚ùå ‚ùå ‚ùå Not setting up document completions - user is NOT recruiting, management, or admin');
                    console.log('üîî User teams found: recruiting=' + isRecruiting + ', management=' + isManagement + ', front-desk=' + isFrontDesk + ', admin=' + isAdmin);
                    // Hide the Document Queue button for non-authorized users
                    const docQueueBtn = document.getElementById('document-completions-btn');
                    if (docQueueBtn) {
                        docQueueBtn.style.display = 'none';
                        console.log('üö´ Document Queue button hidden (no permissions)');
                    }
                }
                console.log('üîî ================================');
                
                // Show events button for ALL authenticated staff members
                console.log('‚úÖ Showing My Events button for all staff:', email);
                const eventsBtn = document.getElementById('recruiter-events-btn');
                if (eventsBtn) {
                    eventsBtn.style.display = 'block';
                    console.log('‚úÖ My Events button shown for all staff');
                }
                
                // Show status controls for recruiters and management - be more permissive
                if (isRecruiting || isManagement || email.includes('kellyeducation')) {
                    console.log('‚úÖ Showing recruiter status buttons for:', email);
                    const statusBtn = document.getElementById('recruiter-status-btn');
                    
                    if (statusBtn) {
                        statusBtn.style.display = 'block';
                        console.log('‚úÖ My Status button shown');
                    }
                    
                    // Auto-load document completions for recruiters
                    console.log('üîÑ Auto-loading document completions for recruiter after login...');
                    setTimeout(() => {
                        loadDocumentCompletionsForStatus();
                    }, 2000);
                } else {
                    console.log('‚ö†Ô∏è Not showing recruiter buttons for:', email, '- isRecruiting:', isRecruiting, 'isManagement:', isManagement);
                }
                
                showScreen('dashboard');
                
                // Show personalized greeting with delay to ensure screen is fully loaded
                setTimeout(() => {
                    console.log('üéâ SHOWING GREETING - userName:', userName, 'email:', email);
                    if (userName) {
                        console.log('üéâ Showing greeting with userName:', userName);
                        showSuccessMessage(`Hello ${userName}! Welcome back.`);
                    } else {
                        // Fallback: use first part of email if no name found
                        const emailName = email.split('@')[0].replace(/[._]/g, ' ');
                        console.log('üéâ Showing greeting with emailName:', emailName);
                        showSuccessMessage(`Hello ${emailName}! Welcome back.`);
                    }
                }, 500);
                
                loadDashboardData();
                
                // Initialize auto-save system
                initAutoSave();
                
                // Auto-load simple completions for everyone
                setTimeout(() => {
                    console.log('üü° Auto-loading simple completions after staff login');
                    loadSimpleCompletionsDisplay();
                }, 3000);
                
                // Run data integrity check for staff users
                initDataIntegrityCheck();
                
                // Pedir permiso para notificaciones del navegador
                requestNotificationPermission();
                
            } catch (error) {
                console.error('Login error:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                alert('Login error: ' + error.message);
                showErrorMessage('Login failed: ' + error.message);
            }
        }

        // Admin login
        async function adminLogin(event) {
            console.log('üîë Admin login attempt started');
            event.preventDefault();
            
            const email = document.getElementById('admin-login-email').value;
            const password = document.getElementById('admin-login-password').value;
            
            console.log('üìß Email:', email);
            console.log('üîê Password length:', password.length);
            
            // Check if Firebase Auth is available
            if (!auth) {
                console.error('‚ùå Firebase Auth not initialized');
                alert('Firebase Authentication not available. Please refresh the page.');
                return;
            }
            
            console.log('üî• Firebase Auth available, attempting login...');
            
            // Show loading indicator
            const submitBtn = event.target.querySelector('button[type="submit"]');
            const originalText = submitBtn.textContent;
            submitBtn.textContent = 'Logging in...';
            submitBtn.disabled = true;
            
            try {
                const userCredential = await auth.signInWithEmailAndPassword(email, password);
                console.log('‚úÖ Login successful:', userCredential.user.email);
                
                if (email === 'cculturausallc@gmail.com') {
                    currentUser = userCredential.user;
                    isAdmin = true;
                    
                    showScreen('admin-dashboard');
                    
                    // Show admin greeting with delay
                    setTimeout(() => {
                        showSuccessMessage('Hello Admin! Welcome back.');
                    }, 500);
                    
                    // Initialize auto-save system for admin
                    initAutoSave();
                    
                    // Show staff-only elements for admin
                    console.log('üîë Admin: Showing staff-only form elements...');
                    document.querySelectorAll('.staff-only').forEach(element => {
                        element.style.display = 'block';
                    });
                    console.log('‚úÖ Admin: Staff-only elements shown');
                    
                    // Auto-load document completions for admin
                    console.log('üìã Admin: Auto-loading document completions...');
                    setTimeout(() => {
                        loadStaffDocumentCompletions();
                    }, 1000);
                    
                    // Load admin data with error handling
                    try {
                        loadAdminData();
                        // Pedir permiso para notificaciones del navegador
                        requestNotificationPermission();
                    } catch (loadError) {
                        console.error('Error loading admin data:', loadError);
                        // Don't show error to user, just log it
                    }
                } else {
                    await auth.signOut();
                    showErrorMessage('Access denied. Admin credentials required.');
                }
                
            } catch (error) {
                console.error('‚ùå Admin login error:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                
                if (error.code === 'auth/user-not-found') {
                    showErrorMessage('User not found. Please check your email.');
                } else if (error.code === 'auth/wrong-password') {
                    showErrorMessage('Incorrect password. Please try again.');
                } else if (error.code === 'auth/invalid-email') {
                    showErrorMessage('Invalid email format.');
                } else if (error.code === 'auth/network-request-failed') {
                    showErrorMessage('Network error. Please check your internet connection.');
                } else {
                    showErrorMessage('Login failed: ' + (error.message || 'Unknown error'));
                }
                
                // Restore button state
                submitBtn.textContent = originalText;
                submitBtn.disabled = false;
            }
        }

        // Logout functions
        function logout() {
            auth.signOut();
            currentUser = null;
            isAdmin = false;
            document.getElementById('info-sessions-btn').style.display = 'none';
            document.getElementById('new-hire-orientations-btn').style.display = 'none';
            document.getElementById('advanced-analytics-btn').style.display = 'none';
            // Keep My Status visible for all staff
            // document.getElementById('recruiter-status-btn').style.display = 'none';
            document.getElementById('recruiter-events-btn').style.display = 'none';
            
            // Hide staff-only elements on logout
            console.log('üîí Hiding staff-only form elements on logout...');
            document.querySelectorAll('.staff-only').forEach(element => {
                element.style.display = 'none';
            });
            console.log('‚úÖ Staff-only elements hidden');
            
            // Desconectar listeners en tiempo real
            disconnectRealtimeListeners();
            
            showScreen('visitor');
            clearForms();
        }

        function adminLogout() {
            auth.signOut();
            currentUser = null;
            isAdmin = false;
            
            // Desconectar listeners en tiempo real
            disconnectRealtimeListeners();
            
            showScreen('visitor');
            clearForms();
        }

        function clearForms() {
            document.querySelectorAll('form').forEach(form => form.reset());
        }

        // Ensure document completions listener is active
        function ensureDocumentCompletionsListener() {
            // Don't start listeners on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Skipping ensureDocumentCompletionsListener on document-completion page');
                return;
            }
            
            // Check if we have an active listener
            const hasActiveListener = realtimeListeners.some(l => l.type === 'document-completions');
            
            if (!hasActiveListener && currentUser) {
                // Get current user permissions
                const userIsRecruiting = typeof isRecruiting !== 'undefined' ? isRecruiting : false;
                const userIsManagement = typeof isManagement !== 'undefined' ? isManagement : false;
                const userIsAdmin = typeof isAdmin !== 'undefined' ? isAdmin : false;
                const userEmail = currentUser.email || '';
                
                if (userIsRecruiting || userIsManagement || userIsAdmin || userEmail.includes('kellyeducation')) {
                    console.log('üîÑ Re-establishing document completions listener for authorized user');
                    setupDocumentCompletionsListener();
                } else {
                    console.log('üîÑ Skipping listener setup - user not authorized for document completions');
                }
            }
        }

        // Show dashboard sections
        function showDashboardSection(sectionId) {
            document.querySelectorAll('.dashboard-section').forEach(section => {
                section.style.display = 'none';
            });
            document.getElementById(sectionId).style.display = 'block';
            
            if (sectionId === 'my-visits') {
                loadMyVisits();
                hideVisitsIndicator(); // Ocultar indicador cuando el usuario vea sus visitas
            } else if (sectionId === 'info-sessions') {
                loadInfoSessions();
            } else if (sectionId === 'new-hire-orientations') {
                console.log('üîç DEBUG: Switching to new-hire-orientations section');
                loadStaffOrientations();
            } else if (sectionId === 'advanced-analytics-staff') {
                console.log('üîç DEBUG: Switching to advanced-analytics-staff section');
                loadStaffAdvancedAnalytics();
            } else if (sectionId === 'fingerprints-admin') {
                console.log('üîç DEBUG: Switching to fingerprints-admin section');
                loadFingerprints();
            } else if (sectionId === 'badges-staff') {
                console.log('üîç DEBUG: Switching to badges-staff section');
                loadStaffBadges();
            } else if (sectionId === 'booking-counts') {
                loadBookingCounts();
            } else if (sectionId === 'daily-statistics-staff') {
                loadStaffTodayStatistics();
            } else if (sectionId === 'document-completions') {
                // Ensure listener is active when viewing Document Queue
                ensureDocumentCompletionsListener();
                loadDocumentCompletions();
                // Reset filter to 'all' when opening the section
                setTimeout(() => {
                    filterDocumentCompletions('all');
                }, 500);
            } else if (sectionId === 'simple-document-completions') {
                // Initialize filter buttons
                setTimeout(() => {
                    filterCompletions(currentCompletionsFilter);
                }, 100);
            } else if (sectionId === 'recruiter-status') {
                loadRecruiterStatus();
                // Ensure listener is active when viewing My Status
                ensureDocumentCompletionsListener();
            } else if (sectionId === 'recruiter-events') {
                loadEventData();
            }
        }

        // Show admin sections
        function showAdminSection(sectionId) {
            document.querySelectorAll('.dashboard-section').forEach(section => {
                section.style.display = 'none';
            });
            document.getElementById(sectionId).style.display = 'block';
            
            if (sectionId === 'manage-staff') {
                loadStaffList();
            } else if (sectionId === 'manage-users') {
                loadAllUsersList();
            } else if (sectionId === 'manage-recruiters') {
                loadRecruitersManagement();
            } else if (sectionId === 'exclusion-list') {
                loadExclusionListView();
            } else if (sectionId === 'queue-management') {
                loadQueueManagement();
            } else if (sectionId === 'all-visits') {
                loadAllVisits();
            } else if (sectionId === 'all-info-sessions') {
                loadAllInfoSessions();
            } else if (sectionId === 'all-fingerprints') {
                loadAllFingerprints();
            } else if (sectionId === 'all-badges') {
                loadAllBadges();
            } else if (sectionId === 'all-orientations') {
                loadAllOrientations();
            } else if (sectionId === 'admin-booking-counts') {
                loadAdminBookingCounts();
            } else if (sectionId === 'daily-statistics') {
                loadTodayStatistics();
            } else if (sectionId === 'advanced-analytics') {
                loadAdvancedAnalytics();
            }
        }

        // Load dashboard data
        function loadDashboardData() {
            showDashboardSection('my-visits');
        }

        function loadAdminData() {
            showAdminSection('manage-staff');
        }

        // Agregar listeners para habilitar audio con cualquier clic
        document.addEventListener('click', enableAudio);
        document.addEventListener('keydown', enableAudio);

        // Load my visits with real-time updates
        async function loadMyVisits() {
            // Don't start listeners on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Skipping loadMyVisits on document-completion page');
                return;
            }
            
            if (!currentUser) return;
            
            const userEmail = currentUser.email;
            const visitsList = document.getElementById('visits-list');
            
            // Desconectar listener anterior si existe
            const existingListener = realtimeListeners.find(l => l.type === 'my-visits');
            if (existingListener) {
                existingListener.unsubscribe();
                realtimeListeners = realtimeListeners.filter(l => l.type !== 'my-visits');
            }
            
            // Configurar listener en tiempo real
            const unsubscribe = db.collection('visits')
                .where('teamMemberEmail', '==', userEmail)
                .where('status', '==', 'pending')
                .orderBy('timestamp', 'desc')
                .onSnapshot(snapshot => {
                    visitsList.innerHTML = '';
                    
                    if (snapshot.empty) {
                        visitsList.innerHTML = '<p>No pending visits.</p>';
                        return;
                    }
                    
                    // Verificar si hay nuevas visitas
                    let hasNewVisits = false;
                    snapshot.docChanges().forEach(change => {
                        if (change.type === 'added') {
                            hasNewVisits = true;
                        }
                    });
                    
                    // Mostrar notificaci√≥n si hay nuevas visitas
                    if (hasNewVisits && snapshot.docChanges().length > 0) {
                        showRealtimeNotification('üîî New visit registered!', 'You have a new pending visit.');
                        showVisitsIndicator(); // Mostrar indicador visual en el bot√≥n
                    }
                    
                    // Convert to array and sort by timestamp (newest first)
                    const visitsArray = [];
                    snapshot.forEach(doc => {
                        visitsArray.push({
                            id: doc.id,
                            data: doc.data()
                        });
                    });
                    
                    // Sort by timestamp (newest first)
                    visitsArray.sort((a, b) => {
                        const timeA = a.data.timestamp ? new Date(a.data.timestamp) : new Date();
                        const timeB = b.data.timestamp ? new Date(b.data.timestamp) : new Date();
                        return timeB - timeA;
                    });
                    
                    let previousTimestamp = null;
                    
                    // Renderizar todas las visitas con divisores diarios
                    visitsArray.forEach((item, index) => {
                        const visit = item.data;
                        const visitId = item.id;
                        
                        // Check if we need to add a daily divider
                        const currentTimestamp = visit.timestamp;
                        if (index > 0 && previousTimestamp && shouldShowDailyDivider(currentTimestamp, previousTimestamp)) {
                            const divider = createDailyDivider(currentTimestamp);
                            visitsList.appendChild(divider);
                        }
                        
                        const visitCard = createVisitCard(visit, visitId, false, index + 1);
                        visitsList.appendChild(visitCard);
                        
                        previousTimestamp = currentTimestamp;
                    });
                }, error => {
                    // Skip errors on document-completion page
                    if (window.location.hash === '#document-completion-form') {
                        console.log('üìÑ Skipping visits listener error on document-completion page');
                        return;
                    }
                    console.error('Error in real-time visits:', error);
                    showErrorMessage('Error loading visits in real-time.');
                });
            
            // Guardar listener para poder desconectarlo despu√©s
            realtimeListeners.push({
                type: 'my-visits',
                unsubscribe: unsubscribe
            });
        }

        // Load info sessions with real-time updates
        async function loadInfoSessions() {
            // Don't start listeners on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Skipping loadInfoSessions on document-completion page');
                return;
            }
            
            console.log('üîç DEBUG: loadInfoSessions called');
            console.log('üîç DEBUG: currentUser =', currentUser);
            
            const sessionsList = document.getElementById('info-sessions-list');
            
            // Desconectar listener anterior si existe
            const existingListener = realtimeListeners.find(l => l.type === 'info-sessions');
            if (existingListener) {
                existingListener.unsubscribe();
                realtimeListeners = realtimeListeners.filter(l => l.type !== 'info-sessions');
            }
            
            // Configurar listener en tiempo real
            const unsubscribe = db.collection('info-sessions')
                .orderBy('timestamp', 'desc')
                .onSnapshot(snapshot => {
                    sessionsList.innerHTML = '';
                    
                    if (snapshot.empty) {
                        sessionsList.innerHTML = '<p>No info sessions registered.</p>';
                        return;
                    }
                    
                    // Verificar si hay nuevas info sessions
                    let hasNewSessions = false;
                    snapshot.docChanges().forEach(change => {
                        if (change.type === 'added') {
                            hasNewSessions = true;
                        }
                    });
                    
                    // Mostrar notificaci√≥n si hay nuevas sessions
                    if (hasNewSessions && snapshot.docChanges().length > 0) {
                        showRealtimeNotification('üìã New info session registered!', 'A new info session has been scheduled.');
                    }
                    
                    // Agrupar sessions por fecha con separadores
                    console.log('üîç DEBUG: Found', snapshot.size, 'info sessions');
                    const sessionsByDate = {};
                    const today = new Date().toISOString().split('T')[0];
                    
                    snapshot.forEach((doc) => {
                        const session = doc.data();
                        let sessionDate = 'unknown-date';
                        
                        // Obtener fecha del timestamp
                        if (session.timestamp) {
                            try {
                                sessionDate = new Date(session.timestamp).toISOString().split('T')[0];
                            } catch (e) {
                                console.log('üîç DEBUG: Error parsing timestamp for session:', session.name);
                                sessionDate = 'unknown-date';
                            }
                        }
                        
                        if (!sessionsByDate[sessionDate]) {
                            sessionsByDate[sessionDate] = [];
                        }
                        sessionsByDate[sessionDate].push({ doc, session });
                    });
                    
                    // Ordenar fechas (m√°s recientes primero)
                    const sortedDates = Object.keys(sessionsByDate).sort((a, b) => {
                        if (a === 'unknown-date') return 1;
                        if (b === 'unknown-date') return -1;
                        return new Date(b) - new Date(a);
                    });
                    
                    console.log('üîç DEBUG: Dates found:', sortedDates);
                    
                    // Renderizar por fecha
                    let totalIndex = 0;
                    sortedDates.forEach(date => {
                        const isToday = date === today;
                        
                        // Crear separador de fecha
                        const dateSeparator = document.createElement('div');
                        dateSeparator.style.cssText = `
                            background: ${isToday ? '#4CAF50' : '#2196F3'};
                            color: white;
                            padding: 12px 20px;
                            margin: 20px 0 10px 0;
                            border-radius: 8px;
                            font-weight: bold;
                            text-align: center;
                            font-size: 16px;
                        `;
                        
                        if (date === 'unknown-date') {
                            dateSeparator.textContent = 'üìã Date not available';
                        } else {
                            const dateObj = new Date(date + 'T12:00:00');
                            const formattedDate = dateObj.toLocaleDateString('en-US', {
                                weekday: 'long',
                                year: 'numeric',
                                month: 'long',
                                day: 'numeric'
                            });
                            dateSeparator.textContent = isToday ? `üìÖ Today - ${formattedDate}` : `üìÖ ${formattedDate}`;
                        }
                        
                        sessionsList.appendChild(dateSeparator);
                        
                        // Renderizar sessions de esta fecha
                        sessionsByDate[date].forEach(({ doc, session }) => {
                            totalIndex++;
                            const sessionCard = createInfoSessionCard(session, doc.id, false, totalIndex);
                            sessionsList.appendChild(sessionCard);
                        });
                    });
                }, error => {
                    console.error('Error in real-time info sessions:', error);
                });
            
            // Guardar listener
            realtimeListeners.push({
                type: 'info-sessions',
                unsubscribe: unsubscribe
            });
        }

        // REMOVED DUPLICATE - Using loadStaffOrientations function from line 8911

        // Load badges for staff with real-time updates
        async function loadStaffBadges() {
            // Don't start listeners on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Skipping loadStaffBadges on document-completion page');
                return;
            }
            
            console.log('üîç DEBUG: loadStaffBadges() called');
            const badgesList = document.getElementById('staff-badges-list');
            
            // Desconectar listener anterior si existe
            const existingListener = realtimeListeners.find(l => l.type === 'staff-badges');
            if (existingListener) {
                existingListener.unsubscribe();
                realtimeListeners = realtimeListeners.filter(l => l.type !== 'staff-badges');
            }
            
            // Configurar listener en tiempo real
            const unsubscribe = db.collection('badges')
                .orderBy('timestamp', 'desc')
                .onSnapshot(snapshot => {
                    badgesList.innerHTML = '';
                    
                    if (snapshot.empty) {
                        badgesList.innerHTML = '<p>No badge appointments scheduled.</p>';
                        return;
                    }
                    
                    // Agrupar badges por fecha con separadores
                    console.log('üîç DEBUG: Processing', snapshot.size, 'badges for date separation');
                    const badgesByDate = {};
                    const today = new Date().toISOString().split('T')[0];
                    
                    snapshot.forEach((doc) => {
                        const badge = doc.data();
                        let badgeDate = 'unknown-date';
                        
                        // Obtener fecha del timestamp
                        if (badge.timestamp) {
                            try {
                                badgeDate = new Date(badge.timestamp).toISOString().split('T')[0];
                            } catch (e) {
                                console.log('üîç DEBUG: Error parsing timestamp for badge:', badge.name);
                                badgeDate = 'unknown-date';
                            }
                        }
                        
                        if (!badgesByDate[badgeDate]) {
                            badgesByDate[badgeDate] = [];
                        }
                        badgesByDate[badgeDate].push({ doc, badge });
                    });
                    
                    // Ordenar fechas (m√°s recientes primero)
                    const sortedDates = Object.keys(badgesByDate).sort((a, b) => {
                        if (a === 'unknown-date') return 1;
                        if (b === 'unknown-date') return -1;
                        return new Date(b) - new Date(a);
                    });
                    
                    console.log('üîç DEBUG: Badge dates found:', sortedDates);
                    
                    // Renderizar por fecha
                    let totalIndex = 0;
                    sortedDates.forEach(date => {
                        const isToday = date === today;
                        
                        // Crear separador de fecha
                        const dateSeparator = document.createElement('div');
                        dateSeparator.style.cssText = `
                            background: ${isToday ? '#4CAF50' : '#2196F3'};
                            color: white;
                            padding: 12px 20px;
                            margin: 20px 0 10px 0;
                            border-radius: 8px;
                            font-weight: bold;
                            text-align: center;
                            font-size: 16px;
                        `;
                        
                        if (date === 'unknown-date') {
                            dateSeparator.textContent = 'üÜî Date not available';
                        } else {
                            const dateObj = new Date(date + 'T12:00:00');
                            const formattedDate = dateObj.toLocaleDateString('en-US', {
                                weekday: 'long',
                                year: 'numeric',
                                month: 'long',
                                day: 'numeric'
                            });
                            dateSeparator.textContent = isToday ? `üìÖ Today - ${formattedDate}` : `üìÖ ${formattedDate}`;
                        }
                        
                        badgesList.appendChild(dateSeparator);
                        
                        // Renderizar badges de esta fecha
                        badgesByDate[date].forEach(({ doc, badge }) => {
                            totalIndex++;
                            const badgeCard = createBadgeCard(badge, false, doc.id, totalIndex);
                            badgesList.appendChild(badgeCard);
                        });
                    });
                    
                }, error => {
                    console.error('Error in real-time badges:', error);
                    badgesList.innerHTML = '<p>Error loading badge appointments. Please refresh.</p>';
                });
                
            // Almacenar el listener
            realtimeListeners.push({
                unsubscribe: unsubscribe,
                type: 'staff-badges'
            });
        }

        // Load fingerprints with real-time updates
        async function loadFingerprints() {
            // Don't start listeners on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Skipping loadFingerprints on document-completion page');
                return;
            }
            
            console.log('üîç DEBUG: loadFingerprints() called');
            const fingerprintsList = document.getElementById('fingerprints-list');
            
            // Desconectar listener anterior si existe
            const existingListener = realtimeListeners.find(l => l.type === 'fingerprints');
            if (existingListener) {
                existingListener.unsubscribe();
                realtimeListeners = realtimeListeners.filter(l => l.type !== 'fingerprints');
            }
            
            // Configurar listener en tiempo real
            const unsubscribe = db.collection('fingerprints')
                .orderBy('timestamp', 'desc')
                .onSnapshot(snapshot => {
                    fingerprintsList.innerHTML = '';
                    
                    if (snapshot.empty) {
                        fingerprintsList.innerHTML = '<p>No fingerprints scheduled.</p>';
                        return;
                    }
                    
                    // Verificar si hay nuevos fingerprints
                    let hasNewFingerprints = false;
                    snapshot.docChanges().forEach(change => {
                        if (change.type === 'added') {
                            hasNewFingerprints = true;
                        }
                    });
                    
                    // Mostrar notificaci√≥n si hay nuevos fingerprints
                    if (hasNewFingerprints && snapshot.docChanges().length > 0) {
                        showRealtimeNotification('üëÜ New fingerprint scheduled!', 'A new fingerprint appointment has been registered.');
                    }
                    
                    // Agrupar fingerprints por fecha con separadores
                    console.log('üîç DEBUG: Processing', snapshot.size, 'fingerprints for date separation');
                    const fingerprintsByDate = {};
                    const today = new Date().toISOString().split('T')[0];
                    
                    snapshot.forEach((doc) => {
                        const fingerprint = doc.data();
                        let fingerprintDate = 'unknown-date';
                        
                        // Obtener fecha del timestamp
                        if (fingerprint.timestamp) {
                            try {
                                fingerprintDate = new Date(fingerprint.timestamp).toISOString().split('T')[0];
                            } catch (e) {
                                console.log('üîç DEBUG: Error parsing timestamp for fingerprint:', fingerprint.name);
                                fingerprintDate = 'unknown-date';
                            }
                        }
                        
                        if (!fingerprintsByDate[fingerprintDate]) {
                            fingerprintsByDate[fingerprintDate] = [];
                        }
                        fingerprintsByDate[fingerprintDate].push({ doc, fingerprint });
                    });
                    
                    // Ordenar fechas (m√°s recientes primero)
                    const sortedDates = Object.keys(fingerprintsByDate).sort((a, b) => {
                        if (a === 'unknown-date') return 1;
                        if (b === 'unknown-date') return -1;
                        return new Date(b) - new Date(a);
                    });
                    
                    console.log('üîç DEBUG: Fingerprint dates found:', sortedDates);
                    
                    // Renderizar por fecha
                    let totalIndex = 0;
                    sortedDates.forEach(date => {
                        const isToday = date === today;
                        
                        // Crear separador de fecha
                        const dateSeparator = document.createElement('div');
                        dateSeparator.style.cssText = `
                            background: ${isToday ? '#4CAF50' : '#2196F3'};
                            color: white;
                            padding: 12px 20px;
                            margin: 20px 0 10px 0;
                            border-radius: 8px;
                            font-weight: bold;
                            text-align: center;
                            font-size: 16px;
                        `;
                        
                        if (date === 'unknown-date') {
                            dateSeparator.textContent = 'üëÜ Date not available';
                        } else {
                            const dateObj = new Date(date + 'T12:00:00');
                            const formattedDate = dateObj.toLocaleDateString('en-US', {
                                weekday: 'long',
                                year: 'numeric',
                                month: 'long',
                                day: 'numeric'
                            });
                            dateSeparator.textContent = isToday ? `üìÖ Today - ${formattedDate}` : `üìÖ ${formattedDate}`;
                        }
                        
                        fingerprintsList.appendChild(dateSeparator);
                        
                        // Renderizar fingerprints de esta fecha
                        fingerprintsByDate[date].forEach(({ doc, fingerprint }) => {
                            totalIndex++;
                            const fingerprintCard = createFingerprintCard(fingerprint, false, doc.id, totalIndex);
                            fingerprintsList.appendChild(fingerprintCard);
                        });
                    });
                }, error => {
                    console.error('Error in real-time fingerprints:', error);
                });
            
            // Guardar listener
            realtimeListeners.push({
                type: 'fingerprints',
                unsubscribe: unsubscribe
            });
        }

        // Add staff member
        async function addStaffMember(event) {
            event.preventDefault();
            
            if (!isAdmin) {
                showErrorMessage('Access denied.');
                return;
            }
            
            try {
                const email = document.getElementById('new-staff-email').value;
                const password = document.getElementById('new-staff-password').value;
                
                // Create user in Authentication
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                const user = userCredential.user;
                
                // Add staff data to Firestore
                const staffData = {
                    name: document.getElementById('new-staff-name').value,
                    email: email,
                    team: document.getElementById('new-staff-team').value,
                    title: document.getElementById('new-staff-title').value,
                    createdAt: new Date().toISOString()
                };
                
                await db.collection('staff').doc(user.uid).set(staffData);
                
                showSuccessMessage('Staff member added successfully!');
                document.querySelector('#manage-staff form').reset();
                loadStaffList();
                
            } catch (error) {
                console.error('Error adding staff:', error);
                if (error.code === 'auth/email-already-in-use') {
                    showErrorMessage('Email already in use!');
                } else {
                    showErrorMessage('Error adding staff member.');
                }
            }
        }

        // Load staff list
        async function loadStaffList() {
            if (!isAdmin) return;
            
            try {
                const staffRef = db.collection('staff').orderBy('name');
                const snapshot = await staffRef.get();
                const staffList = document.getElementById('staff-list');
                staffList.innerHTML = '';
                
                snapshot.forEach(doc => {
                    const staff = doc.data();
                    const staffCard = document.createElement('div');
                    staffCard.className = 'visit-card';
                    staffCard.innerHTML = `
                        <div class="visit-header">
                            <h4>${staff.name}</h4>
                            <div>
                                <button class="btn" onclick="editStaff('${doc.id}')">Edit</button>
                                <button class="btn btn-danger" onclick="deleteStaff('${doc.id}')">Delete</button>
                            </div>
                        </div>
                        <p><strong>Email:</strong> ${staff.email}</p>
                        <p><strong>Team:</strong> ${staff.team}</p>
                        <p><strong>Title:</strong> ${staff.title}</p>
                    `;
                    staffList.appendChild(staffCard);
                });
                
            } catch (error) {
                console.error('Error loading staff:', error);
            }
        }

        // Edit staff
        async function editStaff(staffId) {
            if (!isAdmin) return;
            
            try {
                const staffDoc = await db.collection('staff').doc(staffId).get();
                const staff = staffDoc.data();
                
                if (staff) {
                    document.getElementById('edit-staff-id').value = staffId;
                    document.getElementById('edit-staff-name').value = staff.name;
                    document.getElementById('edit-staff-email').value = staff.email;
                    document.getElementById('edit-staff-team').value = staff.team;
                    document.getElementById('edit-staff-title').value = staff.title;
                    document.getElementById('edit-staff-password').value = '';
                    
                    document.getElementById('edit-staff-modal').style.display = 'block';
                }
            } catch (error) {
                console.error('Error loading staff data:', error);
            }
        }

        // Update staff member
        async function updateStaffMember(event) {
            event.preventDefault();
            
            if (!isAdmin) {
                showErrorMessage('Access denied.');
                return;
            }
            
            try {
                const staffId = document.getElementById('edit-staff-id').value;
                
                const staffData = {
                    name: document.getElementById('edit-staff-name').value,
                    email: document.getElementById('edit-staff-email').value,
                    team: document.getElementById('edit-staff-team').value,
                    title: document.getElementById('edit-staff-title').value,
                    updatedAt: new Date().toISOString()
                };
                
                await db.collection('staff').doc(staffId).update(staffData);
                
                showSuccessMessage('Staff member updated successfully!');
                closeEditModal();
                loadStaffList();
                
            } catch (error) {
                console.error('Error updating staff:', error);
                showErrorMessage('Error updating staff member.');
            }
        }

        // Delete staff
        async function deleteStaff(staffId) {
            if (!isAdmin) return;
            
            if (confirm('Are you sure you want to delete this staff member?')) {
                try {
                    await db.collection('staff').doc(staffId).delete();
                    loadStaffList();
                    showSuccessMessage('Staff member deleted successfully!');
                    
                } catch (error) {
                    console.error('Error deleting staff:', error);
                    showErrorMessage('Error deleting staff member.');
                }
            }
        }

        // Close edit modal
        function closeEditModal() {
            document.getElementById('edit-staff-modal').style.display = 'none';
        }

        // Toggle pending steps field in modal
        function toggleModalPendingStepsField() {
            const checkbox = document.getElementById('modal-pending-steps');
            const field = document.getElementById('modal-pending-steps-field');
            
            if (checkbox.checked) {
                field.style.display = 'block';
            } else {
                field.style.display = 'none';
                document.getElementById('modal-pending-details').value = '';
            }
        }

        // Update orientation status
        async function updateOrientationStatus(orientationId) {
            if (!isAdmin && !currentUser) return;
            
            // Check if user is recruiter (if not admin)
            if (!isAdmin) {
                const userEmail = currentUser.email;
                const staffDoc = await db.collection('staff').where('email', '==', userEmail).get();
                let isRecruiter = false;
                
                staffDoc.forEach(doc => {
                    const staffData = doc.data();
                    if (staffData.team === 'recruiting') {
                        isRecruiter = true;
                    }
                });
                
                if (!isRecruiter) {
                    showErrorMessage('Access denied. Only recruiters and admins can update orientation status.');
                    return;
                }
            }
            
            try {
                const orientationDoc = await db.collection('new-hire-orientations').doc(orientationId).get();
                const orientation = orientationDoc.data();
                
                if (orientation) {
                    // Populate modal with current data
                    document.getElementById('orientation-id').value = orientationId;
                    document.getElementById('orientation-name-display').textContent = `${orientation.name} - ${orientation.date}`;
                    document.getElementById('modal-badge-printed').checked = orientation.badgePrinted || false;
                    document.getElementById('modal-pending-steps').checked = orientation.hasPendingSteps || false;
                    // Set fingerprint status - use new field if available, otherwise use old field
                    const fingerprintStatus = orientation.fingerprintStatus || (orientation.waitingFingerprintResults ? 'pending' : 'ready');
                    document.getElementById('modal-fingerprint-status').value = fingerprintStatus;
                    
                    document.getElementById('modal-pending-details').value = orientation.pendingStepsDetails || '';
                    
                    // Show/hide pending steps field based on current status
                    const pendingField = document.getElementById('modal-pending-steps-field');
                    if (orientation.hasPendingSteps) {
                        pendingField.style.display = 'block';
                    } else {
                        pendingField.style.display = 'none';
                    }
                    
                    document.getElementById('orientation-status-modal').style.display = 'block';
                }
            } catch (error) {
                console.error('Error loading orientation data:', error);
                showErrorMessage('Error loading orientation data.');
            }
        }

        // Save orientation status
        async function saveOrientationStatus(event) {
            event.preventDefault();
            
            if (!isAdmin && !currentUser) {
                showErrorMessage('Access denied.');
                return;
            }

            // Check if user is recruiter (if not admin)
            if (!isAdmin) {
                const userEmail = currentUser.email;
                const staffDoc = await db.collection('staff').where('email', '==', userEmail).get();
                let isRecruiter = false;
                
                staffDoc.forEach(doc => {
                    const staffData = doc.data();
                    if (staffData.team === 'recruiting') {
                        isRecruiter = true;
                    }
                });
                
                if (!isRecruiter) {
                    showErrorMessage('Access denied. Only recruiters and admins can update orientation status.');
                    return;
                }
            }
            
            try {
                const orientationId = document.getElementById('orientation-id').value;
                
                const fingerprintStatus = document.getElementById('modal-fingerprint-status').value;
                
                const updateData = {
                    badgePrinted: document.getElementById('modal-badge-printed').checked,
                    hasPendingSteps: document.getElementById('modal-pending-steps').checked,
                    pendingStepsDetails: document.getElementById('modal-pending-details').value,
                    fingerprintStatus: fingerprintStatus,
                    waitingFingerprintResults: fingerprintStatus === 'pending', // Legacy field for backward compatibility
                    lastUpdated: new Date().toISOString()
                };
                
                await db.collection('new-hire-orientations').doc(orientationId).update(updateData);
                
                showSuccessMessage('Orientation status updated successfully!');
                closeOrientationStatusModal();
                
                // Refresh the appropriate list based on user type
                if (isAdmin) {
                    loadAllOrientations(); // Admin list
                } else {
                    loadStaffOrientations(); // Staff list
                }
                
            } catch (error) {
                console.error('Error updating orientation status:', error);
                showErrorMessage('Error updating orientation status.');
            }
        }

        // Close orientation status modal
        function closeOrientationStatusModal() {
            document.getElementById('orientation-status-modal').style.display = 'none';
        }

        // Load exclusion list view
        async function loadExclusionListView() {
            if (!isAdmin) return;
            
            try {
                // Load current exclusion list from Firestore
                const exclusionDoc = await db.collection('settings').doc('exclusion-list').get();
                if (exclusionDoc.exists) {
                    exclusionListData = exclusionDoc.data().data || [];
                } else {
                    exclusionListData = [];
                }
                
                displayCurrentExclusionList();
            } catch (error) {
                console.error('Error loading exclusion list:', error);
                showErrorMessage('Error loading exclusion list.');
            }
        }

        // Load Excel file
        function loadExclusionFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);
                    
                    // Process and validate data
                    tempExclusionData = [];
                    let validCount = 0;
                    
                    jsonData.forEach((row, index) => {
                        // Try different possible column names
                        const name = row['Name'] || row['name'] || row['Full Name'] || row['fullname'] || '';
                        const code = row['Code'] || row['code'] || row['STATUS'] || row['status'] || '';
                        const dob = row['DOB'] || row['dob'] || row['Date of Birth'] || row['dateOfBirth'] || '';
                        const ssn = row['SSN'] || row['ssn'] || row['Social Security'] || row['socialSecurity'] || '';
                        
                        if (name && ssn) {
                            tempExclusionData.push({
                                name: name.toString().trim(),
                                code: code.toString().trim().toUpperCase(),
                                dob: dob.toString().trim(),
                                ssn: ssn.toString().trim()
                            });
                            validCount++;
                        }
                    });
                    
                    const statusDiv = document.getElementById('file-status');
                    if (validCount > 0) {
                        statusDiv.innerHTML = `<div class="success-message">‚úÖ File loaded successfully! Found ${validCount} valid records.</div>`;
                        document.getElementById('save-exclusion-btn').disabled = false;
                        
                        // Show preview
                        let previewHTML = '<h5>Preview (first 5 records):</h5><ul>';
                        for (let i = 0; i < Math.min(5, tempExclusionData.length); i++) {
                            const record = tempExclusionData[i];
                            previewHTML += `<li>${record.name} - Code: ${record.code} - DOB: ${record.dob} - SSN: ***${record.ssn.slice(-4)}</li>`;
                        }
                        previewHTML += '</ul>';
                        if (tempExclusionData.length > 5) {
                            previewHTML += `<p>... and ${tempExclusionData.length - 5} more records</p>`;
                        }
                        statusDiv.innerHTML += previewHTML;
                    } else {
                        statusDiv.innerHTML = '<div class="error-message">‚ùå No valid records found. Please check column names: Name, Code, DOB, SSN</div>';
                        document.getElementById('save-exclusion-btn').disabled = true;
                    }
                    
                } catch (error) {
                    console.error('Error parsing Excel file:', error);
                    document.getElementById('file-status').innerHTML = '<div class="error-message">‚ùå Error reading file. Please ensure it\'s a valid Excel file.</div>';
                    document.getElementById('save-exclusion-btn').disabled = true;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }

        // Save exclusion list to Firestore
        async function saveExclusionList() {
            if (!isAdmin || tempExclusionData.length === 0) return;
            
            try {
                await db.collection('settings').doc('exclusion-list').set({
                    data: tempExclusionData,
                    lastUpdated: new Date().toISOString(),
                    updatedBy: currentUser.email
                });
                
                exclusionListData = [...tempExclusionData];
                showSuccessMessage(`Exclusion list saved successfully! ${exclusionListData.length} records.`);
                displayCurrentExclusionList();
                
                // Clear temporary data
                tempExclusionData = [];
                document.getElementById('exclusion-file').value = '';
                document.getElementById('file-status').innerHTML = '';
                document.getElementById('save-exclusion-btn').disabled = true;
                
            } catch (error) {
                console.error('Error saving exclusion list:', error);
                showErrorMessage('Error saving exclusion list.');
            }
        }

        // Clear exclusion list
        async function clearExclusionList() {
            if (!isAdmin) return;
            
            if (confirm('Are you sure you want to clear the entire exclusion list? This action cannot be undone.')) {
                try {
                    await db.collection('settings').doc('exclusion-list').delete();
                    exclusionListData = [];
                    showSuccessMessage('Exclusion list cleared successfully.');
                    displayCurrentExclusionList();
                } catch (error) {
                    console.error('Error clearing exclusion list:', error);
                    showErrorMessage('Error clearing exclusion list.');
                }
            }
        }

        // Display current exclusion list
        function displayCurrentExclusionList() {
            const listDiv = document.getElementById('current-exclusion-list');
            
            if (exclusionListData.length === 0) {
                listDiv.innerHTML = '<p>No exclusion list currently loaded.</p>';
                return;
            }
            
            let html = `<p><strong>Total records: ${exclusionListData.length}</strong></p>`;
            html += '<div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px;">';
            
            exclusionListData.forEach((record, index) => {
                html += `
                    <div style="padding: 8px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between;">
                        <div>
                            <strong>${record.name}</strong> - 
                            Code: <span style="background: ${record.code === 'PC' ? '#dc3545' : '#fd7e14'}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 12px;">${record.code}</span> - 
                            DOB: ${record.dob} - 
                            SSN: ***${record.ssn.slice(-4)}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            listDiv.innerHTML = html;
        }

        // Check if name is in exclusion list (staff only - returns matches array)
        function checkNameInExclusionList(name) {
            if (!name || name.trim().length < 2 || exclusionListData.length === 0) {
                return [];
            }
            
            const searchName = name.trim().toLowerCase();
            const searchWords = searchName.split(' ').filter(word => word.length > 0);
            
            const matches = exclusionListData.filter(record => {
                const recordName = record.name.toLowerCase();
                const recordWords = recordName.split(' ').filter(word => word.length > 0);
                
                // Check for exact match first
                if (recordName === searchName) {
                    return true;
                }
                
                // Check if all search words match complete words in record
                // At least 2 words must match completely or first + last name match
                let matchingWords = 0;
                for (let searchWord of searchWords) {
                    for (let recordWord of recordWords) {
                        if (recordWord === searchWord) {
                            matchingWords++;
                            break;
                        }
                    }
                }
                
                // Require at least 2 matching words or first and last name match
                if (searchWords.length >= 2 && recordWords.length >= 2) {
                    // Check if first and last words match (common name pattern)
                    const firstMatch = searchWords[0] === recordWords[0];
                    const lastMatch = searchWords[searchWords.length - 1] === recordWords[recordWords.length - 1];
                    
                    return matchingWords >= 2 || (firstMatch && lastMatch);
                } else {
                    // For single word searches, require exact match
                    return matchingWords > 0 && searchWords.length === 1 && recordWords.includes(searchWords[0]);
                }
            });
            
            return matches;
        }

        // Check if name is in exclusion list (public form - shows warning)
        async function checkExclusionList(name) {
            if (!name || name.trim().length < 2) {
                hideExclusionWarning();
                return;
            }
            
            // Load exclusion list if not already loaded
            if (exclusionListData.length === 0) {
                try {
                    const exclusionDoc = await db.collection('settings').doc('exclusion-list').get();
                    if (exclusionDoc.exists) {
                        exclusionListData = exclusionDoc.data().data || [];
                    }
                } catch (error) {
                    console.error('Error loading exclusion list:', error);
                    return;
                }
            }
            
            // Use the improved matching logic
            const matches = checkNameInExclusionList(name);
            
            if (matches.length > 0) {
                showExclusionWarning(matches);
            } else {
                hideExclusionWarning();
            }
        }

        // Show exclusion warning (no longer used in public form)
        function showExclusionWarning(matches) {
            // This function is no longer used since exclusion warnings are not shown to public
            return;
        }

        // Hide exclusion warning (no longer used in public form)  
        function hideExclusionWarning() {
            // This function is no longer used since exclusion warnings are not shown to public
            return;
        }

        // Verify SSN against exclusion list (no longer used in public form)
        function verifySSN(ssnInput, matches) {
            // This function is no longer used since exclusion verification is not shown to public
            return;
        }

        // Load all visits (admin)
        async function loadAllVisits() {
            if (!isAdmin) return;
            
            try {
                const visitsRef = db.collection('visits').orderBy('timestamp', 'desc');
                const snapshot = await visitsRef.get();
                const visitsList = document.getElementById('admin-visits-list');
                visitsList.innerHTML = '';
                
                if (snapshot.empty) {
                    visitsList.innerHTML = '<p>No visits registered.</p>';
                    return;
                }
                
                snapshot.forEach((doc, index) => {
                    const visit = doc.data();
                    const visitCard = createVisitCard(visit, doc.id, true, index + 1);
                    visitsList.appendChild(visitCard);
                });
                
            } catch (error) {
                console.error('Error loading all visits:', error);
            }
        }

        // Load recent info sessions (admin) - only last 7 days
        async function loadAllInfoSessions() {
            if (!isAdmin) return;
            
            try {
                // Calculate date 7 days ago
                const sevenDaysAgo = new Date();
                sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                const cutoffDate = sevenDaysAgo.toISOString().split('T')[0];
                
                console.log('üìã Loading Info Sessions from', cutoffDate, 'to today');
                
                // Simplified query to avoid composite index issues
                const sessionsRef = db.collection('info-sessions')
                    .orderBy('timestamp', 'desc')
                    .limit(100); // Get last 100 sessions and filter client-side
                const snapshot = await sessionsRef.get();
                const sessionsList = document.getElementById('admin-info-sessions-list');
                
                // Filter sessions to only show last 7 days
                const recentSessions = [];
                snapshot.forEach((doc) => {
                    const session = doc.data();
                    // Check if session is from the last 7 days
                    if (session.date && session.date >= cutoffDate) {
                        recentSessions.push({...session, id: doc.id});
                    }
                });
                
                // Add header with filter info
                sessionsList.innerHTML = `
                    <div style="background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                        <h4 style="margin: 0 0 10px 0; color: #0066cc;">üìÖ Showing Recent Info Sessions</h4>
                        <p style="margin: 0; color: #0066cc;">Displaying sessions from the last 7 days. For historical data, check Daily Statistics.</p>
                        <p style="margin: 5px 0 0 0; color: #666; font-size: 14px;">Found: ${recentSessions.length} sessions ‚Ä¢ Filter: ${cutoffDate} to today</p>
                    </div>
                `;
                
                if (recentSessions.length === 0) {
                    sessionsList.innerHTML += '<p>No recent info sessions found.</p>';
                    return;
                }
                
                // Agrupar sessions por fecha
                const sessionsByDate = {};
                const today = new Date().toLocaleDateString();
                
                recentSessions.forEach((session) => {
                    let sessionDate = 'Unknown Date';
                    
                    if (session.timestamp) {
                        const date = new Date(session.timestamp);
                        sessionDate = date.toLocaleDateString();
                    } else if (session.date) {
                        sessionDate = session.date;
                    }
                    
                    if (!sessionsByDate[sessionDate]) {
                        sessionsByDate[sessionDate] = [];
                    }
                    sessionsByDate[sessionDate].push(session);
                });
                
                // Ordenar fechas con hoy primero
                const sortedDates = Object.keys(sessionsByDate).sort((a, b) => {
                    if (a === today) return -1;
                    if (b === today) return 1;
                    return new Date(b) - new Date(a);
                });
                
                // Renderizar sessions agrupadas por fecha
                let totalIndex = 0;
                sortedDates.forEach(date => {
                    // Crear separador de fecha
                    const isToday = date === today;
                    const dateSeparator = document.createElement('div');
                    dateSeparator.style.cssText = `
                        background: ${isToday ? '#4CAF50' : '#2196F3'};
                        color: white;
                        padding: 12px 20px;
                        margin: 20px 0 10px 0;
                        border-radius: 8px;
                        font-weight: bold;
                        text-align: center;
                        font-size: 16px;
                    `;
                    dateSeparator.innerHTML = `${isToday ? 'üìÖ TODAY' : 'üìÜ PREVIOUS DAYS'} - ${date} (${sessionsByDate[date].length} sessions)`;
                    sessionsList.appendChild(dateSeparator);
                    
                    // Renderizar sessions de esta fecha
                    sessionsByDate[date].forEach((session) => {
                        totalIndex++;
                        const sessionCard = createInfoSessionCard(session, session.id, true, totalIndex);
                        sessionsList.appendChild(sessionCard);
                    });
                });
                
            } catch (error) {
                console.error('Error loading recent info sessions:', error);
                const sessionsList = document.getElementById('admin-info-sessions-list');
                sessionsList.innerHTML = '<p>Error loading info sessions. Please try again.</p>';
            }
        }

        // Load all fingerprints (admin)
        async function loadAllFingerprints() {
            if (!isAdmin) return;
            
            try {
                const fingerprintsRef = db.collection('fingerprints').orderBy('timestamp', 'desc');
                const snapshot = await fingerprintsRef.get();
                const fingerprintsList = document.getElementById('admin-fingerprints-list');
                fingerprintsList.innerHTML = '';
                
                if (snapshot.empty) {
                    fingerprintsList.innerHTML = '<p>No fingerprints scheduled.</p>';
                    return;
                }
                
                // Agrupar fingerprints por fecha
                const fingerprintsByDate = {};
                const today = new Date().toLocaleDateString();
                
                snapshot.forEach((doc) => {
                    const fingerprint = doc.data();
                    let fingerprintDate = 'Unknown Date';
                    
                    if (fingerprint.timestamp) {
                        const date = new Date(fingerprint.timestamp);
                        fingerprintDate = date.toLocaleDateString();
                    } else if (fingerprint.date) {
                        fingerprintDate = fingerprint.date;
                    }
                    
                    if (!fingerprintsByDate[fingerprintDate]) {
                        fingerprintsByDate[fingerprintDate] = [];
                    }
                    fingerprintsByDate[fingerprintDate].push({ doc, fingerprint });
                });
                
                // Ordenar fechas con hoy primero
                const sortedDates = Object.keys(fingerprintsByDate).sort((a, b) => {
                    if (a === today) return -1;
                    if (b === today) return 1;
                    return new Date(b) - new Date(a);
                });
                
                // Renderizar fingerprints agrupadas por fecha
                let totalIndex = 0;
                sortedDates.forEach(date => {
                    // Crear separador de fecha
                    const isToday = date === today;
                    const dateSeparator = document.createElement('div');
                    dateSeparator.style.cssText = `
                        background: ${isToday ? '#4CAF50' : '#2196F3'};
                        color: white;
                        padding: 12px 20px;
                        margin: 20px 0 10px 0;
                        border-radius: 8px;
                        font-weight: bold;
                        text-align: center;
                        font-size: 16px;
                    `;
                    dateSeparator.innerHTML = `${isToday ? 'üìÖ TODAY' : 'üìÜ PREVIOUS DAYS'} - ${date} (${fingerprintsByDate[date].length} fingerprints)`;
                    fingerprintsList.appendChild(dateSeparator);
                    
                    // Renderizar fingerprints de esta fecha
                    fingerprintsByDate[date].forEach(({ doc, fingerprint }) => {
                        totalIndex++;
                        const fingerprintCard = createFingerprintCard(fingerprint, true, doc.id, totalIndex);
                        fingerprintsList.appendChild(fingerprintCard);
                    });
                });
                
            } catch (error) {
                console.error('Error loading all fingerprints:', error);
            }
        }

        // Load all badges (admin)
        async function loadAllBadges() {
            if (!isAdmin) return;
            
            try {
                const badgesRef = db.collection('badges').orderBy('timestamp', 'desc');
                const snapshot = await badgesRef.get();
                const badgesList = document.getElementById('admin-badges-list');
                badgesList.innerHTML = '';
                
                if (snapshot.empty) {
                    badgesList.innerHTML = '<p>No badge appointments scheduled.</p>';
                    return;
                }
                
                // Agrupar badges por fecha
                const badgesByDate = {};
                const today = new Date().toLocaleDateString();
                
                snapshot.forEach((doc) => {
                    const badge = doc.data();
                    let badgeDate = 'Unknown Date';
                    
                    if (badge.timestamp) {
                        const date = new Date(badge.timestamp);
                        badgeDate = date.toLocaleDateString();
                    } else if (badge.date) {
                        badgeDate = badge.date;
                    }
                    
                    if (!badgesByDate[badgeDate]) {
                        badgesByDate[badgeDate] = [];
                    }
                    badgesByDate[badgeDate].push({ doc, badge });
                });
                
                // Ordenar fechas con hoy primero
                const sortedDates = Object.keys(badgesByDate).sort((a, b) => {
                    if (a === today) return -1;
                    if (b === today) return 1;
                    return new Date(b) - new Date(a);
                });
                
                // Renderizar badges agrupadas por fecha
                let totalIndex = 0;
                sortedDates.forEach(date => {
                    // Crear separador de fecha
                    const isToday = date === today;
                    const dateSeparator = document.createElement('div');
                    dateSeparator.style.cssText = `
                        background: ${isToday ? '#4CAF50' : '#2196F3'};
                        color: white;
                        padding: 12px 20px;
                        margin: 20px 0 10px 0;
                        border-radius: 8px;
                        font-weight: bold;
                        text-align: center;
                        font-size: 16px;
                    `;
                    dateSeparator.innerHTML = `${isToday ? 'üìÖ TODAY' : 'üìÜ PREVIOUS DAYS'} - ${date} (${badgesByDate[date].length} badges)`;
                    badgesList.appendChild(dateSeparator);
                    
                    // Renderizar badges de esta fecha
                    badgesByDate[date].forEach(({ doc, badge }) => {
                        totalIndex++;
                        const badgeCard = createBadgeCard(badge, true, doc.id, totalIndex);
                        badgesList.appendChild(badgeCard);
                    });
                });
                
            } catch (error) {
                console.error('Error loading all badges:', error);
            }
        }

        // Load all orientations (admin)
        async function loadAllOrientations() {
            if (!isAdmin) return;
            
            try {
                const orientationsRef = db.collection('new-hire-orientations').orderBy('timestamp', 'desc');
                const snapshot = await orientationsRef.get();
                const orientationsList = document.getElementById('admin-orientations-list');
                orientationsList.innerHTML = '';
                
                if (snapshot.empty) {
                    orientationsList.innerHTML = '<p>No new hire orientations scheduled.</p>';
                    return;
                }
                
                // Agrupar orientations por fecha
                const orientationsByDate = {};
                const today = new Date().toLocaleDateString();
                
                snapshot.forEach((doc) => {
                    const orientation = doc.data();
                    let orientationDate = 'Unknown Date';
                    
                    if (orientation.timestamp) {
                        const date = new Date(orientation.timestamp);
                        orientationDate = date.toLocaleDateString();
                    } else if (orientation.date) {
                        orientationDate = orientation.date;
                    }
                    
                    if (!orientationsByDate[orientationDate]) {
                        orientationsByDate[orientationDate] = [];
                    }
                    orientationsByDate[orientationDate].push({ doc, orientation });
                });
                
                // Ordenar fechas con hoy primero
                const sortedDates = Object.keys(orientationsByDate).sort((a, b) => {
                    if (a === today) return -1;
                    if (b === today) return 1;
                    return new Date(b) - new Date(a);
                });
                
                // Renderizar orientations agrupadas por fecha
                let totalIndex = 0;
                sortedDates.forEach(date => {
                    // Crear separador de fecha
                    const isToday = date === today;
                    const dateSeparator = document.createElement('div');
                    dateSeparator.style.cssText = `
                        background: ${isToday ? '#4CAF50' : '#2196F3'};
                        color: white;
                        padding: 12px 20px;
                        margin: 20px 0 10px 0;
                        border-radius: 8px;
                        font-weight: bold;
                        text-align: center;
                        font-size: 16px;
                    `;
                    dateSeparator.innerHTML = `${isToday ? 'üìÖ TODAY' : 'üìÜ PREVIOUS DAYS'} - ${date} (${orientationsByDate[date].length} orientations)`;
                    orientationsList.appendChild(dateSeparator);
                    
                    // Renderizar orientations de esta fecha
                    orientationsByDate[date].forEach(({ doc, orientation }) => {
                        totalIndex++;
                        const orientationCard = createOrientationCard(orientation, true, doc.id, true, totalIndex);
                        orientationsList.appendChild(orientationCard);
                    });
                });
                
                // Load passed list count when admin section loads
                updatePassedListCount();
                
            } catch (error) {
                console.error('Error loading all orientations:', error);
            }
        }
        
        // Global variable to store passed list data (DataFrame-like structure)
        let passedListDataFrame = [];
        
        // Update passed list count display
        async function updatePassedListCount() {
            try {
                const passedListDoc = await db.collection('settings').doc('passed-list').get();
                if (passedListDoc.exists) {
                    const data = passedListDoc.data();
                    passedListDataFrame = data.people || [];
                    document.getElementById('passed-list-count').textContent = 
                        `Current List: ${passedListDataFrame.length} people`;
                } else {
                    passedListDataFrame = [];
                    document.getElementById('passed-list-count').textContent = 'Current List: 0 people';
                }
            } catch (error) {
                console.error('Error loading passed list count:', error);
                document.getElementById('passed-list-count').textContent = 'Current List: Error loading';
            }
        }
        
        // Download Excel template
        function downloadPassedListTemplate() {
            const template = [
                ['Name', 'Email', 'Completed on Tracker'],
                ['John Doe', 'john.doe@email.com', '2024-01-15'],
                ['Jane Smith', 'jane.smith@email.com', '2024-01-20']
            ];
            
            const ws = XLSX.utils.aoa_to_sheet(template);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Template');
            XLSX.writeFile(wb, 'passed_list_template.xlsx');
        }
        
        // Handle Excel file upload for adding new people
        async function handlePassedListAdd() {
            const fileInput = document.getElementById('passed-list-add-file');
            const file = fileInput.files[0];
            
            if (!file) return;
            
            try {
                const workbook = await readExcelFile(file);
                const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                
                // Skip header row and process data
                const newPeople = [];
                for (let i = 1; i < jsonData.length; i++) {
                    const row = jsonData[i];
                    if (row[0]) { // At least name is required
                        const fullName = row[0].toString().trim();
                        const nameParts = fullName.split(' ');
                        const firstName = nameParts[0] || '';
                        const lastName = nameParts.slice(1).join(' ') || '';
                        
                        newPeople.push({
                            name: fullName,
                            firstName: firstName,
                            lastName: lastName,
                            email: row[1] ? row[1].toString().trim() : '',
                            completedOnTracker: row[2] ? row[2].toString().trim() : '',
                            rowNumber: (i).toString(),
                            addedAt: new Date().toISOString()
                        });
                    }
                }
                
                if (newPeople.length === 0) {
                    showErrorMessage('No valid data found in Excel file. Please check the format.');
                    return;
                }
                
                // Add new people to existing list
                passedListDataFrame = passedListDataFrame.concat(newPeople);
                
                await savePassedListToFirestore();
                showSuccessMessage(`Added ${newPeople.length} new people to the passed list!`);
                fileInput.value = '';
                
            } catch (error) {
                console.error('Error processing Excel file:', error);
                showErrorMessage('Error processing Excel file. Please check the format.');
                fileInput.value = '';
            }
        }
        
        // Handle Excel file upload for replacing entire list
        async function handlePassedListReplace() {
            const fileInput = document.getElementById('passed-list-replace-file');
            const file = fileInput.files[0];
            
            if (!file) return;
            
            if (!confirm('This will replace the entire passed list. Are you sure?')) {
                fileInput.value = '';
                return;
            }
            
            try {
                const workbook = await readExcelFile(file);
                const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                
                // Skip header row and process data
                const newPeople = [];
                for (let i = 1; i < jsonData.length; i++) {
                    const row = jsonData[i];
                    if (row[0]) { // At least name is required
                        const fullName = row[0].toString().trim();
                        const nameParts = fullName.split(' ');
                        const firstName = nameParts[0] || '';
                        const lastName = nameParts.slice(1).join(' ') || '';
                        
                        newPeople.push({
                            name: fullName,
                            firstName: firstName,
                            lastName: lastName,
                            email: row[1] ? row[1].toString().trim() : '',
                            completedOnTracker: row[2] ? row[2].toString().trim() : '',
                            rowNumber: (i).toString(),
                            addedAt: new Date().toISOString()
                        });
                    }
                }
                
                if (newPeople.length === 0) {
                    showErrorMessage('No valid data found in Excel file. Please check the format.');
                    return;
                }
                
                // Replace entire list
                passedListDataFrame = newPeople;
                
                await savePassedListToFirestore();
                showSuccessMessage(`Replaced passed list with ${newPeople.length} people!`);
                fileInput.value = '';
                
            } catch (error) {
                console.error('Error processing Excel file:', error);
                showErrorMessage('Error processing Excel file. Please check the format.');
                fileInput.value = '';
            }
        }
        
        // Read Excel file as Promise
        function readExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        resolve(workbook);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }
        
        // Save passed list to Firestore
        async function savePassedListToFirestore() {
            try {
                await db.collection('settings').doc('passed-list').set({
                    people: passedListDataFrame,
                    lastUpdated: new Date().toISOString(),
                    updatedBy: currentUser ? currentUser.email : 'unknown'
                });
                updatePassedListCount();
            } catch (error) {
                console.error('Error saving passed list:', error);
                throw error;
            }
        }
        
        // Clear passed list
        async function clearPassedList() {
            if (!confirm('Are you sure you want to clear all passed list data? This cannot be undone.')) {
                return;
            }
            
            try {
                passedListDataFrame = [];
                await savePassedListToFirestore();
                showSuccessMessage('Passed list cleared successfully!');
            } catch (error) {
                console.error('Error clearing passed list:', error);
                showErrorMessage('Error clearing passed list.');
            }
        }
        
        // Export current passed list
        function exportPassedList() {
            if (passedListDataFrame.length === 0) {
                showErrorMessage('No data to export.');
                return;
            }
            
            // Convert DataFrame to Excel format
            const exportData = [
                ['Name', 'Email', 'Completed on Tracker', 'Row', 'Added Date']
            ];
            
            passedListDataFrame.forEach(person => {
                exportData.push([
                    person.name || `${person.firstName} ${person.lastName}`.trim(),
                    person.email,
                    person.completedOnTracker,
                    person.rowNumber,
                    person.addedAt ? new Date(person.addedAt).toLocaleDateString() : ''
                ]);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(exportData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Passed List');
            
            const timestamp = new Date().toISOString().split('T')[0];
            XLSX.writeFile(wb, `passed_list_${timestamp}.xlsx`);
            
            showSuccessMessage('Passed list exported successfully!');
        }
        
        // Search passed list function for staff
        async function searchPassedList() {
            const firstName = document.getElementById('search-first-name').value.trim().toLowerCase();
            const lastName = document.getElementById('search-last-name').value.trim().toLowerCase();
            const resultsDiv = document.getElementById('search-results');
            const resultsContent = document.getElementById('search-results-content');
            
            if (!firstName && !lastName) {
                resultsDiv.style.display = 'none';
                return;
            }
            
            try {
                // Load passed list if not already loaded
                if (passedListDataFrame.length === 0) {
                    const passedListDoc = await db.collection('settings').doc('passed-list').get();
                    if (passedListDoc.exists) {
                        const data = passedListDoc.data();
                        passedListDataFrame = data.people || [];
                    }
                }
                
                // Search DataFrame - improved search logic
                const matches = passedListDataFrame.filter(person => {
                    // Get full name from person.name or combine first/last name
                    const fullName = (person.name || `${person.firstName} ${person.lastName}`).toLowerCase();
                    
                    // If only first name is provided, search in full name
                    if (firstName && !lastName) {
                        return fullName.includes(firstName);
                    }
                    
                    // If only last name is provided, search in full name  
                    if (lastName && !firstName) {
                        return fullName.includes(lastName);
                    }
                    
                    // If both first and last name are provided
                    if (firstName && lastName) {
                        // Try exact match first: "firstName lastName"
                        const searchTerm = `${firstName} ${lastName}`;
                        if (fullName.includes(searchTerm)) {
                            return true;
                        }
                        
                        // Also try reverse: "lastName firstName"
                        const reverseSearchTerm = `${lastName} ${firstName}`;
                        if (fullName.includes(reverseSearchTerm)) {
                            return true;
                        }
                        
                        // Try individual components (both must be present)
                        const hasFirstName = fullName.includes(firstName);
                        const hasLastName = fullName.includes(lastName);
                        return hasFirstName && hasLastName;
                    }
                    
                    return false;
                });
                
                resultsContent.innerHTML = '';
                resultsDiv.style.display = 'block';
                
                if (matches.length === 0) {
                    resultsContent.innerHTML = '<p style="color: #d32f2f;">‚ùå No matches found</p>';
                    return;
                }
                
                // Display results
                matches.forEach((person, index) => {
                    const resultCard = document.createElement('div');
                    resultCard.style.cssText = `
                        background: rgba(255,255,255,0.9); 
                        border-radius: 8px; 
                        padding: 15px; 
                        margin-bottom: 10px; 
                        border-left: 5px solid #4caf50;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    `;
                    
                    resultCard.innerHTML = `
                        <div>
                            <strong style="color: #2e7d32;">${person.name || `${person.firstName} ${person.lastName}`.trim()}</strong>
                            ${person.email ? `<br><small style="color: #666;">üìß ${person.email}</small>` : ''}
                            <br><small style="color: #666;">üìç Row: ${person.rowNumber}</small>
                            ${person.completedOnTracker ? `<br><small style="color: #666;">üìÖ Completed: ${person.completedOnTracker}</small>` : ''}
                        </div>
                        <div style="text-align: right; color: #4caf50; font-weight: bold; font-size: 18px;">
                            ‚úÖ Found
                        </div>
                    `;
                    
                    resultsContent.appendChild(resultCard);
                });
                
            } catch (error) {
                console.error('Error searching passed list:', error);
                resultsContent.innerHTML = '<p style="color: #d32f2f;">‚ùå Error searching list</p>';
                resultsDiv.style.display = 'block';
            }
        }
        
        // Clear search
        function clearSearch() {
            document.getElementById('search-first-name').value = '';
            document.getElementById('search-last-name').value = '';
            document.getElementById('search-results').style.display = 'none';
        }
        
        // Daily divider functionality - creates divisions at 6 AM daily
        function shouldShowDailyDivider(currentTimestamp, previousTimestamp) {
            if (!previousTimestamp) return false;
            
            const current = new Date(currentTimestamp.toDate ? currentTimestamp.toDate() : currentTimestamp);
            const previous = new Date(previousTimestamp.toDate ? previousTimestamp.toDate() : previousTimestamp);
            
            // Get 6 AM of current day
            const current6AM = new Date(current);
            current6AM.setHours(6, 0, 0, 0);
            
            // Get 6 AM of previous day
            const previous6AM = new Date(previous);
            previous6AM.setHours(6, 0, 0, 0);
            
            // If entries are on different sides of 6 AM boundary, show divider
            return current >= current6AM && previous < current6AM;
        }
        
        function createDailyDivider(timestamp) {
            const divider = document.createElement('div');
            const date = new Date(timestamp.toDate ? timestamp.toDate() : timestamp);
            
            // Format date to show the day this section represents
            const options = { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            };
            const dateStr = date.toLocaleDateString('en-US', options);
            
            divider.style.cssText = `
                margin: 30px 0 20px 0;
                padding: 15px;
                background: linear-gradient(135deg, #e3f2fd, #bbdefb);
                border-left: 5px solid #2196f3;
                border-radius: 8px;
                text-align: center;
                font-weight: bold;
                color: #1976d2;
                position: relative;
                overflow: hidden;
            `;
            
            divider.innerHTML = `
                <div style="font-size: 18px; margin-bottom: 5px;">üìÖ ${dateStr}</div>
                <div style="font-size: 14px; opacity: 0.8;">All records preserved permanently</div>
                <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, #2196f3, transparent);"></div>
            `;
            
            return divider;
        }
        
        // Generate document status badges
        function getDocumentStatusBadge(status, isI9 = false) {
            if (!status) {
                return '<span style="background: #e9ecef; color: #6c757d; padding: 2px 6px; border-radius: 8px; font-size: 11px;">‚ùì Not Started</span>';
            }
            
            switch (status) {
                case 'completed':
                    return '<span style="background: #d4edda; color: #155724; padding: 2px 6px; border-radius: 8px; font-size: 11px;">‚úÖ Completed</span>';
                case 'in-progress':
                    return '<span style="background: #fff3cd; color: #856404; padding: 2px 6px; border-radius: 8px; font-size: 11px;">üîÑ In Progress</span>';
                case 'existing':
                    return '<span style="background: #d1ecf1; color: #0c5460; padding: 2px 6px; border-radius: 8px; font-size: 11px;">üìÑ Existing I9</span>';
                case 'ineligible':
                    return '<span style="background: #f8d7da; color: #721c24; padding: 2px 6px; border-radius: 8px; font-size: 11px;">‚ùå Inelegible</span>';
                default:
                    return '<span style="background: #e9ecef; color: #6c757d; padding: 2px 6px; border-radius: 8px; font-size: 11px;">‚ùì Unknown</span>';
            }
        }
        
        // Calculate work day based on 6 AM cutoff
        function getWorkDay() {
            const now = new Date();
            const currentHour = now.getHours();
            
            // If it's before 6 AM, consider it part of the previous work day
            if (currentHour < 6) {
                const yesterday = new Date(now);
                yesterday.setDate(now.getDate() - 1);
                return yesterday.toISOString().split('T')[0];
            } else {
                // 6 AM or later, it's the current work day
                return now.toISOString().split('T')[0];
            }
        }

        // Load booking counts (staff)
        async function loadBookingCounts() {
            if (!currentUser) return;
            
            try {
                const bookingCountsList = document.getElementById('booking-counts-list');
                bookingCountsList.innerHTML = '';
                
                const counts = await getBookingCounts();
                
                if (!counts.infoSessions && !counts.newHireOrientations && !counts.teamVisits && !counts.fingerprints && !counts.badges) {
                    bookingCountsList.innerHTML = '<p>No bookings found.</p>';
                    return;
                }
                
                const countsCard = createBookingCountsCard(counts);
                bookingCountsList.appendChild(countsCard);
                
            } catch (error) {
                console.error('Error loading booking counts:', error);
                showErrorMessage('Error loading booking counts.');
            }
        }

        // Load admin booking counts
        async function loadAdminBookingCounts() {
            if (!isAdmin) return;
            
            try {
                const bookingCountsList = document.getElementById('admin-booking-counts-list');
                bookingCountsList.innerHTML = '';
                
                const counts = await getBookingCounts();
                
                if (!counts.infoSessions && !counts.newHireOrientations && !counts.teamVisits && !counts.fingerprints && !counts.badges) {
                    bookingCountsList.innerHTML = '<p>No bookings found.</p>';
                    return;
                }
                
                const countsCard = createBookingCountsCard(counts, true);
                bookingCountsList.appendChild(countsCard);
                
            } catch (error) {
                console.error('Error loading admin booking counts:', error);
            }
        }

        // Load today's statistics
        function loadTodayStatistics() {
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            document.getElementById('stats-date').value = todayStr;
            loadDailyStatistics();
        }

        // Load weekly statistics  
        function loadWeeklyStatistics() {
            const today = new Date();
            const oneWeekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
            loadDateRangeStatistics(oneWeekAgo, today, 'This Week');
        }

        // Load monthly statistics
        function loadMonthlyStatistics() {
            const today = new Date();
            const firstOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
            loadDateRangeStatistics(firstOfMonth, today, 'This Month');
        }

        // Load complete historical DataFrame
        async function loadHistoricalDataFrame() {
            if (!currentUser) return;
            
            const statisticsList = document.getElementById('daily-statistics-list');
            statisticsList.innerHTML = '<div style="text-align: center; padding: 40px;"><p>üìä Loading complete historical data...</p><div style="margin-top: 20px;"><div class="spinner-border" style="width: 3rem; height: 3rem;"></div></div></div>';
            
            try {
                const dataFrame = await createHistoricalDataFrame();
                displayHistoricalDataFrame(dataFrame);
            } catch (error) {
                console.error('Error loading historical DataFrame:', error);
                statisticsList.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 40px;"><p>‚ùå Error loading historical data</p><p>' + error.message + '</p></div>';
            }
        }

        // Display historical DataFrame
        function displayHistoricalDataFrame(dataFrame) {
            const statisticsList = document.getElementById('daily-statistics-list');
            
            const totalRecords = dataFrame.visits.length + dataFrame.infoSessions.length + dataFrame.orientations.length + dataFrame.fingerprints.length + dataFrame.badges.length;
            const summaryDates = dataFrame.summary.length;
            
            let html = `
                <div class="visit-card">
                    <h4>üìä Complete Historical Data Analysis</h4>
                    <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h5>üìà Overall Summary</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                            <div style="text-align: center;">
                                <strong style="font-size: 24px; color: #1976d2;">${totalRecords}</strong>
                                <div style="font-size: 14px; color: #666;">Total Records</div>
                            </div>
                            <div style="text-align: center;">
                                <strong style="font-size: 24px; color: #388e3c;">${dataFrame.visits.length}</strong>
                                <div style="font-size: 14px; color: #666;">Visits</div>
                            </div>
                            <div style="text-align: center;">
                                <strong style="font-size: 24px; color: #f57c00;">${dataFrame.infoSessions.length}</strong>
                                <div style="font-size: 14px; color: #666;">Info Sessions</div>
                            </div>
                            <div style="text-align: center;">
                                <strong style="font-size: 24px; color: #7b1fa2;">${dataFrame.orientations.length}</strong>
                                <div style="font-size: 14px; color: #666;">Orientations</div>
                            </div>
                            <div style="text-align: center;">
                                <strong style="font-size: 24px; color: #c62828;">${dataFrame.fingerprints.length}</strong>
                                <div style="font-size: 14px; color: #666;">Fingerprints</div>
                            </div>
                            <div style="text-align: center;">
                                <strong style="font-size: 24px; color: #00796b;">${dataFrame.badges.length}</strong>
                                <div style="font-size: 14px; color: #666;">Badges</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <button class="btn btn-success" onclick="exportHistoricalDataFrame()">üìä Export Complete Data</button>
                        <button class="btn btn-secondary" onclick="toggleHistoricalDetails()" id="toggle-details-btn">üìã Show Daily Breakdown</button>
                    </div>
                    
                    <div id="historical-details" style="display: none;">
                        <h5>üìÖ Daily Breakdown (${summaryDates} days with data)</h5>
                        <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead style="background: #f8f9fa; position: sticky; top: 0;">
                                    <tr>
                                        <th style="padding: 8px; border-bottom: 2px solid #ddd; text-align: left;">Date</th>
                                        <th style="padding: 8px; border-bottom: 2px solid #ddd; text-align: center;">Visits</th>
                                        <th style="padding: 8px; border-bottom: 2px solid #ddd; text-align: center;">Info Sessions</th>
                                        <th style="padding: 8px; border-bottom: 2px solid #ddd; text-align: center;">Orientations</th>
                                        <th style="padding: 8px; border-bottom: 2px solid #ddd; text-align: center;">Fingerprints</th>
                                        <th style="padding: 8px; border-bottom: 2px solid #ddd; text-align: center;">Badges</th>
                                        <th style="padding: 8px; border-bottom: 2px solid #ddd; text-align: center; background: #e8f5e8;"><strong>Total</strong></th>
                                    </tr>
                                </thead>
                                <tbody>`;
                                
            dataFrame.summary.forEach((day, index) => {
                const formattedDate = new Date(day.date + 'T00:00:00').toLocaleDateString();
                const isToday = day.date === new Date().toISOString().split('T')[0];
                const bgColor = isToday ? 'background: #fff3cd;' : (index % 2 === 0 ? 'background: #f8f9fa;' : '');
                
                html += `
                    <tr style="${bgColor}" ${isToday ? 'title="Today"' : ''}>
                        <td style="padding: 8px; border-bottom: 1px solid #eee; font-weight: ${isToday ? 'bold' : 'normal'};">
                            ${formattedDate} ${isToday ? '(Today)' : ''}
                        </td>
                        <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${day.visits}</td>
                        <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${day.infoSessions}</td>
                        <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${day.orientations}</td>
                        <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${day.fingerprints}</td>
                        <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">${day.badges}</td>
                        <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center; font-weight: bold; background: #e8f5e8;">${day.total}</td>
                    </tr>`;
            });
            
            html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 14px; color: #666;">
                        <strong>üìã Data Source Information:</strong><br>
                        ‚Ä¢ Current collections: Live data from active database collections<br>
                        ‚Ä¢ Archived data: Historical data preserved from daily archives<br>
                        ‚Ä¢ All records maintained permanently for complete historical analysis<br>
                        ‚Ä¢ Data includes both active and archived records for comprehensive reporting
                    </div>
                </div>`;
            
            statisticsList.innerHTML = html;
            
            // Store dataFrame globally for export
            window.currentHistoricalDataFrame = dataFrame;
        }

        // Toggle historical details
        function toggleHistoricalDetails() {
            const details = document.getElementById('historical-details');
            const button = document.getElementById('toggle-details-btn');
            
            if (details.style.display === 'none') {
                details.style.display = 'block';
                button.textContent = 'üìã Hide Daily Breakdown';
            } else {
                details.style.display = 'none';
                button.textContent = 'üìã Show Daily Breakdown';
            }
        }

        // Debug currently selected date
        function debugCurrentDate() {
            const selectedDate = document.getElementById('stats-date').value;
            if (!selectedDate) {
                alert('Please select a date first');
                return;
            }
            debugDateData(selectedDate);
        }

        // Export historical DataFrame
        async function exportHistoricalDataFrame() {
            if (!window.currentHistoricalDataFrame) {
                showErrorMessage('No historical data loaded. Please load the complete history first.');
                return;
            }
            
            try {
                const dataFrame = window.currentHistoricalDataFrame;
                const workbook = XLSX.utils.book_new();
                
                // Summary sheet
                const summaryData = [
                    ['Complete Historical Data Export', ''],
                    ['Export Date', new Date().toLocaleDateString()],
                    [''],
                    ['Summary Statistics', ''],
                    ['Total Visits', dataFrame.visits.length],
                    ['Total Info Sessions', dataFrame.infoSessions.length],
                    ['Total Orientations', dataFrame.orientations.length],
                    ['Total Fingerprints', dataFrame.fingerprints.length],
                    ['Total Badges', dataFrame.badges.length],
                    ['Total Records', dataFrame.visits.length + dataFrame.infoSessions.length + dataFrame.orientations.length + dataFrame.fingerprints.length + dataFrame.badges.length],
                    ['Days with Data', dataFrame.summary.length]
                ];
                
                const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
                XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
                
                // Daily breakdown sheet
                const dailyData = [['Date', 'Visits', 'Info Sessions', 'Orientations', 'Fingerprints', 'Badges', 'Total']];
                dataFrame.summary.forEach(day => {
                    dailyData.push([
                        new Date(day.date + 'T00:00:00').toLocaleDateString(),
                        day.visits,
                        day.infoSessions,
                        day.orientations,
                        day.fingerprints,
                        day.badges,
                        day.total
                    ]);
                });
                
                const dailySheet = XLSX.utils.aoa_to_sheet(dailyData);
                XLSX.utils.book_append_sheet(workbook, dailySheet, 'Daily Breakdown');
                
                // Individual data sheets
                ['visits', 'infoSessions', 'orientations', 'fingerprints', 'badges'].forEach(type => {
                    if (dataFrame[type].length > 0) {
                        const data = dataFrame[type].map(record => {
                            const cleanRecord = { ...record };
                            delete cleanRecord.id; // Remove internal ID
                            return cleanRecord;
                        });
                        
                        const ws = XLSX.utils.json_to_sheet(data);
                        XLSX.utils.book_append_sheet(workbook, ws, type.charAt(0).toUpperCase() + type.slice(1));
                    }
                });
                
                const fileName = `Complete_Historical_Data_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(workbook, fileName);
                
                showSuccessMessage('Historical data exported successfully!');
                
            } catch (error) {
                console.error('Error exporting historical data:', error);
                showErrorMessage('Error exporting data. Please try again.');
            }
        }

        // Load statistics for a specific date
        async function loadDailyStatistics() {
            if (!currentUser) return;
            
            const selectedDate = document.getElementById('stats-date').value;
            if (!selectedDate) return;
            
            const statisticsList = document.getElementById('daily-statistics-list');
            statisticsList.innerHTML = '<p>Loading statistics...</p>';
            
            try {
                const stats = await getDailyStatistics(selectedDate);
                displayDailyStatistics(stats, selectedDate);
            } catch (error) {
                console.error('Error loading daily statistics:', error);
                statisticsList.innerHTML = '<p>Error loading statistics.</p>';
            }
        }

        // Load statistics for date range
        async function loadDateRangeStatistics(startDate, endDate, title) {
            if (!currentUser) return;
            
            const statisticsList = document.getElementById('daily-statistics-list');
            statisticsList.innerHTML = '<p>Loading statistics...</p>';
            
            try {
                const stats = await getDateRangeStatistics(startDate, endDate);
                displayRangeStatistics(stats, title, startDate, endDate);
            } catch (error) {
                console.error('Error loading range statistics:', error);
                statisticsList.innerHTML = '<p>Error loading statistics.</p>';
            }
        }

        // Get statistics for a specific date (includes archived data)
        async function getDailyStatistics(dateStr) {
            console.log('Getting daily statistics for date:', dateStr);
            console.log('Date format check - input dateStr:', typeof dateStr, dateStr);
            
            const stats = {
                date: dateStr,
                visits: 0,
                infoSessions: { total: 0, byTime: { '8:30': 0, '10:00': 0, '1:30': 0 } },
                orientations: { total: 0, byTime: { '9:00-12:00': 0, '1:30-4:30': 0 } },
                fingerprints: 0,
                badges: 0,
                visitsList: [],
                infoSessionsList: [],
                orientationsList: [],
                fingerprintsList: [],
                badgesList: []
            };

            // First, try to get data from active collections
            try {
                // Get visits for the date
                console.log('Querying visits...');
                const visitsSnapshot = await db.collection('visits').where('date', '==', dateStr).get();
                stats.visits = visitsSnapshot.size;
                console.log('Found visits:', stats.visits);
                visitsSnapshot.forEach(doc => {
                    stats.visitsList.push({ id: doc.id, ...doc.data() });
                });
            } catch (error) {
                console.error('Error loading visits:', error);
            }

            try {
                // Get info sessions for the date
                console.log('Querying info sessions...');
                const infoSnapshot = await db.collection('info-sessions').where('date', '==', dateStr).get();
                stats.infoSessions.total = infoSnapshot.size;
                console.log('Found info sessions:', stats.infoSessions.total);
                infoSnapshot.forEach(doc => {
                    const data = { id: doc.id, ...doc.data() };
                    stats.infoSessionsList.push(data);
                    if (data.session === '8:30 AM') stats.infoSessions.byTime['8:30']++;
                    else if (data.session === '10:00 AM') stats.infoSessions.byTime['10:00']++;
                    else if (data.session === '1:30 PM') stats.infoSessions.byTime['1:30']++;
                });
            } catch (error) {
                console.error('Error loading info sessions:', error);
            }

            try {
                // Get orientations for the date
                console.log('Querying orientations...');
                const orientationsSnapshot = await db.collection('new-hire-orientations').where('date', '==', dateStr).get();
                stats.orientations.total = orientationsSnapshot.size;
                console.log('Found orientations:', stats.orientations.total);
                orientationsSnapshot.forEach(doc => {
                    const data = { id: doc.id, ...doc.data() };
                    stats.orientationsList.push(data);
                    if (data.session === '9:00 AM - 12:00 PM') stats.orientations.byTime['9:00-12:00']++;
                    else if (data.session === '1:30 PM - 4:30 PM') stats.orientations.byTime['1:30-4:30']++;
                });
            } catch (error) {
                console.error('Error loading orientations:', error);
            }

            try {
                // Get fingerprints for the date
                console.log('Querying fingerprints...');
                const fingerprintsSnapshot = await db.collection('fingerprints').where('date', '==', dateStr).get();
                stats.fingerprints = fingerprintsSnapshot.size;
                console.log('Found fingerprints:', stats.fingerprints);
                fingerprintsSnapshot.forEach(doc => {
                    stats.fingerprintsList.push({ id: doc.id, ...doc.data() });
                });
            } catch (error) {
                console.error('Error loading fingerprints:', error);
            }

            try {
                // Get badges for the date
                console.log('Querying badges...');
                const badgesSnapshot = await db.collection('badges').where('date', '==', dateStr).get();
                stats.badges = badgesSnapshot.size;
                console.log('Found badges:', stats.badges);
                badgesSnapshot.forEach(doc => {
                    stats.badgesList.push({ id: doc.id, ...doc.data() });
                });
            } catch (error) {
                console.error('Error loading badges:', error);
            }

            // Also check daily archives for any missing data types
            // This ensures we get archived data even if some current data exists for the date
            console.log('Checking archives for additional data for:', dateStr);
            try {
                const archiveSnapshot = await db.collection('daily-archives').doc(dateStr).get();
                if (archiveSnapshot.exists) {
                    const archiveData = archiveSnapshot.data();
                    console.log('Found archived data for:', dateStr);
                    console.log('Archive data keys:', Object.keys(archiveData));
                    if (archiveData.newHireOrientations) {
                        console.log('newHireOrientations found in archive, count:', archiveData.newHireOrientations.length);
                    } else {
                        console.log('newHireOrientations NOT found in archive data');
                    }
                    
                    // Add archived visits if none found in current collections
                    if (stats.visits === 0 && archiveData.visits) {
                        const filteredVisits = archiveData.visits.filter(visit => visit.date === dateStr);
                        stats.visits = filteredVisits.length;
                        stats.visitsList = filteredVisits;
                    }
                    
                    // Add archived info sessions if none found in current collections
                    if (stats.infoSessions.total === 0 && archiveData.infoSessions) {
                        const filteredSessions = archiveData.infoSessions.filter(session => session.date === dateStr);
                        stats.infoSessions.total = filteredSessions.length;
                        stats.infoSessionsList = filteredSessions;
                        filteredSessions.forEach(session => {
                            if (session.session === '8:30 AM') stats.infoSessions.byTime['8:30']++;
                            else if (session.session === '10:00 AM') stats.infoSessions.byTime['10:00']++;
                            else if (session.session === '1:30 PM') stats.infoSessions.byTime['1:30']++;
                        });
                    }
                    
                    // Add archived orientations if none found in current collections
                    if (stats.orientations.total === 0 && archiveData.newHireOrientations) {
                        console.log('Found archived orientations:', archiveData.newHireOrientations.length);
                        console.log('Sample orientation data:', archiveData.newHireOrientations[0]);
                        const filteredOrientations = archiveData.newHireOrientations.filter(orientation => orientation.date === dateStr);
                        console.log('Filtered orientations for', dateStr, ':', filteredOrientations.length);
                        stats.orientations.total = filteredOrientations.length;
                        stats.orientationsList = filteredOrientations;
                        filteredOrientations.forEach(orientation => {
                            if (orientation.session === '9:00 AM - 12:00 PM') stats.orientations.byTime['9:00-12:00']++;
                            else if (orientation.session === '1:30 PM - 4:30 PM') stats.orientations.byTime['1:30-4:30']++;
                        });
                    } else if (stats.orientations.total === 0) {
                        console.log('No archived orientations found in archive for:', dateStr);
                    }
                    
                    // Add archived fingerprints if none found in current collections
                    if (stats.fingerprints === 0 && archiveData.fingerprints) {
                        const filteredFingerprints = archiveData.fingerprints.filter(fingerprint => fingerprint.date === dateStr);
                        stats.fingerprints = filteredFingerprints.length;
                        stats.fingerprintsList = filteredFingerprints;
                    }
                    
                    // Add archived badges if none found in current collections
                    if (stats.badges === 0 && archiveData.badges) {
                        const filteredBadges = archiveData.badges.filter(badge => badge.date === dateStr);
                        stats.badges = filteredBadges.length;
                        stats.badgesList = filteredBadges;
                    }
                    
                    console.log('Final stats after checking archives:', {
                        visits: stats.visits,
                        infoSessions: stats.infoSessions.total,
                        orientations: stats.orientations.total,
                        fingerprints: stats.fingerprints,
                        badges: stats.badges
                    });
                }
            } catch (error) {
                console.error('Error loading archived data:', error);
            }

            console.log('Final stats:', stats);
            return stats;
        }

        // Get statistics for date range
        async function getDateRangeStatistics(startDate, endDate) {
            const startStr = startDate.toISOString().split('T')[0];
            const endStr = endDate.toISOString().split('T')[0];
            
            const stats = {
                startDate: startStr,
                endDate: endStr,
                totalVisits: 0,
                totalInfoSessions: 0,
                totalOrientations: 0,
                totalFingerprints: 0,
                totalBadges: 0,
                dailyBreakdown: []
            };

            // Get all dates in range
            const currentDate = new Date(startDate);
            while (currentDate <= endDate) {
                const dateStr = currentDate.toISOString().split('T')[0];
                const dayStats = await getDailyStatistics(dateStr);
                
                stats.totalVisits += dayStats.visits;
                stats.totalInfoSessions += dayStats.infoSessions.total;
                stats.totalOrientations += dayStats.orientations.total;
                stats.totalFingerprints += dayStats.fingerprints;
                stats.totalBadges += dayStats.badges;
                
                stats.dailyBreakdown.push({
                    date: dateStr,
                    visits: dayStats.visits,
                    infoSessions: dayStats.infoSessions.total,
                    orientations: dayStats.orientations.total,
                    fingerprints: dayStats.fingerprints,
                    badges: dayStats.badges
                });
                
                currentDate.setDate(currentDate.getDate() + 1);
            }

            return stats;
        }

        // Create historical DataFrame for comprehensive data analysis
        async function createHistoricalDataFrame() {
            console.log('Creating comprehensive historical DataFrame...');
            
            const dataFrame = {
                visits: [],
                infoSessions: [],
                orientations: [],
                fingerprints: [],
                badges: [],
                summary: []
            };
            
            try {
                // Get all data from current collections
                const collections = [
                    { name: 'visits', key: 'visits' },
                    { name: 'info-sessions', key: 'infoSessions' },
                    { name: 'new-hire-orientations', key: 'orientations' },
                    { name: 'fingerprints', key: 'fingerprints' },
                    { name: 'badges', key: 'badges' }
                ];
                
                // Collect current data
                for (const collection of collections) {
                    const snapshot = await db.collection(collection.name).get();
                    snapshot.forEach(doc => {
                        const data = { id: doc.id, ...doc.data() };
                        dataFrame[collection.key].push(data);
                    });
                }
                
                // Get all archived data
                const archivesSnapshot = await db.collection('daily-archives').get();
                archivesSnapshot.forEach(doc => {
                    const archiveData = doc.data();
                    const archiveDate = doc.id;
                    
                    // Add archived visits
                    if (archiveData.visits) {
                        archiveData.visits.forEach(visit => {
                            dataFrame.visits.push({ ...visit, archivedDate: archiveDate });
                        });
                    }
                    
                    // Add archived info sessions
                    if (archiveData.infoSessions) {
                        archiveData.infoSessions.forEach(session => {
                            dataFrame.infoSessions.push({ ...session, archivedDate: archiveDate });
                        });
                    }
                    
                    // Add archived orientations
                    if (archiveData.newHireOrientations) {
                        archiveData.newHireOrientations.forEach(orientation => {
                            dataFrame.orientations.push({ ...orientation, archivedDate: archiveDate });
                        });
                    }
                    
                    // Add archived fingerprints
                    if (archiveData.fingerprints) {
                        archiveData.fingerprints.forEach(fingerprint => {
                            dataFrame.fingerprints.push({ ...fingerprint, archivedDate: archiveDate });
                        });
                    }
                    
                    // Add archived badges
                    if (archiveData.badges) {
                        archiveData.badges.forEach(badge => {
                            dataFrame.badges.push({ ...badge, archivedDate: archiveDate });
                        });
                    }
                });
                
                // Generate summary statistics by date
                const dateStats = {};
                
                // Process all data types to create date-wise summary
                ['visits', 'infoSessions', 'orientations', 'fingerprints', 'badges'].forEach(type => {
                    dataFrame[type].forEach(record => {
                        const date = record.date;
                        if (!dateStats[date]) {
                            dateStats[date] = {
                                date: date,
                                visits: 0,
                                infoSessions: 0,
                                orientations: 0,
                                fingerprints: 0,
                                badges: 0,
                                total: 0
                            };
                        }
                        dateStats[date][type]++;
                        dateStats[date].total++;
                    });
                });
                
                // Convert summary to array and sort by date
                dataFrame.summary = Object.values(dateStats).sort((a, b) => new Date(b.date) - new Date(a.date));
                
                console.log('Historical DataFrame created:', {
                    totalVisits: dataFrame.visits.length,
                    totalInfoSessions: dataFrame.infoSessions.length,
                    totalOrientations: dataFrame.orientations.length,
                    totalFingerprints: dataFrame.fingerprints.length,
                    totalBadges: dataFrame.badges.length,
                    summaryDates: dataFrame.summary.length
                });
                
                return dataFrame;
                
            } catch (error) {
                console.error('Error creating historical DataFrame:', error);
                throw error;
            }
        }
        
        // Query DataFrame by date range
        function queryDataFrameByDateRange(dataFrame, startDate, endDate) {
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            const filteredData = {
                visits: dataFrame.visits.filter(item => {
                    const itemDate = new Date(item.date);
                    return itemDate >= start && itemDate <= end;
                }),
                infoSessions: dataFrame.infoSessions.filter(item => {
                    const itemDate = new Date(item.date);
                    return itemDate >= start && itemDate <= end;
                }),
                orientations: dataFrame.orientations.filter(item => {
                    const itemDate = new Date(item.date);
                    return itemDate >= start && itemDate <= end;
                }),
                fingerprints: dataFrame.fingerprints.filter(item => {
                    const itemDate = new Date(item.date);
                    return itemDate >= start && itemDate <= end;
                }),
                badges: dataFrame.badges.filter(item => {
                    const itemDate = new Date(item.date);
                    return itemDate >= start && itemDate <= end;
                }),
                summary: dataFrame.summary.filter(item => {
                    const itemDate = new Date(item.date);
                    return itemDate >= start && itemDate <= end;
                })
            };
            
            return filteredData;
        }

        // Display daily statistics
        function displayDailyStatistics(stats, dateStr) {
            const statisticsList = document.getElementById('daily-statistics-list');
            
            const formattedDate = new Date(dateStr + 'T00:00:00').toLocaleDateString();
            
            statisticsList.innerHTML = `
                <div class="visit-card">
                    <h4>Statistics for ${formattedDate}</h4>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Visits</h5>
                            <h3 style="color: #007bff; margin: 0;">${stats.visits}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Info Sessions</h5>
                            <h3 style="color: #28a745; margin: 0;">${stats.infoSessions.total}</h3>
                            <small>8:30(${stats.infoSessions.byTime['8:30']}) 10:00(${stats.infoSessions.byTime['10:00']}) 1:30(${stats.infoSessions.byTime['1:30']})</small>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Orientations</h5>
                            <h3 style="color: #fd7e14; margin: 0;">${stats.orientations.total}</h3>
                            <small>AM(${stats.orientations.byTime['9:00-12:00']}) PM(${stats.orientations.byTime['1:30-4:30']})</small>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Fingerprints</h5>
                            <h3 style="color: #dc3545; margin: 0;">${stats.fingerprints}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Badges</h5>
                            <h3 style="color: #6f42c1; margin: 0;">${stats.badges}</h3>
                        </div>
                    </div>

                    <div style="margin-top: 20px;">
                        <button class="btn" onclick="exportDailyStats('${dateStr}')">Export to Excel</button>
                    </div>
                </div>
            `;

            // Add detailed lists if there are entries
            if (stats.visits > 0 || stats.infoSessions.total > 0 || stats.orientations.total > 0 || stats.fingerprints > 0 || stats.badges > 0) {
                statisticsList.innerHTML += createDetailedStatsList(stats);
            }
        }

        // Display range statistics
        function displayRangeStatistics(stats, title, startDate, endDate) {
            const statisticsList = document.getElementById('daily-statistics-list');
            
            const startStr = startDate.toLocaleDateString();
            const endStr = endDate.toLocaleDateString();
            
            let dailyBreakdownHtml = '';
            stats.dailyBreakdown.forEach(day => {
                if (day.visits > 0 || day.infoSessions > 0 || day.orientations > 0 || day.fingerprints > 0 || day.badges > 0) {
                    const dayFormatted = new Date(day.date + 'T00:00:00').toLocaleDateString();
                    dailyBreakdownHtml += `
                        <tr>
                            <td>${dayFormatted}</td>
                            <td>${day.visits}</td>
                            <td>${day.infoSessions}</td>
                            <td>${day.orientations}</td>
                            <td>${day.fingerprints}</td>
                            <td>${day.badges}</td>
                        </tr>
                    `;
                }
            });
            
            statisticsList.innerHTML = `
                <div class="visit-card">
                    <h4>${title} (${startStr} - ${endStr})</h4>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Total Visits</h5>
                            <h3 style="color: #007bff; margin: 0;">${stats.totalVisits}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Total Info Sessions</h5>
                            <h3 style="color: #28a745; margin: 0;">${stats.totalInfoSessions}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Total Orientations</h5>
                            <h3 style="color: #fd7e14; margin: 0;">${stats.totalOrientations}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Total Fingerprints</h5>
                            <h3 style="color: #dc3545; margin: 0;">${stats.totalFingerprints}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Total Badges</h5>
                            <h3 style="color: #6f42c1; margin: 0;">${stats.totalBadges}</h3>
                        </div>
                    </div>

                    <h5>Daily Breakdown</h5>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                            <thead>
                                <tr style="background: #f8f9fa;">
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Date</th>
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Visits</th>
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Info Sessions</th>
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Orientations</th>
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Fingerprints</th>
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Badges</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${dailyBreakdownHtml || '<tr><td colspan="6" style="padding: 8px; text-align: center; color: #6c757d;">No data for this period</td></tr>'}
                            </tbody>
                        </table>
                    </div>

                    <div style="margin-top: 20px;">
                        <button class="btn" onclick="exportRangeStats('${stats.startDate}', '${stats.endDate}', '${title}')">Export to Excel</button>
                    </div>
                </div>
            `;
        }

        // Create detailed stats list
        function createDetailedStatsList(stats) {
            let detailsHtml = '<div class="visit-card" style="margin-top: 20px;"><h5>Detailed Records</h5>';
            
            // Visits details
            if (stats.visitsList.length > 0) {
                detailsHtml += '<h6>Visits (' + stats.visitsList.length + ')</h6><ul>';
                stats.visitsList.forEach(visit => {
                    detailsHtml += `<li>${visit.name} - ${visit.company || 'No company'} (${visit.purpose || 'No purpose'})</li>`;
                });
                detailsHtml += '</ul>';
            }
            
            // Info Sessions details
            if (stats.infoSessionsList.length > 0) {
                detailsHtml += '<h6>Info Sessions (' + stats.infoSessionsList.length + ')</h6><ul>';
                stats.infoSessionsList.forEach(session => {
                    detailsHtml += `<li>${session.name} - ${session.session} ${session.phone ? '(' + session.phone + ')' : ''}</li>`;
                });
                detailsHtml += '</ul>';
            }
            
            // Orientations details
            if (stats.orientationsList.length > 0) {
                detailsHtml += '<h6>New Hire Orientations (' + stats.orientationsList.length + ')</h6><ul>';
                stats.orientationsList.forEach(orientation => {
                    detailsHtml += `<li>${orientation.name} - ${orientation.session} ${orientation.phone ? '(' + orientation.phone + ')' : ''}</li>`;
                });
                detailsHtml += '</ul>';
            }
            
            // Fingerprints details
            if (stats.fingerprintsList.length > 0) {
                detailsHtml += '<h6>Fingerprints (' + stats.fingerprintsList.length + ')</h6><ul>';
                stats.fingerprintsList.forEach(fingerprint => {
                    detailsHtml += `<li>${fingerprint.name} - ${fingerprint.purpose || 'Fingerprint'}</li>`;
                });
                detailsHtml += '</ul>';
            }
            
            // Badges details
            if (stats.badgesList.length > 0) {
                detailsHtml += '<h6>Badges (' + stats.badgesList.length + ')</h6><ul>';
                stats.badgesList.forEach(badge => {
                    detailsHtml += `<li>${badge.name} - ${badge.purpose || 'Badge'}</li>`;
                });
                detailsHtml += '</ul>';
            }
            
            detailsHtml += '</div>';
            return detailsHtml;
        }

        // Export daily statistics to Excel
        async function exportDailyStats(dateStr) {
            try {
                const stats = await getDailyStatistics(dateStr);
                const formattedDate = new Date(dateStr + 'T00:00:00').toLocaleDateString().replace(/\//g, '-');
                
                const workbook = XLSX.utils.book_new();
                
                // Summary sheet
                const summaryData = [
                    ['Daily Statistics Summary', ''],
                    ['Date', formattedDate],
                    [''],
                    ['Category', 'Count'],
                    ['Visits', stats.visits],
                    ['Info Sessions Total', stats.infoSessions.total],
                    ['  - 8:30 AM', stats.infoSessions.byTime['8:30']],
                    ['  - 10:00 AM', stats.infoSessions.byTime['10:00']],
                    ['  - 1:30 PM', stats.infoSessions.byTime['1:30']],
                    ['Orientations Total', stats.orientations.total],
                    ['  - 9:00 AM - 12:00 PM', stats.orientations.byTime['9:00-12:00']],
                    ['  - 1:30 PM - 4:30 PM', stats.orientations.byTime['1:30-4:30']],
                    ['Fingerprints', stats.fingerprints],
                    ['Badges', stats.badges],
                    [''],
                    ['TOTAL', stats.visits + stats.infoSessions.total + stats.orientations.total + stats.fingerprints + stats.badges]
                ];
                
                const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
                XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
                
                // Individual sheets for each category if they have data
                if (stats.visitsList.length > 0) {
                    const visitsData = [['Name', 'Company', 'Purpose', 'Time']];
                    stats.visitsList.forEach(visit => {
                        visitsData.push([
                            visit.name || '',
                            visit.company || '',
                            visit.purpose || '',
                            visit.timestamp ? new Date(visit.timestamp).toLocaleTimeString() : ''
                        ]);
                    });
                    const visitsSheet = XLSX.utils.aoa_to_sheet(visitsData);
                    XLSX.utils.book_append_sheet(workbook, visitsSheet, 'Visits');
                }
                
                if (stats.infoSessionsList.length > 0) {
                    const infoData = [['Name', 'Phone', 'Session', 'Time']];
                    stats.infoSessionsList.forEach(session => {
                        infoData.push([
                            session.name || '',
                            session.phone || '',
                            session.session || '',
                            session.timestamp ? new Date(session.timestamp).toLocaleTimeString() : ''
                        ]);
                    });
                    const infoSheet = XLSX.utils.aoa_to_sheet(infoData);
                    XLSX.utils.book_append_sheet(workbook, infoSheet, 'Info Sessions');
                }
                
                if (stats.orientationsList.length > 0) {
                    const orientationData = [['Name', 'Phone', 'Session', 'Time']];
                    stats.orientationsList.forEach(orientation => {
                        orientationData.push([
                            orientation.name || '',
                            orientation.phone || '',
                            orientation.session || '',
                            orientation.timestamp ? new Date(orientation.timestamp).toLocaleTimeString() : ''
                        ]);
                    });
                    const orientationSheet = XLSX.utils.aoa_to_sheet(orientationData);
                    XLSX.utils.book_append_sheet(workbook, orientationSheet, 'Orientations');
                }
                
                if (stats.fingerprintsList.length > 0) {
                    const fingerprintData = [['Name', 'Purpose', 'Time']];
                    stats.fingerprintsList.forEach(fingerprint => {
                        fingerprintData.push([
                            fingerprint.name || '',
                            fingerprint.purpose || '',
                            fingerprint.timestamp ? new Date(fingerprint.timestamp).toLocaleTimeString() : ''
                        ]);
                    });
                    const fingerprintSheet = XLSX.utils.aoa_to_sheet(fingerprintData);
                    XLSX.utils.book_append_sheet(workbook, fingerprintSheet, 'Fingerprints');
                }
                
                if (stats.badgesList.length > 0) {
                    const badgeData = [['Name', 'Purpose', 'Time']];
                    stats.badgesList.forEach(badge => {
                        badgeData.push([
                            badge.name || '',
                            badge.purpose || '',
                            badge.timestamp ? new Date(badge.timestamp).toLocaleTimeString() : ''
                        ]);
                    });
                    const badgeSheet = XLSX.utils.aoa_to_sheet(badgeData);
                    XLSX.utils.book_append_sheet(workbook, badgeSheet, 'Badges');
                }
                
                XLSX.writeFile(workbook, `Daily_Stats_${formattedDate}.xlsx`);
                
            } catch (error) {
                console.error('Error exporting daily stats:', error);
                alert('Error exporting statistics. Please try again.');
            }
        }

        // Export range statistics to Excel
        async function exportRangeStats(startDate, endDate, title) {
            try {
                const start = new Date(startDate);
                const end = new Date(endDate);
                const stats = await getDateRangeStatistics(start, end);
                
                const titleFormatted = title.replace(/\s+/g, '_');
                const startFormatted = startDate.replace(/-/g, '');
                const endFormatted = endDate.replace(/-/g, '');
                
                const workbook = XLSX.utils.book_new();
                
                // Summary sheet
                const summaryData = [
                    [`${title} Statistics Summary`, ''],
                    ['Period', `${start.toLocaleDateString()} - ${end.toLocaleDateString()}`],
                    [''],
                    ['Category', 'Total Count'],
                    ['Total Visits', stats.totalVisits],
                    ['Total Info Sessions', stats.totalInfoSessions],
                    ['Total Orientations', stats.totalOrientations],
                    ['Total Fingerprints', stats.totalFingerprints],
                    ['Total Badges', stats.totalBadges],
                    [''],
                    ['GRAND TOTAL', stats.totalVisits + stats.totalInfoSessions + stats.totalOrientations + stats.totalFingerprints + stats.totalBadges]
                ];
                
                const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
                XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
                
                // Daily breakdown sheet
                const dailyData = [['Date', 'Visits', 'Info Sessions', 'Orientations', 'Fingerprints', 'Badges', 'Daily Total']];
                stats.dailyBreakdown.forEach(day => {
                    const dayFormatted = new Date(day.date + 'T00:00:00').toLocaleDateString();
                    const dailyTotal = day.visits + day.infoSessions + day.orientations + day.fingerprints + day.badges;
                    dailyData.push([dayFormatted, day.visits, day.infoSessions, day.orientations, day.fingerprints, day.badges, dailyTotal]);
                });
                
                const dailySheet = XLSX.utils.aoa_to_sheet(dailyData);
                XLSX.utils.book_append_sheet(workbook, dailySheet, 'Daily Breakdown');
                
                XLSX.writeFile(workbook, `${titleFormatted}_Stats_${startFormatted}_${endFormatted}.xlsx`);
                
            } catch (error) {
                console.error('Error exporting range stats:', error);
                alert('Error exporting statistics. Please try again.');
            }
        }

        // Store current filter state
        let currentDocumentFilter = 'all';

        // Load document completions for recruiters with real-time updates and filtering
        async function loadDocumentCompletions() {
            // Don't start listeners on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Skipping loadDocumentCompletions on document-completion page');
                return;
            }
            
            console.log('üîç DEBUG: loadDocumentCompletions called');
            console.log('üîç DEBUG: currentUser =', currentUser);
            console.log('üîç DEBUG: auth.currentUser =', auth.currentUser);
            
            if (!currentUser) {
                console.log('‚ùå Cannot load document completions: No current user');
                console.log('‚ùå DEBUG: Please login first to view document completions');
                
                // Show helpful message in the UI
                const completionsContainer = document.getElementById('document-completions-container');
                if (completionsContainer) {
                    completionsContainer.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <h3>üîí Authentication Required</h3>
                            <p>Please log in to view document completions.</p>
                            <p style="color: #999; font-size: 14px;">Current user: ${currentUser || 'null'}</p>
                        </div>
                    `;
                }
                return;
            }
            
            console.log('üìã Setting up real-time document completions for:', currentUser.email);
            
            try {
                const completionsList = document.getElementById('document-completions-list');
                completionsList.innerHTML = '<p>Loading document completions...</p>';
                
                // Remove existing listener if any
                const existingListener = realtimeListeners.find(l => l.type === 'document-completions-dashboard');
                if (existingListener) {
                    console.log('üìã Removing existing dashboard listener');
                    existingListener.unsubscribe();
                    realtimeListeners = realtimeListeners.filter(l => l.type !== 'document-completions-dashboard');
                }
                
                // Get today's ALL completions with real-time listener (no status filter)
                const today = getWorkDay();
                console.log('üìã Setting up real-time listener for ALL completions on date:', today);
                
                const unsubscribe = db.collection('document-queue')
                    .where('date', '==', today)
                    .onSnapshot(snapshot => {
                        console.log('üìã Real-time update: Found', snapshot.size, 'total completions');
                        
                        // Store all data for filtering
                        window.allDocumentCompletions = [];
                        let myAssignedCount = 0;
                        
                        if (snapshot.empty) {
                            console.log('üìã No completions found for today');
                            window.allDocumentCompletions = [];
                        } else {
                            // Convert to array and store globally for filtering
                            snapshot.forEach(doc => {
                                const completion = doc.data();
                                window.allDocumentCompletions.push({
                                    id: doc.id,
                                    data: completion
                                });
                                
                                // Count my assignments (only pending ones for indicator)
                                if (completion.recruiterEmail === currentUser.email && completion.status === 'pending-recruiter-contact') {
                                    myAssignedCount++;
                                }
                            });
                            
                            // Sort by timestamp (newest first)
                            window.allDocumentCompletions.sort((a, b) => {
                                const timeA = a.data.timestamp ? new Date(a.data.timestamp) : new Date(a.data.completedAt);
                                const timeB = b.data.timestamp ? new Date(b.data.timestamp) : new Date(b.data.completedAt);
                                return timeB - timeA;
                            });
                        }
                        
                        console.log('üìã Real-time summary - Total completions:', window.allDocumentCompletions.length, ', My pending assignments:', myAssignedCount);
                        
                        // Update indicator with user's pending assigned count
                        updateCompletionsIndicator(myAssignedCount);
                        
                        // Apply current filter to display
                        filterDocumentCompletions(currentDocumentFilter);
                        
                        // Show notification for new completions
                        snapshot.docChanges().forEach(change => {
                            if (change.type === 'added') {
                                const completion = change.doc.data();
                                if (completion.recruiterEmail === currentUser.email) {
                                    // Check if this is a new completion (less than 10 seconds old)
                                    if (completion.timestamp) {
                                        const completionTime = new Date(completion.timestamp);
                                        const now = new Date();
                                        const diffInSeconds = (now - completionTime) / 1000;
                                        
                                        if (diffInSeconds < 10) {
                                            console.log('üéâ NEW completion assigned to me!');
                                            playSuccessSound();
                                            showSuccessMessage(`üéâ NEW: ${completion.name} (Queue #${completion.queueNumber}) assigned to you!`);
                                        }
                                    }
                                }
                            }
                        });
                    }, error => {
                        console.error('‚ùå Error in real-time document completions:', error);
                        completionsList.innerHTML = '<p>Error loading completions. Please refresh.</p>';
                    });
                
                // Store the listener
                realtimeListeners.push({
                    type: 'document-completions-dashboard',
                    unsubscribe: unsubscribe
                });
                
                console.log('üìã Real-time document completions listener set up successfully');
                
            } catch (error) {
                console.error('‚ùå Error setting up real-time document completions:', error);
                document.getElementById('document-completions-list').innerHTML = '<p>Error loading completions. Please refresh.</p>';
            }
        }

        // Filter document completions by status
        function filterDocumentCompletions(status) {
            console.log('üìã Filtering document completions by status:', status);
            currentDocumentFilter = status;
            
            const completionsList = document.getElementById('document-completions-list');
            if (!window.allDocumentCompletions) {
                completionsList.innerHTML = '<p>Loading document completions...</p>';
                return;
            }
            
            // Update filter button styles
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.style.background = 'transparent';
                btn.style.color = '#666';
            });
            
            const activeButton = document.getElementById(`filter-${status}`);
            if (activeButton) {
                activeButton.style.background = '#007bff';
                activeButton.style.color = 'white';
            }
            
            // Filter completions based on status
            let filteredCompletions = [];
            
            if (status === 'all') {
                filteredCompletions = window.allDocumentCompletions;
            } else if (status === 'pending') {
                filteredCompletions = window.allDocumentCompletions.filter(item => 
                    item.data.status === 'pending-recruiter-contact'
                );
            } else if (status === 'contacted') {
                filteredCompletions = window.allDocumentCompletions.filter(item => 
                    item.data.status === 'contacted'
                );
            } else if (status === 'attended') {
                filteredCompletions = window.allDocumentCompletions.filter(item => 
                    item.data.status === 'attended'
                );
            }
            
            // Clear and populate the list
            completionsList.innerHTML = '';
            
            if (filteredCompletions.length === 0) {
                const statusText = status === 'all' ? 'completions' : `${status} completions`;
                completionsList.innerHTML = `<p>No ${statusText} found for today.</p>`;
                return;
            }
            
            console.log(`üìã Displaying ${filteredCompletions.length} ${status} completions`);
            
            let previousTimestamp = null;
            
            filteredCompletions.forEach((item, index) => {
                const completion = item.data;
                const completionId = item.id;
                
                // Check if we need to add a daily divider
                const currentTimestamp = completion.timestamp || new Date(completion.completedAt);
                if (index > 0 && previousTimestamp && shouldShowDailyDivider(currentTimestamp, previousTimestamp)) {
                    const divider = createDailyDivider(currentTimestamp);
                    completionsList.appendChild(divider);
                }
                
                // Check if this completion is assigned to current user
                const isMyAssignment = completion.recruiterEmail === currentUser.email;
                
                const completionCard = createDocumentCompletionCard(completion, completionId, isMyAssignment);
                completionsList.appendChild(completionCard);
                
                previousTimestamp = currentTimestamp;
            });
        }

        // Create document completion card
        function createDocumentCompletionCard(completion, completionId, isMyAssignment) {
            const card = document.createElement('div');
            card.className = 'visit-card';
            
            // Highlight cards based on status and assignment
            if (completion.status === 'attended') {
                // Green background for attended
                card.style.background = '#d4f6d4';
                card.style.border = '2px solid #28a745';
            } else if (isMyAssignment) {
                // Light blue background for assigned to current user
                card.style.border = '2px solid #007bff';
                card.style.background = '#e3f2fd';
            }
            
            const safeName = completion.name.replace(/'/g, "\\'");
            
            card.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px;">
                    <div>
                        <h4 style="margin: 0; color: ${completion.status === 'attended' ? '#28a745' : isMyAssignment ? '#007bff' : '#333'}; font-size: 18px;">
                            ${completion.status === 'attended' ? '‚úÖ ' : isMyAssignment ? 'üë§ ' : ''}${completion.name}
                        </h4>
                        <p style="margin: 5px 0 0 0; color: ${completion.status === 'attended' ? '#28a745' : '#666'}; font-size: 16px; font-weight: bold;">
                            Queue #${completion.queueNumber}${completion.status === 'attended' ? ' - ATTENDED' : ''}
                        </p>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        ${completion.status !== 'attended' ? `
                            <button class="btn btn-success" onclick="markAsAttended('${completionId}', '${safeName}', ${completion.queueNumber})" style="font-size: 14px; padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px;">
                                ‚úÖ Mark Attended
                            </button>
                        ` : `
                            <span style="background: #28a745; color: white; padding: 10px 20px; border-radius: 6px; font-size: 14px; font-weight: bold;">
                                ‚úÖ Attended
                            </span>
                        `}
                        <button class="btn btn-danger" onclick="deleteCompletion('${completionId}', '${safeName}')" style="font-size: 14px; padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 6px;">
                            üóëÔ∏è Delete
                        </button>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        // Get status information for completion card
        function getStatusInfo(completion) {
            const status = completion.status;
            
            if (status === 'contacted') {
                const contactedTime = completion.contactedAt ? completion.contactedAt.toDate().toLocaleString() : 'Unknown';
                const contactedBy = completion.contactedBy || 'Unknown';
                return `<p style="margin: 5px 0 0 0; font-size: 12px; color: #28a745;">
                    <strong>üìû Contacted:</strong> ${contactedTime} by ${contactedBy}
                </p>`;
            } else if (status === 'attended') {
                const attendedTime = completion.attendedAt ? completion.attendedAt.toDate().toLocaleString() : 'Unknown';
                const attendedBy = completion.attendedBy || 'Unknown';
                return `<p style="margin: 5px 0 0 0; font-size: 12px; color: #007bff;">
                    <strong>‚úÖ Attended:</strong> ${attendedTime} by ${attendedBy}
                </p>`;
            }
            
            return '';
        }
        
        // Get action buttons based on completion status
        function getActionButtons(completion, completionId) {
            const status = completion.status;
            
            if (status === 'pending-recruiter-contact') {
                return `
                    <button class="btn btn-success" onclick="markAsContacted('${completionId}')" style="font-size: 12px; padding: 6px 12px;">
                        üìû Mark as Contacted
                    </button>`;
            } else if (status === 'contacted') {
                return `
                    <button class="btn btn-primary" onclick="markAsAttended('${completionId}', '${completion.name}', ${completion.queueNumber})" style="font-size: 12px; padding: 6px 12px;">
                        ‚úÖ Mark as Attended
                    </button>
                    <button class="btn btn-secondary" onclick="markAsPending('${completionId}')" style="font-size: 10px; padding: 4px 8px;">
                        ‚è™ Back to Pending
                    </button>`;
            } else if (status === 'attended') {
                return `
                    <button class="btn btn-secondary" onclick="markAsContacted('${completionId}')" style="font-size: 10px; padding: 4px 8px;">
                        ‚è™ Back to Contacted
                    </button>
                    <span style="color: #28a745; font-size: 12px; font-weight: bold;">‚úÖ Complete</span>`;
            }
            
            return '';
        }

        // Mark completion as contacted
        async function markAsContacted(completionId) {
            try {
                // Get completion data to check if this was assigned to current user
                const completionDoc = await db.collection('document-queue').doc(completionId).get();
                const completionData = completionDoc.data();
                
                // Update completion status
                await db.collection('document-queue').doc(completionId).update({
                    status: 'contacted',
                    contactedBy: currentUser.email,
                    contactedAt: new Date().toISOString()
                });
                
                // If this was assigned to current user, mark them as free
                if (completionData.recruiterEmail === currentUser.email) {
                    const today = new Date().toISOString().split('T')[0];
                    const availabilitySnapshot = await db.collection('recruiter-availability')
                        .where('recruiterEmail', '==', currentUser.email)
                        .where('date', '==', today)
                        .get();
                    
                    if (!availabilitySnapshot.empty) {
                        const docId = availabilitySnapshot.docs[0].id;
                        const currentData = availabilitySnapshot.docs[0].data();
                        
                        await db.collection('recruiter-availability').doc(docId).update({
                            isFree: true,
                            currentAssignment: null,
                            completedAssignments: (currentData.completedAssignments || 0) + 1,
                            lastFreed: new Date().toISOString()
                        });
                    }
                }
                
                showSuccessMessage('Marked as contacted successfully! You are now available for next assignment.');
                loadDocumentCompletions(); // Refresh list
                
            } catch (error) {
                console.error('Error marking as contacted:', error);
                showErrorMessage('Error updating status. Please try again.');
            }
        }

        // Update completions indicator
        function updateCompletionsIndicator(count) {
            const indicator = document.getElementById('completions-indicator');
            const button = document.getElementById('document-completions-btn');
            
            console.log('üî¥ Updating completions indicator with count:', count);
            
            if (count > 0) {
                indicator.textContent = count;
                indicator.style.display = 'block';
                indicator.style.background = '#dc3545'; // Red for attention
                button.style.fontWeight = 'bold';
                button.style.color = '#dc3545';
                console.log('‚úÖ Indicator now showing:', count, 'completions (RED ALERT)');
                
                // Add pulsing animation for new completions
                indicator.classList.add('pulse-animation');
            } else {
                indicator.style.display = 'none';
                button.style.fontWeight = 'normal';
                button.style.color = '';
                console.log('üö© Indicator hidden (no completions)');
                
                indicator.classList.remove('pulse-animation');
            }
        }

        // Setup real-time listener for document completions (Enhanced for all views)
        function setupDocumentCompletionsListener() {
            if (!currentUser) {
                console.log('‚ùå Cannot setup document completions listener: No current user');
                return;
            }
            
            console.log('üîî Setting up ENHANCED document completions listener for:', currentUser.email);
            
            // Remove existing listener if any
            const existingListener = realtimeListeners.find(l => l.type === 'document-completions');
            if (existingListener) {
                console.log('üîî Removing existing document completions listener');
                existingListener.unsubscribe();
                const index = realtimeListeners.indexOf(existingListener);
                realtimeListeners.splice(index, 1);
            }
            
            try {
                const today = getWorkDay();
                console.log('üîî Listening for ALL document completions on date:', today);
                
                // Listen to ALL document completions for today (not just pending)
                const unsubscribe = db.collection('document-queue')
                    .where('date', '==', today)
                    .onSnapshot(snapshot => {
                        console.log('üîî Real-time update: Document completions snapshot received, total size:', snapshot.size);
                        
                        let myAssignedCount = 0;
                        let totalPendingCount = 0;
                        let totalContactedCount = 0;
                        let totalAttendedCount = 0;
                        let hasNewCompletions = false;
                        
                        snapshot.forEach(doc => {
                            const completion = doc.data();
                            
                            // Count by status
                            if (completion.status === 'pending-recruiter-contact') {
                                totalPendingCount++;
                                if (completion.recruiterEmail === currentUser.email) {
                                    myAssignedCount++;
                                    
                                    // Check if this is a new completion (less than 60 seconds old)
                                    if (completion.timestamp) {
                                        const completionTime = new Date(completion.timestamp);
                                        const now = new Date();
                                        const diffInSeconds = (now - completionTime) / 1000;
                                        
                                        if (diffInSeconds < 60) {
                                            hasNewCompletions = true;
                                            console.log('üÜï NEW completion detected:', completion.name);
                                        }
                                    }
                                }
                            } else if (completion.status === 'contacted') {
                                totalContactedCount++;
                            } else if (completion.status === 'attended') {
                                totalAttendedCount++;
                            }
                        });
                        
                        console.log('üîî Real-time counts:', {
                            myAssigned: myAssignedCount,
                            totalPending: totalPendingCount,
                            totalContacted: totalContactedCount,
                            totalAttended: totalAttendedCount,
                            totalAll: snapshot.size,
                            hasNew: hasNewCompletions
                        });
                        
                        // Update indicator in navbar
                        updateCompletionsIndicator(myAssignedCount);
                        
                        // Play notification sound if there are new completions assigned to this user
                        if (hasNewCompletions && myAssignedCount > 0) {
                            console.log('üîî Playing notification sound and showing message!');
                            playSuccessSound();
                            showSuccessMessage(`üîî New document completion assigned to you! Queue has ${myAssignedCount} pending.`);
                        }
                        
                        // Auto-refresh ALL document completion views that are currently visible
                        console.log('üîî Checking which views need real-time updates...');
                        
                        // 1. Main Document Queue view
                        const completionsSection = document.getElementById('document-completions');
                        if (completionsSection && completionsSection.style.display !== 'none') {
                            console.log('üîÑ Auto-refreshing main Document Queue view');
                            loadDocumentCompletions();
                        }
                        
                        // 2. Status view (My Status section)
                        const statusSection = document.getElementById('recruiter-status');
                        if (statusSection && statusSection.style.display !== 'none') {
                            console.log('üîÑ Auto-refreshing My Status document completions');
                            loadStatusDocumentCompletions();
                        }
                        
                        // 3. Simple completions view (if exists and visible)
                        const simpleSection = document.getElementById('simple-document-completions');
                        if (simpleSection && simpleSection.style.display !== 'none') {
                            console.log('üîÑ Auto-refreshing simple document completions');
                            // Trigger a re-filter to refresh the data
                            if (typeof filterCompletions === 'function') {
                                filterCompletions(currentCompletionsFilter || 'all');
                            }
                        }
                        
                        // 4. Update all status indicators
                        const statusIndicator = document.getElementById('status-completions-indicator');
                        if (statusIndicator) {
                            if (myAssignedCount > 0) {
                                statusIndicator.textContent = myAssignedCount;
                                statusIndicator.style.display = 'inline-block';
                                console.log('‚úÖ Status indicator updated:', myAssignedCount);
                            } else {
                                statusIndicator.style.display = 'none';
                            }
                        }
                        
                        // 5. Update queue management if visible
                        const queueSection = document.getElementById('queue-management');
                        if (queueSection && queueSection.style.display !== 'none') {
                            console.log('üîÑ Auto-refreshing queue management');
                            loadQueueManagement();
                        }
                        
                    }, error => {
                        console.error('‚ùå Error in enhanced document completions listener:', error);
                    });
                
                // Store listener
                realtimeListeners.push({
                    type: 'document-completions',
                    unsubscribe: unsubscribe
                });
                
                console.log('‚úÖ Enhanced document completions listener setup complete');
                
            } catch (error) {
                console.error('‚ùå Error setting up enhanced document completions listener:', error);
            }
        }

        // Load recruiter status
        async function loadRecruiterStatus() {
            if (!currentUser) return;
            
            try {
                const today = new Date().toISOString().split('T')[0];
                
                // Get current recruiter's availability record for today
                const availabilitySnapshot = await db.collection('recruiter-availability')
                    .where('recruiterEmail', '==', currentUser.email)
                    .where('date', '==', today)
                    .get();
                
                let availabilityDoc = null;
                if (!availabilitySnapshot.empty) {
                    availabilityDoc = availabilitySnapshot.docs[0];
                }
                
                // Update UI based on current status
                if (availabilityDoc) {
                    const data = availabilityDoc.data();
                    document.getElementById('present-today-toggle').checked = data.isPresent || false;
                    
                    if (data.isPresent) {
                        document.getElementById('availability-controls').style.display = 'block';
                        document.getElementById('present-status-text').textContent = '‚úÖ Present Today';
                        updateCurrentStatusDisplay(data.isFree, data.currentAssignment);
                    } else {
                        document.getElementById('availability-controls').style.display = 'none';
                        document.getElementById('present-status-text').textContent = 'üè† Present Today';
                    }
                } else {
                    // No record for today, create one
                    document.getElementById('present-today-toggle').checked = false;
                    document.getElementById('availability-controls').style.display = 'none';
                    document.getElementById('present-status-text').textContent = 'üè† Present Today';
                }
                
                // Load today's stats
                await loadRecruiterStats();
                
                // Load document completions for this recruiter
                console.log('üìã About to call loadDocumentCompletionsForStatus()...');
                await loadDocumentCompletionsForStatus();
                console.log('üìã loadDocumentCompletionsForStatus() completed');
                
            } catch (error) {
                console.error('Error loading recruiter status:', error);
            }
        }

        // Update present status
        async function updatePresentStatus() {
            if (!currentUser) return;
            
            try {
                const today = new Date().toISOString().split('T')[0];
                const isPresent = document.getElementById('present-today-toggle').checked;
                
                // Get staff info
                const staffSnapshot = await db.collection('staff')
                    .where('email', '==', currentUser.email)
                    .get();
                
                if (staffSnapshot.empty) return;
                
                const staffData = staffSnapshot.docs[0].data();
                const staffId = staffSnapshot.docs[0].id;
                
                const availabilityData = {
                    recruiterEmail: currentUser.email,
                    recruiterName: staffData.name,
                    staffId: staffId,
                    team: staffData.team,
                    date: today,
                    isPresent: isPresent,
                    isFree: isPresent, // If checking in, start as free
                    currentAssignment: isPresent ? null : 'not-present',
                    checkedInAt: isPresent ? new Date().toISOString() : null,
                    checkedOutAt: !isPresent ? new Date().toISOString() : null,
                    completedAssignments: 0
                };
                
                // Check if record exists for today
                const existingSnapshot = await db.collection('recruiter-availability')
                    .where('recruiterEmail', '==', currentUser.email)
                    .where('date', '==', today)
                    .get();
                
                if (existingSnapshot.empty) {
                    // Create new record
                    await db.collection('recruiter-availability').add(availabilityData);
                } else {
                    // Update existing record
                    const docId = existingSnapshot.docs[0].id;
                    await db.collection('recruiter-availability').doc(docId).update({
                        isPresent: isPresent,
                        isFree: isPresent,
                        currentAssignment: isPresent ? null : 'not-present',
                        checkedInAt: isPresent ? new Date().toISOString() : null,
                        checkedOutAt: !isPresent ? new Date().toISOString() : null
                    });
                }
                
                // Update UI
                if (isPresent) {
                    document.getElementById('availability-controls').style.display = 'block';
                    document.getElementById('present-status-text').textContent = '‚úÖ Present Today';
                    updateCurrentStatusDisplay(true, null);
                    showSuccessMessage('Checked in successfully! You are now available for assignments.');
                } else {
                    document.getElementById('availability-controls').style.display = 'none';
                    document.getElementById('present-status-text').textContent = 'üè† Present Today';
                    showSuccessMessage('Checked out successfully.');
                }
                
                await loadRecruiterStats();
                
            } catch (error) {
                console.error('Error updating present status:', error);
                showErrorMessage('Error updating status. Please try again.');
            }
        }

        // Mark recruiter as free
        async function markAsFree() {
            if (!currentUser) return;
            
            try {
                const today = new Date().toISOString().split('T')[0];
                
                // Update availability status
                const availabilitySnapshot = await db.collection('recruiter-availability')
                    .where('recruiterEmail', '==', currentUser.email)
                    .where('date', '==', today)
                    .get();
                
                if (!availabilitySnapshot.empty) {
                    const docId = availabilitySnapshot.docs[0].id;
                    const currentData = availabilitySnapshot.docs[0].data();
                    
                    await db.collection('recruiter-availability').doc(docId).update({
                        isFree: true,
                        currentAssignment: null,
                        completedAssignments: (currentData.completedAssignments || 0) + 1,
                        lastFreed: new Date().toISOString()
                    });
                    
                    updateCurrentStatusDisplay(true, null);
                    showSuccessMessage('Marked as free! Ready for next assignment.');
                    
                    await loadRecruiterStats();
                }
                
            } catch (error) {
                console.error('Error marking as free:', error);
                showErrorMessage('Error updating status. Please try again.');
            }
        }

        // Update current status display
        function updateCurrentStatusDisplay(isFree, currentAssignment) {
            const statusDisplay = document.getElementById('current-status-display');
            const freeButton = document.getElementById('mark-free-btn');
            
            if (isFree) {
                statusDisplay.textContent = 'üü¢ Available';
                statusDisplay.style.color = '#28a745';
                freeButton.style.display = 'none';
            } else {
                statusDisplay.textContent = 'üî¥ Busy';
                statusDisplay.style.color = '#dc3545';
                freeButton.style.display = 'inline-block';
            }
            
            // Update current assignment info
            const assignmentInfo = document.getElementById('current-assignment-info');
            if (currentAssignment && currentAssignment !== 'not-present') {
                assignmentInfo.textContent = currentAssignment;
            } else {
                assignmentInfo.textContent = 'None';
            }
        }

        // Load recruiter stats for today
        async function loadRecruiterStats() {
            if (!currentUser) return;
            
            try {
                const today = new Date().toISOString().split('T')[0];
                
                // Get completed assignments count
                const completedCount = await db.collection('document-queue')
                    .where('date', '==', today)
                    .where('recruiterEmail', '==', currentUser.email)
                    .where('status', '==', 'contacted')
                    .get();
                
                document.getElementById('completed-assignments').textContent = completedCount.size;
                
            } catch (error) {
                console.error('Error loading recruiter stats:', error);
            }
        }

        // Staff statistics functions
        function loadStaffTodayStatistics() {
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            document.getElementById('staff-stats-date').value = todayStr;
            loadStaffDailyStatistics();
        }

        function loadStaffWeeklyStatistics() {
            const today = new Date();
            const oneWeekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
            loadStaffDateRangeStatistics(oneWeekAgo, today, 'This Week');
        }

        function loadStaffMonthlyStatistics() {
            const today = new Date();
            const firstOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
            loadStaffDateRangeStatistics(firstOfMonth, today, 'This Month');
        }

        async function loadStaffDailyStatistics() {
            if (!currentUser) return;
            
            const selectedDate = document.getElementById('staff-stats-date').value;
            if (!selectedDate) return;
            
            const statisticsList = document.getElementById('staff-daily-statistics-list');
            statisticsList.innerHTML = '<p>Loading statistics...</p>';
            
            try {
                const stats = await getDailyStatistics(selectedDate);
                displayStaffDailyStatistics(stats, selectedDate);
            } catch (error) {
                console.error('Error loading staff daily statistics:', error);
                statisticsList.innerHTML = '<p>Error loading statistics.</p>';
            }
        }

        async function loadStaffDateRangeStatistics(startDate, endDate, title) {
            if (!currentUser) return;
            
            const statisticsList = document.getElementById('staff-daily-statistics-list');
            statisticsList.innerHTML = '<p>Loading statistics...</p>';
            
            try {
                const stats = await getDateRangeStatistics(startDate, endDate);
                displayStaffRangeStatistics(stats, title, startDate, endDate);
            } catch (error) {
                console.error('Error loading staff range statistics:', error);
                statisticsList.innerHTML = '<p>Error loading statistics.</p>';
            }
        }

        function displayStaffDailyStatistics(stats, dateStr) {
            const statisticsList = document.getElementById('staff-daily-statistics-list');
            
            const formattedDate = new Date(dateStr + 'T00:00:00').toLocaleDateString();
            
            statisticsList.innerHTML = `
                <div class="visit-card">
                    <h4>Statistics for ${formattedDate}</h4>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Visits</h5>
                            <h3 style="color: #007bff; margin: 0;">${stats.visits}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Info Sessions</h5>
                            <h3 style="color: #28a745; margin: 0;">${stats.infoSessions.total}</h3>
                            <small>8:30(${stats.infoSessions.byTime['8:30']}) 10:00(${stats.infoSessions.byTime['10:00']}) 1:30(${stats.infoSessions.byTime['1:30']})</small>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Orientations</h5>
                            <h3 style="color: #fd7e14; margin: 0;">${stats.orientations.total}</h3>
                            <small>AM(${stats.orientations.byTime['9:00-12:00']}) PM(${stats.orientations.byTime['1:30-4:30']})</small>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Fingerprints</h5>
                            <h3 style="color: #dc3545; margin: 0;">${stats.fingerprints}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Badges</h5>
                            <h3 style="color: #6f42c1; margin: 0;">${stats.badges}</h3>
                        </div>
                    </div>

                    <div style="margin-top: 20px;">
                        <button class="btn" onclick="exportDailyStats('${dateStr}')">Export to Excel</button>
                    </div>
                </div>
            `;

            // Add detailed lists if there are entries
            if (stats.visits > 0 || stats.infoSessions.total > 0 || stats.orientations.total > 0 || stats.fingerprints > 0 || stats.badges > 0) {
                statisticsList.innerHTML += createDetailedStatsList(stats);
            }
        }

        function displayStaffRangeStatistics(stats, title, startDate, endDate) {
            const statisticsList = document.getElementById('staff-daily-statistics-list');
            
            const startStr = startDate.toLocaleDateString();
            const endStr = endDate.toLocaleDateString();
            
            let dailyBreakdownHtml = '';
            stats.dailyBreakdown.forEach(day => {
                if (day.visits > 0 || day.infoSessions > 0 || day.orientations > 0 || day.fingerprints > 0 || day.badges > 0) {
                    const dayFormatted = new Date(day.date + 'T00:00:00').toLocaleDateString();
                    dailyBreakdownHtml += `
                        <tr>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${dayFormatted}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${day.visits}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${day.infoSessions}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${day.orientations}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${day.fingerprints}</td>
                            <td style="padding: 8px; border: 1px solid #dee2e6;">${day.badges}</td>
                        </tr>
                    `;
                }
            });
            
            statisticsList.innerHTML = `
                <div class="visit-card">
                    <h4>${title} (${startStr} - ${endStr})</h4>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Total Visits</h5>
                            <h3 style="color: #007bff; margin: 0;">${stats.totalVisits}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Total Info Sessions</h5>
                            <h3 style="color: #28a745; margin: 0;">${stats.totalInfoSessions}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Total Orientations</h5>
                            <h3 style="color: #fd7e14; margin: 0;">${stats.totalOrientations}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Total Fingerprints</h5>
                            <h3 style="color: #dc3545; margin: 0;">${stats.totalFingerprints}</h3>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                            <h5 style="color: #495057; margin: 0 0 5px 0;">Total Badges</h5>
                            <h3 style="color: #6f42c1; margin: 0;">${stats.totalBadges}</h3>
                        </div>
                    </div>

                    <h5>Daily Breakdown</h5>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                            <thead>
                                <tr style="background: #f8f9fa;">
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Date</th>
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Visits</th>
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Info Sessions</th>
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Orientations</th>
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Fingerprints</th>
                                    <th style="padding: 8px; border: 1px solid #dee2e6;">Badges</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${dailyBreakdownHtml || '<tr><td colspan="6" style="padding: 8px; text-align: center; color: #6c757d;">No data for this period</td></tr>'}
                            </tbody>
                        </table>
                    </div>

                    <div style="margin-top: 20px;">
                        <button class="btn" onclick="exportRangeStats('${stats.startDate}', '${stats.endDate}', '${title}')">Export to Excel</button>
                    </div>
                </div>
            `;
        }

        // Get booking counts from all collections
        async function getBookingCounts() {
            const counts = {
                infoSessions: {},
                infoSessionsByTime: {
                    '8:30': {},
                    '10:00': {},
                    '1:30': {}
                },
                newHireOrientations: {},
                orientationsByTime: {
                    '9:00-12:00': {},
                    '1:30-4:30': {}
                },
                teamVisits: {},
                fingerprints: {},
                badges: {}
            };
            
            try {
                // Get info sessions counts
                const infoSessionsSnapshot = await db.collection('info-sessions').get();
                infoSessionsSnapshot.forEach(doc => {
                    const session = doc.data();
                    const key = `${session.date} - ${session.time}`;
                    counts.infoSessions[key] = (counts.infoSessions[key] || 0) + 1;
                    
                    // Count by time slot
                    if (counts.infoSessionsByTime[session.time]) {
                        counts.infoSessionsByTime[session.time][session.date] = (counts.infoSessionsByTime[session.time][session.date] || 0) + 1;
                    }
                });
                
                // Get new hire orientations counts
                const orientationsSnapshot = await db.collection('new-hire-orientations').get();
                orientationsSnapshot.forEach(doc => {
                    const orientation = doc.data();
                    const key = `${orientation.date} - ${orientation.timeSlot}`;
                    counts.newHireOrientations[key] = (counts.newHireOrientations[key] || 0) + 1;
                    
                    // Count by time slot
                    if (counts.orientationsByTime[orientation.timeSlot]) {
                        counts.orientationsByTime[orientation.timeSlot][orientation.date] = (counts.orientationsByTime[orientation.timeSlot][orientation.date] || 0) + 1;
                    }
                });
                
                // Get team visits counts by date
                const visitsSnapshot = await db.collection('visits').get();
                visitsSnapshot.forEach(doc => {
                    const visit = doc.data();
                    if (visit.timestamp) {
                        const date = new Date(visit.timestamp).toLocaleDateString();
                        const key = `${date} - Team Visits`;
                        counts.teamVisits[key] = (counts.teamVisits[key] || 0) + 1;
                    }
                });
                
                // Get fingerprints counts by date and time
                const fingerprintsSnapshot = await db.collection('fingerprints').get();
                fingerprintsSnapshot.forEach(doc => {
                    const fingerprint = doc.data();
                    const key = `${fingerprint.date} - ${fingerprint.time} (${fingerprint.fingerprintType})`;
                    counts.fingerprints[key] = (counts.fingerprints[key] || 0) + 1;
                });
                
                // Get badges counts by date and time
                const badgesSnapshot = await db.collection('badges').get();
                badgesSnapshot.forEach(doc => {
                    const badge = doc.data();
                    const key = `${badge.date} - ${badge.timeSlot}`;
                    counts.badges[key] = (counts.badges[key] || 0) + 1;
                });
                
            } catch (error) {
                console.error('Error getting booking counts:', error);
            }
            
            return counts;
        }

        // Create booking counts card
        function createBookingCountsCard(counts, isAdmin = false) {
            const card = document.createElement('div');
            card.className = 'visit-card';
            
            let infoSessionsHTML = '';
            let orientationsHTML = '';
            let teamVisitsHTML = '';
            let fingerprintsHTML = '';
            let badgesHTML = '';
            let summaryHTML = '';
            
            // Calculate totals for summary
            const totalInfoSessions = Object.values(counts.infoSessions).reduce((sum, count) => sum + count, 0);
            const totalOrientations = Object.values(counts.newHireOrientations).reduce((sum, count) => sum + count, 0);
            const totalTeamVisits = Object.values(counts.teamVisits).reduce((sum, count) => sum + count, 0);
            const totalFingerprints = Object.values(counts.fingerprints).reduce((sum, count) => sum + count, 0);
            const totalBadges = Object.values(counts.badges).reduce((sum, count) => sum + count, 0);
            const grandTotal = totalInfoSessions + totalOrientations + totalTeamVisits + totalFingerprints + totalBadges;
            
            // Summary section
            if (grandTotal > 0) {
                summaryHTML = `
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4 style="margin-bottom: 10px; color: #4CAF50;">üìä Total Summary</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(105px, 1fr)); gap: 8px;">
                            <div style="text-align: center;">
                                <div style="font-size: 18px; font-weight: bold; color: #4CAF50;">${totalInfoSessions}</div>
                                <div style="font-size: 10px; color: #666;">Info Sessions</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 18px; font-weight: bold; color: #9C27B0;">${totalOrientations}</div>
                                <div style="font-size: 10px; color: #666;">Orientations</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 18px; font-weight: bold; color: #2196F3;">${totalTeamVisits}</div>
                                <div style="font-size: 10px; color: #666;">Team Visits</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 18px; font-weight: bold; color: #ff9800;">${totalFingerprints}</div>
                                <div style="font-size: 10px; color: #666;">Fingerprints</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 18px; font-weight: bold; color: #795548;">${totalBadges}</div>
                                <div style="font-size: 10px; color: #666;">Badges</div>
                            </div>
                            <div style="text-align: center; border-left: 2px solid #ddd; padding-left: 8px;">
                                <div style="font-size: 20px; font-weight: bold; color: #333;">${grandTotal}</div>
                                <div style="font-size: 10px; color: #666;">TOTAL</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Info Sessions - General and by Time
            if (Object.keys(counts.infoSessions).length > 0) {
                infoSessionsHTML = `
                    <h4 style="color: #4CAF50;">üìã Info Sessions Detail</h4>
                    <div style="margin-bottom: 15px;">
                        <h5 style="color: #4CAF50; margin-bottom: 10px;">üìä Total: ${totalInfoSessions} registrations</h5>
                    </div>
                    
                    <div style="background: #f1f8e9; padding: 10px; border-radius: 6px; margin-bottom: 15px;">
                        <h5 style="color: #4CAF50; margin-bottom: 8px;">‚è∞ By Time Slots</h5>
                `;
                
                // Desglose por horarios
                const timeSlots = [
                    { key: '8:30', name: '8:30 AM' },
                    { key: '10:00', name: '10:00 AM' },
                    { key: '1:30', name: '1:30 PM' }
                ];
                
                timeSlots.forEach(slot => {
                    const slotData = counts.infoSessionsByTime[slot.key];
                    const slotTotal = Object.values(slotData).reduce((sum, count) => sum + count, 0);
                    
                    if (slotTotal > 0) {
                        infoSessionsHTML += `
                            <div style="margin-bottom: 8px;">
                                <strong>${slot.name}:</strong> <span style="color: #4CAF50; font-weight: bold;">${slotTotal} people</span>
                        `;
                        
                        // Mostrar detalles por fecha para este horario
                        const sortedDates = Object.entries(slotData).sort(([a], [b]) => new Date(a) - new Date(b));
                        if (sortedDates.length > 0) {
                            infoSessionsHTML += '<ul style="margin: 5px 0 0 20px; color: #666;">';
                            sortedDates.forEach(([date, count]) => {
                                infoSessionsHTML += `<li>${date}: ${count}</li>`;
                            });
                            infoSessionsHTML += '</ul>';
                        }
                        infoSessionsHTML += '</div>';
                    }
                });
                
                infoSessionsHTML += `
                    </div>
                    
                    <div style="background: #fff; border: 1px solid #e8f5e8; padding: 10px; border-radius: 6px;">
                        <h5 style="color: #4CAF50; margin-bottom: 8px;">üìÖ All Sessions by Date</h5>
                `;
                
                Object.entries(counts.infoSessions)
                    .sort(([a], [b]) => new Date(a.split(' - ')[0]) - new Date(b.split(' - ')[0]))
                    .forEach(([session, count]) => {
                        infoSessionsHTML += `<p style="margin: 3px 0;"><strong>${session}:</strong> <span style="color: #4CAF50; font-weight: bold;">${count}</span></p>`;
                    });
                    
                infoSessionsHTML += '</div>';
            }
            
            // New Hire Orientations - General and by Time
            if (Object.keys(counts.newHireOrientations).length > 0) {
                orientationsHTML = `
                    <h4 style="color: #9C27B0;">üéØ New Hire Orientations Detail</h4>
                    <div style="margin-bottom: 15px;">
                        <h5 style="color: #9C27B0; margin-bottom: 10px;">üìä Total: ${totalOrientations} registrations</h5>
                    </div>
                    
                    <div style="background: #f3e5f5; padding: 10px; border-radius: 6px; margin-bottom: 15px;">
                        <h5 style="color: #9C27B0; margin-bottom: 8px;">‚è∞ By Time Slots</h5>
                `;
                
                // Desglose por horarios para orientaciones
                const orientationSlots = [
                    { key: '9:00-12:00', name: '9:00 AM - 12:00 PM' },
                    { key: '1:30-4:30', name: '1:30 PM - 4:30 PM' }
                ];
                
                orientationSlots.forEach(slot => {
                    const slotData = counts.orientationsByTime[slot.key];
                    const slotTotal = Object.values(slotData).reduce((sum, count) => sum + count, 0);
                    
                    if (slotTotal > 0) {
                        orientationsHTML += `
                            <div style="margin-bottom: 8px;">
                                <strong>${slot.name}:</strong> <span style="color: #9C27B0; font-weight: bold;">${slotTotal} people</span>
                        `;
                        
                        // Mostrar detalles por fecha para este horario
                        const sortedDates = Object.entries(slotData).sort(([a], [b]) => new Date(a) - new Date(b));
                        if (sortedDates.length > 0) {
                            orientationsHTML += '<ul style="margin: 5px 0 0 20px; color: #666;">';
                            sortedDates.forEach(([date, count]) => {
                                orientationsHTML += `<li>${date}: ${count}</li>`;
                            });
                            orientationsHTML += '</ul>';
                        }
                        orientationsHTML += '</div>';
                    }
                });
                
                orientationsHTML += `
                    </div>
                    
                    <div style="background: #fff; border: 1px solid #e1bee7; padding: 10px; border-radius: 6px;">
                        <h5 style="color: #9C27B0; margin-bottom: 8px;">üìÖ All Orientations by Date</h5>
                `;
                
                Object.entries(counts.newHireOrientations)
                    .sort(([a], [b]) => new Date(a.split(' - ')[0]) - new Date(b.split(' - ')[0]))
                    .forEach(([orientation, count]) => {
                        orientationsHTML += `<p style="margin: 3px 0;"><strong>${orientation}:</strong> <span style="color: #9C27B0; font-weight: bold;">${count}</span></p>`;
                    });
                    
                orientationsHTML += '</div>';
            }
            
            // Team Visits
            if (Object.keys(counts.teamVisits).length > 0) {
                teamVisitsHTML = '<h4 style="color: #2196F3;">üè¢ Team Visits Detail</h4>';
                Object.entries(counts.teamVisits)
                    .sort(([a], [b]) => new Date(a.split(' - ')[0]) - new Date(b.split(' - ')[0]))
                    .forEach(([visit, count]) => {
                        teamVisitsHTML += `<p><strong>${visit}:</strong> <span style="color: #2196F3; font-weight: bold;">${count} ${count === 1 ? 'visit' : 'visits'}</span></p>`;
                    });
            }
            
            // Fingerprints
            if (Object.keys(counts.fingerprints).length > 0) {
                fingerprintsHTML = '<h4 style="color: #ff9800;">üëÜ Fingerprints Detail</h4>';
                Object.entries(counts.fingerprints)
                    .sort(([a], [b]) => {
                        const dateA = new Date(a.split(' - ')[0]);
                        const dateB = new Date(b.split(' - ')[0]);
                        return dateA - dateB;
                    })
                    .forEach(([fingerprint, count]) => {
                        fingerprintsHTML += `<p><strong>${fingerprint}:</strong> <span style="color: #ff9800; font-weight: bold;">${count} ${count === 1 ? 'appointment' : 'appointments'}</span></p>`;
                    });
            }
            
            // Badges
            if (Object.keys(counts.badges).length > 0) {
                badgesHTML = '<h4 style="color: #795548;">üÜî Badges Detail</h4>';
                Object.entries(counts.badges)
                    .sort(([a], [b]) => {
                        const dateA = new Date(a.split(' - ')[0]);
                        const dateB = new Date(b.split(' - ')[0]);
                        return dateA - dateB;
                    })
                    .forEach(([badge, count]) => {
                        badgesHTML += `<p><strong>${badge}:</strong> <span style="color: #795548; font-weight: bold;">${count} ${count === 1 ? 'appointment' : 'appointments'}</span></p>`;
                    });
            }
            
            card.innerHTML = `
                <h3>üìà Booking Analytics</h3>
                ${summaryHTML}
                <div style="margin-top: 20px;">
                    ${infoSessionsHTML}
                    ${infoSessionsHTML && orientationsHTML ? '<hr style="margin: 20px 0; border: 1px solid #eee;">' : ''}
                    ${orientationsHTML}
                    ${(infoSessionsHTML || orientationsHTML) && teamVisitsHTML ? '<hr style="margin: 20px 0; border: 1px solid #eee;">' : ''}
                    ${teamVisitsHTML}
                    ${(infoSessionsHTML || orientationsHTML || teamVisitsHTML) && fingerprintsHTML ? '<hr style="margin: 20px 0; border: 1px solid #eee;">' : ''}
                    ${fingerprintsHTML}
                    ${(infoSessionsHTML || orientationsHTML || teamVisitsHTML || fingerprintsHTML) && badgesHTML ? '<hr style="margin: 20px 0; border: 1px solid #eee;">' : ''}
                    ${badgesHTML}
                </div>
            `;
            
            if (!infoSessionsHTML && !orientationsHTML && !teamVisitsHTML && !fingerprintsHTML && !badgesHTML) {
                card.innerHTML = '<h3>üìà Booking Analytics</h3><p>No bookings found.</p>';
            }
            
            return card;
        }

        // Create visit card
        function createVisitCard(visit, visitId, isAdmin = false, index = null) {
            const card = document.createElement('div');
            card.className = 'visit-card';
            
            const date = visit.timestamp ? new Date(visit.timestamp).toLocaleString() : 'Date not available';
            
            let buttons = '';
            if (!isAdmin && visit.status === 'pending') {
                buttons = `<button class="btn btn-success" onclick="markVisitComplete('${visitId}')">Mark as Completed</button>`;
            } else if (isAdmin) {
                buttons = `
                    <span style="padding: 5px 10px; border-radius: 15px; background: ${visit.status === 'completed' ? '#4CAF50' : '#ff9800'}; color: white; font-size: 12px;">${visit.status}</span>
                    <button class="btn btn-danger" onclick="deleteVisit('${visitId}')" style="margin-left: 10px;">Delete Record</button>
                `;
            }
            
            card.innerHTML = `
                <div class="visit-header">
                    <h4>${index !== null ? `${index}. ` : ''}${visit.visitorName}</h4>
                    <span class="visit-time">${date}</span>
                </div>
                <p><strong>Email:</strong> ${visit.visitorEmail || 'Not provided'}</p>
                <p><strong>Team Member:</strong> ${visit.teamMemberName}</p>
                <p><strong>Reason:</strong> ${visit.reason}</p>
                <div style="margin-top: 15px;">
                    ${buttons}
                </div>
            `;
            
            return card;
        }

        // Create info session card
        function createInfoSessionCard(session, sessionId, isAdmin = false, index = null) {
            const card = document.createElement('div');
            card.className = 'visit-card';
            
            const date = session.timestamp ? new Date(session.timestamp).toLocaleString() : 'Date not available';
            
            // Check exclusion list for staff members
            let exclusionWarning = '';
            if (currentUser && (isAdmin || (currentUser.role === 'staff'))) {
                const matches = checkNameInExclusionList(session.name);
                if (matches.length > 0) {
                    exclusionWarning = `
                        <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; padding: 10px; margin: 10px 0;">
                            <h5 style="color: #856404; margin: 0 0 5px 0;">‚ö†Ô∏è Possible PC or RR List</h5>
                            <p style="color: #856404; margin: 5px 0; font-size: 13px;">This name appears on the exclusion list. Verify with SSN.</p>
                            ${matches.map(match => `
                                <div style="font-size: 12px; color: #856404;">
                                    Code: <strong>${match.code}</strong> - DOB: ${match.dob} - SSN: ***${match.ssn.slice(-4)}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
            }
            
            card.innerHTML = `
                ${isAdmin && sessionId ? `
                <div style="position: absolute; top: 10px; right: 10px;">
                    <input type="checkbox" class="record-checkbox info-session-checkbox" data-id="${sessionId}" onchange="updateDeleteButton('info-sessions')">
                </div>` : ''}
                <div class="visit-header">
                    <h4>${index !== null ? `${index}. ` : ''}${session.name}</h4>
                    <span class="visit-time">${session.date} - ${session.time}</span>
                </div>
                <p><strong>Email:</strong> ${session.email}</p>
                <p><strong>Phone:</strong> ${session.phone}</p>
                <p><strong>Session Type:</strong> <span style="background: ${!session.sessionType || session.sessionType === 'new-hire' ? '#d4edda' : '#fff3cd'}; color: ${!session.sessionType || session.sessionType === 'new-hire' ? '#155724' : '#856404'}; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">${!session.sessionType ? 'üÜï New Hire (Default)' : session.sessionType === 'new-hire' ? 'üÜï New Hire' : 'üîÑ Reactivation'}</span></p>
                
                <!-- Document Status Display -->
                <div style="background: #f8f9fa; border-radius: 8px; padding: 12px; margin: 10px 0;">
                    <h5 style="margin: 0 0 8px 0; color: #495057; font-size: 14px;">üìã Document Status</h5>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 13px;">
                        <div>
                            ${session.ob365Sent ? '<span style="color: #28a745;">‚úÖ OB365 Sent</span>' : '<span style="color: #6c757d;">‚¨ú OB365 Sent</span>'}
                        </div>
                        <div>
                            ${session.i9Sent ? '<span style="color: #28a745;">‚úÖ I9 Sent</span>' : '<span style="color: #6c757d;">‚¨ú I9 Sent</span>'}
                        </div>
                        <div>
                            ${session.existingI9 ? '<span style="color: #17a2b8;">‚úÖ Existing I9</span>' : '<span style="color: #6c757d;">‚¨ú Existing I9</span>'}
                        </div>
                        <div>
                            ${session.ineligible ? '<span style="color: #dc3545;">‚úÖ Inelegible</span>' : '<span style="color: #6c757d;">‚¨ú Inelegible</span>'}
                        </div>
                    </div>
                </div>
                
                <p><strong>Registered:</strong> ${date}</p>
                
                
                ${exclusionWarning}
                ${!isAdmin ? `
                <div class="checkbox-group" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div class="checkbox-item">
                        <input type="checkbox" id="ob365-${sessionId}" ${session.ob365Sent ? 'checked' : ''} 
                               onchange="updateSessionStatus('${sessionId}', 'ob365Sent', this.checked)">
                        <label for="ob365-${sessionId}">‚úÖ OB365 Sent</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="i9-${sessionId}" ${session.i9Sent ? 'checked' : ''} 
                               onchange="updateSessionStatus('${sessionId}', 'i9Sent', this.checked)">
                        <label for="i9-${sessionId}">üìù I9 Sent</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="existing-i9-${sessionId}" ${session.existingI9 ? 'checked' : ''} 
                               onchange="updateSessionStatus('${sessionId}', 'existingI9', this.checked)">
                        <label for="existing-i9-${sessionId}">üìÑ Existing I9</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="ineligible-${sessionId}" ${session.ineligible ? 'checked' : ''} 
                               onchange="updateSessionStatus('${sessionId}', 'ineligible', this.checked)">
                        <label for="ineligible-${sessionId}">‚ùå Inelegible</label>
                    </div>
                </div>` : `
                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin: 10px 0;">
                    <h6 style="margin: 0 0 8px 0; color: #495057;">Document Status (Admin View):</h6>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
                        <div><strong>OB365 Sent:</strong> ${session.ob365Sent ? '<span style="color: #28a745;">Yes</span>' : '<span style="color: #6c757d;">No</span>'}</div>
                        <div><strong>I9 Sent:</strong> ${session.i9Sent ? '<span style="color: #28a745;">Yes</span>' : '<span style="color: #6c757d;">No</span>'}</div>
                        <div><strong>Existing I9:</strong> ${session.existingI9 ? '<span style="color: #17a2b8;">Yes</span>' : '<span style="color: #6c757d;">No</span>'}</div>
                        <div><strong>Inelegible:</strong> ${session.ineligible ? '<span style="color: #dc3545;">Yes</span>' : '<span style="color: #6c757d;">No</span>'}</div>
                    </div>
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn btn-danger" onclick="deleteInfoSession('${sessionId}')">Delete Record</button>
                </div>`}
            `;
            
            // Add relative positioning for checkbox placement
            if (isAdmin) {
                card.style.position = 'relative';
            }
            
            return card;
        }

        // Create fingerprint card
        function createFingerprintCard(fingerprint, isAdmin = false, fingerprintId = null, index = null) {
            const card = document.createElement('div');
            card.className = 'visit-card';
            
            const registeredDate = fingerprint.timestamp ? new Date(fingerprint.timestamp).toLocaleString() : 'Date not available';
            
            card.innerHTML = `
                ${isAdmin && fingerprintId ? `
                <div style="position: absolute; top: 10px; right: 10px;">
                    <input type="checkbox" class="record-checkbox fingerprint-checkbox" data-id="${fingerprintId}" onchange="updateDeleteButton('fingerprints')">
                </div>` : ''}
                <div class="visit-header">
                    <h4>${index !== null ? `${index}. ` : ''}${fingerprint.name}</h4>
                    <span class="visit-time">${fingerprint.date} - ${fingerprint.time}</span>
                </div>
                <p><strong>Email:</strong> ${fingerprint.email}</p>
                <p><strong>Type:</strong> ${fingerprint.fingerprintType.toUpperCase()}</p>
                ${isAdmin ? `<p><strong>Registered:</strong> ${registeredDate}</p>` : ''}
                ${isAdmin && fingerprintId ? `
                <div style="margin-top: 15px;">
                    <button class="btn btn-danger" onclick="deleteFingerprint('${fingerprintId}')">Delete Record</button>
                </div>` : ''}
            `;
            
            // Add relative positioning for checkbox placement
            if (isAdmin) {
                card.style.position = 'relative';
            }
            
            return card;
        }

        // Create badge card
        function createBadgeCard(badge, isAdmin = false, badgeId = null, index = null) {
            const card = document.createElement('div');
            card.className = 'visit-card';
            
            const registeredDate = badge.timestamp ? new Date(badge.timestamp).toLocaleString() : 'Date not available';
            
            card.innerHTML = `
                ${isAdmin && badgeId ? `
                <div style="position: absolute; top: 10px; right: 10px;">
                    <input type="checkbox" class="record-checkbox badge-checkbox" data-id="${badgeId}" onchange="updateDeleteButton('badges')">
                </div>` : ''}
                <div class="visit-header">
                    <h4>${index !== null ? `${index}. ` : ''}üÜî ${badge.name}</h4>
                    <span class="visit-time">${badge.date} - ${badge.timeSlot}</span>
                </div>
                <p><strong>Email:</strong> ${badge.email}</p>
                <p><strong>Phone:</strong> ${badge.phone}</p>
                <p><strong>Time Slot:</strong> ${badge.timeSlot}</p>
                ${isAdmin ? `<p><strong>Registered:</strong> ${registeredDate}</p>` : ''}
                ${isAdmin && badgeId ? `
                <div style="margin-top: 15px;">
                    <button class="btn btn-danger" onclick="deleteBadge('${badgeId}')">Delete Record</button>
                </div>` : ''}
            `;
            
            // Add relative positioning for checkbox placement
            if (isAdmin) {
                card.style.position = 'relative';
            }
            
            return card;
        }

        // Create orientation card
        function createOrientationCard(orientation, showStatusControls = false, orientationId = null, isAdmin = false, index = null) {
            const card = document.createElement('div');
            card.className = 'visit-card';
            
            const registeredDate = orientation.timestamp ? new Date(orientation.timestamp).toLocaleString() : 'Date not available';
            
            // Status indicators
            const badgeStatus = orientation.badgePrinted ? '‚úÖ' : '‚ùå';
            const pendingStatus = orientation.hasPendingSteps ? '‚ö†Ô∏è' : '‚úÖ';
            
            // Use fingerprintStatus if available, otherwise fall back to waitingFingerprintResults
            let fpStatusText = 'Pending';
            let fpIcon = '‚è≥';
            
            if (orientation.fingerprintStatus) {
                if (orientation.fingerprintStatus === 'completed' || orientation.fingerprintStatus === 'ready') {
                    fpStatusText = 'Ready';
                    fpIcon = '‚úÖ';
                } else if (orientation.fingerprintStatus === 'pending') {
                    fpStatusText = 'Pending';
                    fpIcon = '‚è≥';
                }
            } else {
                // Fallback for old records
                if (!orientation.waitingFingerprintResults) {
                    fpStatusText = 'Ready';
                    fpIcon = '‚úÖ';
                }
            }
            
            const statusSection = showStatusControls ? `
                <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <h5 style="margin-bottom: 8px; color: #333;">üìã Process Status</h5>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 14px;">
                        <div>üÜî Badge: <span style="font-weight: bold;">${badgeStatus} ${orientation.badgePrinted ? 'Printed' : 'Pending'}</span></div>
                        <div>üëÜ Fingerprints: <span style="font-weight: bold;">${fpIcon} ${fpStatusText}</span></div>
                        <div style="grid-column: 1 / -1;">‚è≥ Steps: <span style="font-weight: bold;">${pendingStatus} ${orientation.hasPendingSteps ? 'Pending' : 'Completed'}</span></div>
                        ${orientation.hasPendingSteps && orientation.pendingStepsDetails ? 
                            `<div style="grid-column: 1 / -1; margin-top: 5px; padding: 5px; background: #fff3cd; border-radius: 3px;">
                                <strong>Details:</strong> ${orientation.pendingStepsDetails}
                            </div>` : ''}
                    </div>
                    <div style="margin-top: 10px;">
                        <button class="btn" onclick="updateOrientationStatus('${orientationId}')" style="font-size: 12px; padding: 5px 10px;">Update Status</button>
                    </div>
                </div>
            ` : '';
            
            card.innerHTML = `
                ${isAdmin && orientationId ? `
                <div style="position: absolute; top: 10px; right: 10px;">
                    <input type="checkbox" class="record-checkbox orientation-checkbox" data-id="${orientationId}" onchange="updateDeleteButton('orientations')">
                </div>` : ''}
                <div class="visit-header">
                    <h4>${index !== null ? `${index}. ` : ''}üéØ ${orientation.name}</h4>
                    <span class="visit-time">${orientation.date} - ${orientation.timeSlot}</span>
                </div>
                <p><strong>Email:</strong> ${orientation.email}</p>
                <p><strong>Phone:</strong> ${orientation.phone}</p>
                <p><strong>Orientation Time:</strong> ${orientation.timeSlot}</p>
                ${statusSection}
                ${showStatusControls ? `<p><strong>Registered:</strong> ${registeredDate}</p>` : ''}
                ${isAdmin && orientationId ? `
                <div style="margin-top: 15px;">
                    <button class="btn btn-danger" onclick="deleteOrientation('${orientationId}')">Delete Record</button>
                </div>` : ''}
            `;
            
            // Add relative positioning for checkbox placement
            if (isAdmin) {
                card.style.position = 'relative';
            }
            
            return card;
        }

        // Mark visit as complete
        async function markVisitComplete(visitId) {
            try {
                await db.collection('visits').doc(visitId).update({
                    status: 'completed',
                    completedAt: new Date().toISOString()
                });
                
                showSuccessMessage('Visit marked as completed');
                loadMyVisits();
                
            } catch (error) {
                console.error('Error updating visit:', error);
                showErrorMessage('Error updating visit status.');
            }
        }

        // Update session status
        async function updateSessionStatus(sessionId, field, value) {
            try {
                await db.collection('info-sessions').doc(sessionId).update({
                    [field]: value,
                    updatedAt: new Date().toISOString()
                });
                
                showSuccessMessage(`${field === 'ob365Sent' ? 'OB365' : 'I9'} status updated`);
                
            } catch (error) {
                console.error('Error updating session:', error);
                showErrorMessage('Error updating session status.');
            }
        }

        // Delete info session (admin only)
        async function deleteInfoSession(sessionId) {
            if (!isAdmin) {
                showErrorMessage('Access denied. Admin privileges required.');
                return;
            }
            
            if (confirm('Are you sure you want to delete this info session record? This action cannot be undone.')) {
                try {
                    await db.collection('info-sessions').doc(sessionId).delete();
                    showSuccessMessage('Info session record deleted successfully!');
                    loadAllInfoSessions(); // Reload the list
                    
                } catch (error) {
                    console.error('Error deleting info session:', error);
                    showErrorMessage('Error deleting info session record.');
                }
            }
        }

        // Update user type fields visibility
        function updateUserTypeFields() {
            const userType = document.getElementById('new-user-type').value;
            const teamField = document.getElementById('team-field');
            const titleField = document.getElementById('title-field');
            const teamSelect = document.getElementById('new-user-team');
            const titleInput = document.getElementById('new-user-title');
            
            if (userType === 'staff') {
                teamField.style.display = 'block';
                titleField.style.display = 'block';
                teamSelect.setAttribute('required', 'required');
                titleInput.setAttribute('required', 'required');
            } else if (userType === 'admin') {
                teamField.style.display = 'none';
                titleField.style.display = 'none';
                teamSelect.removeAttribute('required');
                titleInput.removeAttribute('required');
                teamSelect.value = '';
                titleInput.value = '';
            } else {
                teamField.style.display = 'none';
                titleField.style.display = 'none';
                teamSelect.removeAttribute('required');
                titleInput.removeAttribute('required');
            }
        }

        // Create new user
        async function createNewUser(event) {
            event.preventDefault();
            
            if (!isAdmin) {
                showErrorMessage('Access denied. Admin privileges required.');
                return;
            }
            
            try {
                const email = document.getElementById('new-user-email').value;
                const password = document.getElementById('new-user-password').value;
                const userType = document.getElementById('new-user-type').value;
                const name = document.getElementById('new-user-name').value;
                
                // Create user in Authentication
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                const user = userCredential.user;
                
                // Prepare user data
                const userData = {
                    name: name,
                    email: email,
                    userType: userType,
                    createdAt: new Date().toISOString(),
                    createdBy: currentUser.email
                };
                
                // Add staff-specific fields if user type is staff
                if (userType === 'staff') {
                    userData.team = document.getElementById('new-user-team').value;
                    userData.title = document.getElementById('new-user-title').value;
                    
                    // Add to staff collection as well for backwards compatibility
                    await db.collection('staff').doc(user.uid).set({
                        name: name,
                        email: email,
                        team: userData.team,
                        title: userData.title,
                        createdAt: new Date().toISOString()
                    });
                }
                
                // Add user data to users collection
                await db.collection('users').doc(user.uid).set(userData);
                
                showSuccessMessage(`${userType === 'admin' ? 'Administrator' : 'Staff member'} created successfully!`);
                document.querySelector('#manage-users form').reset();
                updateUserTypeFields(); // Reset field visibility
                loadAllUsersList(); // Refresh the users list
                
                // TODO: Send welcome email if checkbox is checked
                const sendWelcomeEmail = document.getElementById('send-welcome-email').checked;
                if (sendWelcomeEmail) {
                    showSuccessMessage('User created! (Welcome email feature will be implemented soon)');
                }
                
            } catch (error) {
                console.error('Error creating user:', error);
                if (error.code === 'auth/email-already-in-use') {
                    showErrorMessage('Email already in use!');
                } else if (error.code === 'auth/weak-password') {
                    showErrorMessage('Password is too weak. Please use at least 6 characters.');
                } else {
                    showErrorMessage('Error creating user account.');
                }
            }
        }

        // Load all users list
        async function loadAllUsersList() {
            if (!isAdmin) return;
            
            try {
                const usersList = document.getElementById('all-users-list');
                usersList.innerHTML = '<p>Loading users...</p>';
                
                // Load from both users collection and staff collection for backwards compatibility
                const usersSnapshot = await db.collection('users').orderBy('name').get();
                const staffSnapshot = await db.collection('staff').orderBy('name').get();
                
                usersList.innerHTML = '';
                
                const processedEmails = new Set();
                
                // Process users from users collection first
                usersSnapshot.forEach(doc => {
                    const user = doc.data();
                    if (!processedEmails.has(user.email)) {
                        const userCard = createUserCard(user, doc.id);
                        usersList.appendChild(userCard);
                        processedEmails.add(user.email);
                    }
                });
                
                // Process staff collection for backwards compatibility
                staffSnapshot.forEach(doc => {
                    const staff = doc.data();
                    if (!processedEmails.has(staff.email)) {
                        // Convert staff data to user format
                        const userData = {
                            ...staff,
                            userType: 'staff' // Assume staff type for existing records
                        };
                        const userCard = createUserCard(userData, doc.id);
                        usersList.appendChild(userCard);
                        processedEmails.add(staff.email);
                    }
                });
                
                if (usersList.children.length === 0) {
                    usersList.innerHTML = '<p>No users found.</p>';
                }
                
            } catch (error) {
                console.error('Error loading users:', error);
                document.getElementById('all-users-list').innerHTML = '<p>Error loading users.</p>';
            }
        }

        // Create user card
        function createUserCard(user, userId) {
            const card = document.createElement('div');
            card.className = 'visit-card';
            
            const userTypeLabel = user.userType === 'admin' ? 'üëë Administrator' : 'üë§ Staff Member';
            const teamInfo = user.team ? `<p><strong>Team:</strong> ${user.team}</p>` : '';
            const titleInfo = user.title ? `<p><strong>Title:</strong> ${user.title}</p>` : '';
            
            card.innerHTML = `
                <div class="visit-header">
                    <div>
                        <h4>${user.name}</h4>
                        <span style="background: ${user.userType === 'admin' ? '#ff9800' : '#4CAF50'}; color: white; padding: 3px 8px; border-radius: 10px; font-size: 12px;">
                            ${userTypeLabel}
                        </span>
                    </div>
                    <div>
                        <button class="btn" onclick="editUser('${userId}', '${user.userType}')">Edit</button>
                        <button class="btn btn-danger" onclick="deleteUser('${userId}', '${user.email}')">Delete</button>
                    </div>
                </div>
                <p><strong>Email:</strong> ${user.email}</p>
                ${teamInfo}
                ${titleInfo}
                <p><strong>Created:</strong> ${user.createdAt ? user.createdAt.toDate().toLocaleDateString() : 'Unknown'}</p>
            `;
            
            return card;
        }

        // Delete user
        async function deleteUser(userId, userEmail) {
            if (!isAdmin) return;
            
            if (userEmail === 'cculturausallc@gmail.com') {
                showErrorMessage('Cannot delete the main administrator account.');
                return;
            }
            
            if (confirm('Are you sure you want to delete this user account? This action cannot be undone.')) {
                try {
                    // Delete from Firestore collections
                    await db.collection('users').doc(userId).delete();
                    await db.collection('staff').doc(userId).delete(); // Also try to delete from staff collection
                    
                    // Note: Cannot delete from Firebase Auth from client side
                    // In a production app, you'd need a Cloud Function for this
                    
                    showSuccessMessage('User account deleted successfully!');
                    loadAllUsersList();
                    
                } catch (error) {
                    console.error('Error deleting user:', error);
                    showErrorMessage('Error deleting user account.');
                }
            }
        }

        // Edit user (placeholder for now)
        function editUser(userId, userType) {
            showErrorMessage('Edit user functionality will be available in the next update.');
            // TODO: Implement edit user modal similar to edit staff
        }

        // ===== DOCUMENT COMPLETION ONLY MODE =====

        // Show document completion form in registration-only mode
        function showDocumentCompletionOnly() {
            console.log('üìã Setting up visitor-only document completion view...');
            
            // Hide navigation and dashboard elements, but keep success screens visible
            document.querySelectorAll('.nav-buttons, .dashboard-section').forEach(element => {
                element.style.display = 'none';
            });
            
            // Hide all screens except document completion related ones
            document.querySelectorAll('.screen:not(#document-completion-form):not(#document-completion-success)').forEach(element => {
                element.style.display = 'none';
            });
            
            // Hide staff-only buttons
            document.querySelectorAll('.btn[onclick*="showCompletionsAlert"], .btn[onclick*="adminResetQueue"], .btn[onclick*="testPCRRStatus"], .btn[onclick*="debugOrientationCounts"], .btn[onclick*="checkRecruiterPermissions"]').forEach(btn => {
                btn.style.display = 'none';
            });
            
            // Show only the document completion form
            const docForm = document.getElementById('document-completion-form');
            docForm.style.display = 'block';
            
            // Disable ALL Firebase listeners to prevent conflicts
            console.log('üö´ Disabling all Firebase listeners to prevent conflicts...');
            
            // Stop all existing listeners
            if (window.realtimeListeners && Array.isArray(window.realtimeListeners)) {
                window.realtimeListeners.forEach(listener => {
                    if (listener && typeof listener.unsubscribe === 'function') {
                        listener.unsubscribe();
                    }
                });
                window.realtimeListeners = [];
                console.log('‚úÖ All Firebase listeners stopped');
            }
            
            // Initialize the dynamic checklist after showing the form
            setTimeout(() => {
                console.log('üîÑ Initializing dynamic document completion checklist...');
                // Only initialize the dynamic checklist, no old form handler
                if (typeof initDocumentCompletionChecklist === 'function') {
                    initDocumentCompletionChecklist();
                } else {
                    console.log('‚ö†Ô∏è initDocumentCompletionChecklist function not found, trying alternative...');
                    // Alternative initialization
                    if (typeof firebase !== 'undefined' && firebase.firestore) {
                        const db = firebase.firestore();
                        if (document.getElementById('document-completion-checklist-container')) {
                            window.documentCompletionChecklist = new DocumentCompletionChecklist(db);
                        }
                    }
                }
            }, 1000);
            docForm.classList.add('active');
            
            // Hide the cancel button since there's nowhere to go back to
            const cancelBtn = document.getElementById('doc-completion-cancel-btn');
            if (cancelBtn) cancelBtn.style.display = 'none';
            
            // Clean up the form appearance for visitor-only view - PRESERVE UPDATED CONTENT
            const title = docForm.querySelector('h2');
            if (title) {
                // Don't override the title - keep the updated version
                title.style.textAlign = 'center';
                title.style.color = '#4CAF50';
                title.style.marginBottom = '30px';
            }
            
            // DON'T hide instruction paragraphs - we need them to show English instructions
            // Keep the version and instruction paragraphs visible
            
            // Enhance the submit button for visitor view
            const submitBtn = docForm.querySelector('button[type="submit"]');
            if (submitBtn) {
                submitBtn.textContent = '‚úÖ Submit Completion';
                submitBtn.style.fontSize = '18px';
                submitBtn.style.padding = '15px 30px';
                submitBtn.style.width = '100%';
                submitBtn.style.marginTop = '20px';
                submitBtn.style.padding = '12px 24px';
            }
            
            // Add minimal styling for registration-only mode
            docForm.style.maxWidth = '500px';
            docForm.style.margin = '20px auto';
            docForm.style.padding = '20px';
            
            // Set flag for registration-only mode
            window.isRegistrationOnlyMode = true;
            
            console.log('Document completion form shown in simplified registration-only mode');
        }

        // Handle cancel button for document completion
        function handleDocCompletionCancel() {
            if (window.isRegistrationOnlyMode) {
                // In registration-only mode, just refresh the page to reset
                window.location.reload();
            } else {
                // Normal mode, go back to visitor screen
                showScreen('visitor');
            }
        }

        // ===== RECRUITER MANAGEMENT FUNCTIONS =====

        // Load recruiters management
        async function loadRecruitersManagement() {
            if (!isAdmin) return;
            
            // Set today's date as default
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('availability-date').value = today;
            
            // Load recruiters dropdown and today's status
            await Promise.all([
                loadRecruiterSelect(),
                loadTodaysRecruiterStatus()
            ]);
        }

        // Load recruiter select dropdown
        async function loadRecruiterSelect() {
            try {
                const select = document.getElementById('recruiter-select');
                select.innerHTML = '<option value="">Loading recruiters...</option>';
                
                const recruitersSnapshot = await db.collection('staff')
                    .where('team', '==', 'recruiting')
                    .get();
                
                select.innerHTML = '<option value="">Select recruiter</option>';
                
                if (recruitersSnapshot.empty) {
                    select.innerHTML = '<option value="">No recruiters found</option>';
                    return;
                }
                
                // Convert to array and sort by name
                const recruiters = [];
                recruitersSnapshot.forEach(doc => {
                    recruiters.push({ id: doc.id, ...doc.data() });
                });
                recruiters.sort((a, b) => a.name.localeCompare(b.name));
                
                recruiters.forEach(recruiter => {
                    const option = document.createElement('option');
                    option.value = recruiter.id;
                    option.textContent = `${recruiter.name} (${recruiter.email})`;
                    option.dataset.email = recruiter.email;
                    option.dataset.name = recruiter.name;
                    select.appendChild(option);
                });
                
            } catch (error) {
                console.error('Error loading recruiters:', error);
                document.getElementById('recruiter-select').innerHTML = '<option value="">Error loading recruiters</option>';
            }
        }

        // Load today's recruiter status
        async function loadTodaysRecruiterStatus() {
            try {
                const statusDiv = document.getElementById('todays-recruiter-status');
                statusDiv.innerHTML = '<p style="text-align: center; color: #666;">Loading status...</p>';
                
                const today = new Date().toISOString().split('T')[0];
                
                // Get today's availability records
                const availabilitySnapshot = await db.collection('recruiter-availability')
                    .where('date', '==', today)
                    .get();
                
                // Get all recruiters
                const recruitersSnapshot = await db.collection('staff')
                    .where('team', '==', 'recruiting')
                    .get();
                
                if (recruitersSnapshot.empty) {
                    statusDiv.innerHTML = '<p style="color: #ff6b6b; text-align: center;">No recruiters found in system</p>';
                    return;
                }
                
                const availabilityMap = {};
                availabilitySnapshot.forEach(doc => {
                    const data = doc.data();
                    availabilityMap[data.staffId] = {id: doc.id, ...data};
                });
                
                // Convert to array and sort by name
                const recruiters = [];
                recruitersSnapshot.forEach(doc => {
                    recruiters.push({ id: doc.id, ...doc.data() });
                });
                recruiters.sort((a, b) => a.name.localeCompare(b.name));
                
                let statusHtml = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">';
                
                recruiters.forEach(recruiter => {
                    const availability = availabilityMap[recruiter.id];
                    
                    let statusText = 'Not Set';
                    let statusColor = '#ccc';
                    let statusIcon = '‚ùì';
                    
                    if (availability) {
                        if (availability.isPresent && availability.isFree) {
                            statusText = 'Present & Free';
                            statusColor = '#28a745';
                            statusIcon = '‚úÖ';
                        } else if (availability.isPresent && !availability.isFree) {
                            statusText = 'Present & Busy';
                            statusColor = '#ffc107';
                            statusIcon = 'üü°';
                        } else {
                            statusText = 'Not Present';
                            statusColor = '#dc3545';
                            statusIcon = '‚ùå';
                        }
                    }
                    
                    statusHtml += `
                        <div style="background: white; border: 1px solid #ddd; border-radius: 8px; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <strong>${recruiter.name}</strong>
                                <span style="color: ${statusColor}; font-weight: bold;">${statusIcon} ${statusText}</span>
                            </div>
                            <div style="color: #666; font-size: 14px; margin-bottom: 10px;">
                                ${recruiter.email}
                            </div>
                            ${availability && availability.notes ? `<div style="color: #666; font-size: 12px; font-style: italic;">Note: ${availability.notes}</div>` : ''}
                            <div style="margin-top: 10px;">
                                <button class="btn btn-sm" onclick="quickSetAvailability('${recruiter.id}', '${recruiter.name}', '${recruiter.email}', 'present-free')" 
                                        style="background: #28a745; color: white; margin-right: 5px; padding: 5px 10px; font-size: 12px;">Set Free</button>
                                <button class="btn btn-sm" onclick="quickSetAvailability('${recruiter.id}', '${recruiter.name}', '${recruiter.email}', 'present-busy')" 
                                        style="background: #ffc107; color: black; margin-right: 5px; padding: 5px 10px; font-size: 12px;">Set Busy</button>
                                <button class="btn btn-sm" onclick="quickSetAvailability('${recruiter.id}', '${recruiter.name}', '${recruiter.email}', 'not-present')" 
                                        style="background: #dc3545; color: white; padding: 5px 10px; font-size: 12px;">Set Away</button>
                            </div>
                        </div>
                    `;
                });
                
                statusHtml += '</div>';
                statusDiv.innerHTML = statusHtml;
                
            } catch (error) {
                console.error('Error loading today\'s recruiter status:', error);
                document.getElementById('todays-recruiter-status').innerHTML = '<p style="color: #ff6b6b; text-align: center;">Error loading status</p>';
            }
        }

        // Quick set availability
        async function quickSetAvailability(staffId, recruiterName, recruiterEmail, status) {
            try {
                const today = new Date().toISOString().split('T')[0];
                
                let isPresent, isFree;
                switch (status) {
                    case 'present-free':
                        isPresent = true;
                        isFree = true;
                        break;
                    case 'present-busy':
                        isPresent = true;
                        isFree = false;
                        break;
                    case 'not-present':
                        isPresent = false;
                        isFree = false;
                        break;
                }
                
                const availabilityData = {
                    staffId: staffId,
                    recruiterName: recruiterName,
                    recruiterEmail: recruiterEmail,
                    date: today,
                    isPresent: isPresent,
                    isFree: isFree,
                    lastUpdated: new Date().toISOString(),
                    updatedBy: currentUser ? currentUser.email : 'admin'
                };
                
                // Check if record exists for today
                const existingSnapshot = await db.collection('recruiter-availability')
                    .where('staffId', '==', staffId)
                    .where('date', '==', today)
                    .get();
                
                if (existingSnapshot.empty) {
                    // Create new record
                    await db.collection('recruiter-availability').add(availabilityData);
                } else {
                    // Update existing record
                    await db.collection('recruiter-availability')
                        .doc(existingSnapshot.docs[0].id)
                        .update(availabilityData);
                }
                
                showSuccessMessage(`${recruiterName} status updated successfully!`);
                loadTodaysRecruiterStatus(); // Refresh status
                
            } catch (error) {
                console.error('Error setting quick availability:', error);
                showErrorMessage('Error updating recruiter status.');
            }
        }

        // Set recruiter availability (form submission)
        async function setRecruiterAvailability(event) {
            event.preventDefault();
            
            if (!isAdmin) {
                showErrorMessage('Access denied. Admin privileges required.');
                return;
            }
            
            try {
                const recruiterSelect = document.getElementById('recruiter-select');
                const selectedOption = recruiterSelect.options[recruiterSelect.selectedIndex];
                const staffId = recruiterSelect.value;
                const recruiterName = selectedOption.dataset.name;
                const recruiterEmail = selectedOption.dataset.email;
                const date = document.getElementById('availability-date').value;
                const status = document.getElementById('availability-status').value;
                const notes = document.getElementById('availability-notes').value;
                
                let isPresent, isFree;
                switch (status) {
                    case 'present-free':
                        isPresent = true;
                        isFree = true;
                        break;
                    case 'present-busy':
                        isPresent = true;
                        isFree = false;
                        break;
                    case 'not-present':
                        isPresent = false;
                        isFree = false;
                        break;
                }
                
                const availabilityData = {
                    staffId: staffId,
                    recruiterName: recruiterName,
                    recruiterEmail: recruiterEmail,
                    date: date,
                    isPresent: isPresent,
                    isFree: isFree,
                    notes: notes || '',
                    timestamp: new Date().toISOString(),
                    createdBy: currentUser ? currentUser.email : 'admin'
                };
                
                // Check if record exists for this recruiter and date
                const existingSnapshot = await db.collection('recruiter-availability')
                    .where('staffId', '==', staffId)
                    .where('date', '==', date)
                    .get();
                
                if (existingSnapshot.empty) {
                    // Create new record
                    await db.collection('recruiter-availability').add(availabilityData);
                    showSuccessMessage('Recruiter availability set successfully!');
                } else {
                    // Update existing record
                    await db.collection('recruiter-availability')
                        .doc(existingSnapshot.docs[0].id)
                        .update({...availabilityData, lastUpdated: new Date().toISOString()});
                    showSuccessMessage('Recruiter availability updated successfully!');
                }
                
                // Clear form
                document.querySelector('#manage-recruiters form').reset();
                document.getElementById('availability-date').value = new Date().toISOString().split('T')[0];
                
                // Refresh status if today
                const today = new Date().toISOString().split('T')[0];
                if (date === today) {
                    loadTodaysRecruiterStatus();
                }
                
            } catch (error) {
                console.error('Error setting recruiter availability:', error);
                showErrorMessage('Error setting recruiter availability.');
            }
        }

        // Refresh recruiters status
        function refreshRecruitersStatus() {
            loadTodaysRecruiterStatus();
        }

        // Load recruiters availability (for the all records section)
        async function loadRecruitersAvailability(period) {
            try {
                const listDiv = document.getElementById('all-recruiters-availability');
                listDiv.innerHTML = '<p style="text-align: center; color: #666;">Loading availability records...</p>';
                
                let query = db.collection('recruiter-availability');
                
                const today = new Date().toISOString().split('T')[0];
                
                if (period === 'today') {
                    query = query.where('date', '==', today);
                } else if (period === 'week') {
                    const weekAgo = new Date();
                    weekAgo.setDate(weekAgo.getDate() - 7);
                    const weekAgoStr = weekAgo.toISOString().split('T')[0];
                    query = query.where('date', '>=', weekAgoStr);
                }
                
                const snapshot = await query.orderBy('date', 'desc').limit(50).get();
                
                if (snapshot.empty) {
                    listDiv.innerHTML = '<p style="text-align: center; color: #666;">No availability records found.</p>';
                    return;
                }
                
                let recordsHtml = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px;">';
                
                snapshot.forEach(doc => {
                    const record = doc.data();
                    
                    let statusText = 'Unknown';
                    let statusColor = '#ccc';
                    let statusIcon = '‚ùì';
                    
                    if (record.isPresent && record.isFree) {
                        statusText = 'Present & Free';
                        statusColor = '#28a745';
                        statusIcon = '‚úÖ';
                    } else if (record.isPresent && !record.isFree) {
                        statusText = 'Present & Busy';
                        statusColor = '#ffc107';
                        statusIcon = 'üü°';
                    } else {
                        statusText = 'Not Present';
                        statusColor = '#dc3545';
                        statusIcon = '‚ùå';
                    }
                    
                    const formattedDate = new Date(record.date + 'T00:00:00').toLocaleDateString();
                    
                    recordsHtml += `
                        <div style="background: white; border: 1px solid #ddd; border-radius: 8px; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <strong>${record.recruiterName}</strong>
                                <span style="color: ${statusColor}; font-weight: bold;">${statusIcon} ${statusText}</span>
                            </div>
                            <div style="color: #666; font-size: 14px; margin-bottom: 5px;">
                                üìÖ ${formattedDate}
                            </div>
                            <div style="color: #666; font-size: 14px; margin-bottom: 10px;">
                                üìß ${record.recruiterEmail}
                            </div>
                            ${record.notes ? `<div style="color: #666; font-size: 12px; font-style: italic; margin-bottom: 10px;">üìù ${record.notes}</div>` : ''}
                            <div style="color: #999; font-size: 11px;">
                                Updated by: ${record.createdBy || record.updatedBy || 'System'}
                            </div>
                            <div style="margin-top: 10px; text-align: right;">
                                <button class="btn btn-sm btn-danger" onclick="deleteAvailabilityRecord('${doc.id}')" style="padding: 5px 10px; font-size: 12px;">Delete</button>
                            </div>
                        </div>
                    `;
                });
                
                recordsHtml += '</div>';
                listDiv.innerHTML = recordsHtml;
                
            } catch (error) {
                console.error('Error loading recruiters availability:', error);
                document.getElementById('all-recruiters-availability').innerHTML = '<p style="color: #ff6b6b; text-align: center;">Error loading availability records</p>';
            }
        }

        // Delete availability record
        async function deleteAvailabilityRecord(recordId) {
            if (!isAdmin) {
                showErrorMessage('Access denied. Admin privileges required.');
                return;
            }
            
            if (confirm('Are you sure you want to delete this availability record?')) {
                try {
                    await db.collection('recruiter-availability').doc(recordId).delete();
                    showSuccessMessage('Availability record deleted successfully!');
                    
                    // Refresh current view - check which button was last clicked or default to today
                    loadRecruitersAvailability('today');
                    loadTodaysRecruiterStatus(); // Also refresh today's status in case it was a today record
                    
                } catch (error) {
                    console.error('Error deleting availability record:', error);
                    showErrorMessage('Error deleting availability record.');
                }
            }
        }

        // Delete fingerprint record (admin only)
        async function deleteFingerprint(fingerprintId) {
            if (!isAdmin) {
                showErrorMessage('Access denied. Admin privileges required.');
                return;
            }
            
            if (confirm('Are you sure you want to delete this fingerprint record? This action cannot be undone.')) {
                try {
                    await db.collection('fingerprints').doc(fingerprintId).delete();
                    showSuccessMessage('Fingerprint record deleted successfully!');
                    loadAllFingerprints(); // Reload the list
                    
                } catch (error) {
                    console.error('Error deleting fingerprint:', error);
                    showErrorMessage('Error deleting fingerprint record.');
                }
            }
        }

        // Delete visit record (admin only)
        async function deleteVisit(visitId) {
            if (!isAdmin) {
                showErrorMessage('Access denied. Admin privileges required.');
                return;
            }
            
            if (confirm('Are you sure you want to delete this visit record? This action cannot be undone.')) {
                try {
                    await db.collection('visits').doc(visitId).delete();
                    showSuccessMessage('Visit record deleted successfully!');
                    loadAllVisits(); // Reload the list
                    
                } catch (error) {
                    console.error('Error deleting visit:', error);
                    showErrorMessage('Error deleting visit record.');
                }
            }
        }

        // Delete badge record (admin only)
        async function deleteBadge(badgeId) {
            if (!isAdmin) {
                showErrorMessage('Access denied. Admin privileges required.');
                return;
            }
            
            if (confirm('Are you sure you want to delete this badge appointment? This action cannot be undone.')) {
                try {
                    await db.collection('badges').doc(badgeId).delete();
                    showSuccessMessage('Badge appointment deleted successfully!');
                    loadAllBadges(); // Reload the list
                    
                } catch (error) {
                    console.error('Error deleting badge:', error);
                    showErrorMessage('Error deleting badge appointment.');
                }
            }
        }

        // Delete orientation record (admin only)
        async function deleteOrientation(orientationId) {
            if (!isAdmin) {
                showErrorMessage('Access denied. Admin privileges required.');
                return;
            }
            
            if (confirm('Are you sure you want to delete this orientation record? This action cannot be undone.')) {
                try {
                    await db.collection('new-hire-orientations').doc(orientationId).delete();
                    showSuccessMessage('New hire orientation deleted successfully!');
                    loadAllOrientations(); // Reload the list
                    
                } catch (error) {
                    console.error('Error deleting orientation:', error);
                    showErrorMessage('Error deleting orientation record.');
                }
            }
        }


        // Success and error message functions
        function showSuccessMessage(message) {
            console.log('üì¢ showSuccessMessage called with:', message);
            const existingMessage = document.querySelector('.success-message, .error-message');
            if (existingMessage) {
                console.log('üì¢ Removing existing message');
                existingMessage.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'success-message';
            messageDiv.textContent = message;
            messageDiv.style.cssText = `
                background: #d4edda !important;
                color: #155724 !important;
                padding: 15px !important;
                border-radius: 8px !important;
                margin: 20px 0 !important;
                border: 1px solid #c3e6cb !important;
                position: relative !important;
                z-index: 1000 !important;
                display: block !important;
                width: 100% !important;
                box-sizing: border-box !important;
                font-weight: bold !important;
                text-align: center !important;
            `;
            
            // Try multiple strategies to insert the message
            let inserted = false;
            
            // Strategy 1: Try to insert in active screen
            const activeScreen = document.querySelector('.screen.active');
            console.log('üì¢ Active screen found:', activeScreen ? 'YES' : 'NO');
            if (activeScreen) {
                activeScreen.insertBefore(messageDiv, activeScreen.firstChild);
                console.log('üì¢ Message inserted in active screen');
                inserted = true;
            }
            
            // Strategy 2: If no active screen, try dashboard section
            if (!inserted) {
                const dashboard = document.querySelector('#dashboard');
                if (dashboard) {
                    dashboard.insertBefore(messageDiv, dashboard.firstChild);
                    console.log('üì¢ Message inserted in dashboard');
                    inserted = true;
                }
            }
            
            // Strategy 3: If all else fails, insert in body
            if (!inserted) {
                document.body.insertBefore(messageDiv, document.body.firstChild);
                console.log('üì¢ Message inserted in body as fallback');
                inserted = true;
            }
            
            console.log('üì¢ Message insertion result:', inserted ? 'SUCCESS' : 'FAILED');
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 5000);
        }

        function showErrorMessage(message) {
            const existingMessage = document.querySelector('.success-message, .error-message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'error-message';
            messageDiv.textContent = message;
            
            const activeScreen = document.querySelector('.screen.active');
            activeScreen.insertBefore(messageDiv, activeScreen.firstChild);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 5000);
        }

        // Variables para notificaciones de pesta√±a
        let originalTitle = document.title;
        let blinkInterval = null;
        let isBlinking = false;
        let hasNewVisits = false; // Para trackear si hay nuevas visitas

        // Real-time notification functions
        function showRealtimeNotification(title, message) {
            console.log('üîî Notificaci√≥n disparada:', title, message);
            
            // Reproducir sonido de notificaci√≥n
            playNotificationSound();
            
            // Activar notificaci√≥n visual en pesta√±a
            startTabNotification();
            
            // Crear notificaci√≥n visual en la p√°gina
            const notificationDiv = document.createElement('div');
            notificationDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 300px;
                animation: slideIn 0.3s ease;
            `;
            
            notificationDiv.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 5px;">${title}</div>
                <div style="font-size: 14px;">${message}</div>
            `;
            
            document.body.appendChild(notificationDiv);
            
            // Remover despu√©s de 5 segundos
            setTimeout(() => {
                if (notificationDiv.parentNode) {
                    notificationDiv.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => {
                        notificationDiv.remove();
                    }, 300);
                }
            }, 5000);
            
            // Intentar mostrar notificaci√≥n del navegador tambi√©n
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification(title, {
                    body: message,
                    icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEyIDJDNi40NzcgMiAyIDYuNDc3IDIgMTJTNi40NzcgMjIgMTIgMjJTMjIgMTcuNTIzIDIyIDEyUzE3LjUyMyAyIDEyIDJaIiBmaWxsPSIjNENBRjUwIi8+CjxwYXRoIGQ9Ik0xNiA5TDEwLjUgMTQuNUw4IDEyIiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8L3N2Zz4K'
                });
            }
        }

        // Funciones para notificaciones en pesta√±a
        function startTabNotification() {
            console.log('Iniciando notificaci√≥n de pesta√±a...');
            if (isBlinking) {
                console.log('Ya hay una notificaci√≥n activa, saltando...');
                return; // Ya est√° parpadeando
            }
            
            isBlinking = true;
            let isRed = false;
            
            console.log('T√≠tulo original guardado:', originalTitle);
            
            blinkInterval = setInterval(() => {
                if (isRed) {
                    document.title = originalTitle;
                } else {
                    document.title = 'üî¥ ¬°NUEVA NOTIFICACI√ìN! - ' + originalTitle;
                }
                isRed = !isRed;
                console.log('Parpadeo cambiado a:', document.title);
            }, 1000); // Parpadea cada segundo
            
            // Ya no hay timeout - el parpadeo contin√∫a hasta que el usuario abra la pesta√±a
            console.log('Parpadeo iniciado - continuar√° hasta que abras la pesta√±a');
        }

        function stopTabNotification() {
            console.log('Deteniendo notificaci√≥n de pesta√±a...');
            if (blinkInterval) {
                clearInterval(blinkInterval);
                blinkInterval = null;
                console.log('Intervalo de parpadeo detenido');
            }
            isBlinking = false;
            document.title = originalTitle;
            console.log('T√≠tulo restaurado a:', originalTitle);
        }

        // Detener notificaci√≥n de pesta√±a SOLO cuando el usuario regrese a la pesta√±a
        document.addEventListener('visibilitychange', () => {
            console.log('Visibilidad cambiada, hidden:', document.hidden);
            if (!document.hidden && isBlinking) {
                console.log('Usuario regres√≥ a la pesta√±a, deteniendo notificaci√≥n...');
                stopTabNotification();
            }
        });
        
        // Tambi√©n detener cuando la ventana reciba foco (por si acaso)
        window.addEventListener('focus', () => {
            if (isBlinking) {
                console.log('Ventana recibi√≥ foco, deteniendo notificaci√≥n...');
                stopTabNotification();
            }
        });

        // Funciones para el indicador de nuevas visitas
        function showVisitsIndicator() {
            const indicator = document.getElementById('visits-indicator');
            if (indicator) {
                indicator.style.display = 'inline';
                hasNewVisits = true;
                console.log('Indicador de nuevas visitas mostrado');
            }
        }

        function hideVisitsIndicator() {
            const indicator = document.getElementById('visits-indicator');
            if (indicator) {
                indicator.style.display = 'none';
                hasNewVisits = false;
                console.log('Indicador de nuevas visitas ocultado');
            }
        }

        // Funci√≥n de prueba para notificaciones de pesta√±a
        function testTabNotification() {
            console.log('üß™ Ejecutando prueba de notificaci√≥n de pesta√±a...');
            showRealtimeNotification('üß™ Test Notification', 'Hello Kelly member, this is a test notification');
        }

        // Funci√≥n de prueba para Info Sessions
        function testInfoSessionDebug() {
            console.log('üß™ === DEBUGGING INFO SESSION ===');
            console.log('üîç Firebase initialized:', typeof firebase !== 'undefined');
            console.log('üîç Firestore db:', typeof db, db);
            console.log('üîç Form elements check:');
            console.log('  - info-name:', document.getElementById('info-name'));
            console.log('  - info-email:', document.getElementById('info-email'));
            console.log('  - info-phone:', document.getElementById('info-phone'));
            console.log('  - info-date:', document.getElementById('info-date'));
            console.log('  - info-time:', document.getElementById('info-time'));
            console.log('üîç Form:', document.querySelector('#info-session-form form'));
            
            // Probar conexi√≥n b√°sica a Firestore
            try {
                db.collection('info-sessions').limit(1).get().then(() => {
                    console.log('‚úÖ Firestore connection works');
                }).catch(error => {
                    console.error('‚ùå Firestore connection error:', error);
                });
            } catch (error) {
                console.error('‚ùå Error testing Firestore:', error);
            }
        }

        // Funci√≥n de prueba para verificar estado de usuario y exclusi√≥n
        function testExclusionStatus() {
            console.log('üß™ === DEBUGGING EXCLUSION STATUS ===');
            console.log('üîç Current User:', currentUser);
            console.log('üîç Is Admin:', isAdmin);
            console.log('üîç Current User Role:', currentUser?.role);
            console.log('üîç Exclusion List Data Length:', exclusionListData.length);
            console.log('üîç Should show exclusion alerts:', currentUser && (isAdmin || (currentUser.role === 'staff')));
            
            if (exclusionListData.length > 0) {
                console.log('üîç Sample exclusion records:', exclusionListData.slice(0, 3));
                
                // Test with a sample name
                const testName = exclusionListData[0]?.name || 'Test Name';
                console.log('üîç Testing exclusion check with name:', testName);
                const matches = checkNameInExclusionList(testName);
                console.log('üîç Exclusion matches found:', matches);
            }
        }

        // Funci√≥n para reproducir sonido de notificaci√≥n
        function playNotificationSound() {
            if (!audioEnabled) {
                console.log('Audio no habilitado a√∫n');
                return;
            }
            
            try {
                // Crear sonido usando Web Audio API
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Asegurar que el contexto est√© activo
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Crear un oscilador para generar el sonido
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // Conectar los nodos
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Configurar el sonido (tono de notificaci√≥n)
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // Frecuencia inicial
                oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1); // Bajar tono
                
                // Configurar volumen
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                // Reproducir sonido
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
                
                console.log('Sonido de notificaci√≥n reproducido');
                
            } catch (error) {
                console.log('Error reproduciendo sonido:', error);
            }
        }

        // Funci√≥n alternativa para sonido de √©xito (m√°s alegre)
        function playSuccessSound() {
            if (!audioEnabled) {
                console.log('Audio no habilitado a√∫n');
                return;
            }
            
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Asegurar que el contexto est√© activo
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Crear una secuencia de tonos m√°s alegre
                const frequencies = [523.25, 659.25, 783.99]; // Do, Mi, Sol
                
                frequencies.forEach((freq, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + index * 0.1);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + index * 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.1 + 0.2);
                    
                    oscillator.start(audioContext.currentTime + index * 0.1);
                    oscillator.stop(audioContext.currentTime + index * 0.1 + 0.2);
                });
                
                console.log('Sonido de √©xito reproducido');
                
            } catch (error) {
                console.log('Error reproduciendo sonido de √©xito:', error);
            }
        }

        // Habilitar audio con interacci√≥n del usuario
        function enableAudio() {
            if (!audioEnabled) {
                try {
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    // Reproducir un sonido silencioso para habilitar audio
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    
                    audioEnabled = true;
                    console.log('Audio habilitado');
                    
                    // Mostrar mensaje de confirmaci√≥n
                    showSuccessMessage('üîä Audio notifications enabled!');
                    
                } catch (error) {
                    console.log('Error habilitando audio:', error);
                }
            }
        }

        // Pedir permiso para notificaciones del navegador al hacer login
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log('Notificaciones habilitadas');
                    }
                });
            }
        }

        // Desconectar todos los listeners en tiempo real
        function disconnectRealtimeListeners() {
            realtimeListeners.forEach(listener => {
                if (listener.unsubscribe) {
                    listener.unsubscribe();
                }
            });
            realtimeListeners = [];
        }

        // Agregar estilos CSS para animaciones
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0% {
                    transform: scale(1);
                    box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
                }
                70% {
                    transform: scale(1.05);
                    box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
                }
                100% {
                    transform: scale(1);
                    box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
                }
            }
            
            .pulse-animation {
                animation: pulse 2s infinite;
            }
            
            @keyframes slideIn {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            
            @keyframes slideOut {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);

        // ===== TEAM VISIT FUNCTIONS =====
        
        // Update team members dropdown based on selected team (public form)
        async function updateTeamMembers() {
            const teamSelect = document.getElementById('team-select');
            const memberSelect = document.getElementById('team-member');
            const selectedTeam = teamSelect.value;
            
            // Clear previous options
            memberSelect.innerHTML = '<option value="">Loading members...</option>';
            
            if (!selectedTeam) {
                memberSelect.innerHTML = '<option value="">First select a team</option>';
                return;
            }
            
            try {
                // Get staff members from the selected team
                // NOTE: This excludes management team - they are not visible to public
                const staffQuery = await db.collection('staff').where('team', '==', selectedTeam).get();
                
                memberSelect.innerHTML = '<option value="">Select team member</option>';
                
                if (staffQuery.empty) {
                    memberSelect.innerHTML = '<option value="">No members available</option>';
                    return;
                }
                
                // Add each staff member as an option
                staffQuery.forEach(doc => {
                    const staff = doc.data();
                    const option = document.createElement('option');
                    option.value = staff.name;
                    option.textContent = `${staff.name} - ${staff.title}`;
                    option.dataset.email = staff.email;
                    option.dataset.name = staff.name;
                    memberSelect.appendChild(option);
                });
                
            } catch (error) {
                console.error('Error loading team members:', error);
                memberSelect.innerHTML = '<option value="">Error loading members</option>';
            }
        }

        // ===== NEW HIRE ORIENTATIONS FUNCTIONS =====
        
        // Load staff orientations with real-time updates (all staff)
        async function loadStaffOrientations() {
            // Don't start listeners on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Skipping loadStaffOrientations on document-completion page');
                return;
            }
            
            console.log('üîç DEBUG: loadStaffOrientations() called from line 8911');
            if (!currentUser) return;
            
            const orientationsList = document.getElementById('staff-orientations-list');
            
            // Clear existing content
            orientationsList.innerHTML = '<p>Loading orientations...</p>';
            
            try {
                // Get orientations with real-time updates
                const unsubscribe = db.collection('new-hire-orientations')
                    .orderBy('timestamp', 'desc')
                    .onSnapshot(snapshot => {
                        orientationsList.innerHTML = '';
                        
                        if (snapshot.empty) {
                            orientationsList.innerHTML = '<p>No new hire orientations registered.</p>';
                            return;
                        }
                        
                        // Convert to array and sort by timestamp (newest first)
                        const orientationsArray = [];
                        snapshot.forEach(doc => {
                            orientationsArray.push({
                                id: doc.id,
                                data: doc.data()
                            });
                        });
                        
                        // Sort by timestamp (newest first)
                        orientationsArray.sort((a, b) => {
                            const timeA = a.data.timestamp ? new Date(a.data.timestamp) : new Date();
                            const timeB = b.data.timestamp ? new Date(b.data.timestamp) : new Date();
                            return timeB - timeA;
                        });
                        
                        // Agrupar orientations por fecha con separadores
                        console.log('üîç DEBUG: Processing', orientationsArray.length, 'orientations for date separation');
                        const orientationsByDate = {};
                        const today = new Date().toISOString().split('T')[0];
                        
                        orientationsArray.forEach(item => {
                            const orientation = item.data;
                            let orientationDate = 'unknown-date';
                            
                            // Obtener fecha del timestamp
                            if (orientation.timestamp) {
                                try {
                                    orientationDate = new Date(orientation.timestamp).toISOString().split('T')[0];
                                } catch (e) {
                                    console.log('üîç DEBUG: Error parsing timestamp for orientation:', orientation.name);
                                    orientationDate = 'unknown-date';
                                }
                            }
                            
                            if (!orientationsByDate[orientationDate]) {
                                orientationsByDate[orientationDate] = [];
                            }
                            orientationsByDate[orientationDate].push(item);
                        });
                        
                        // Ordenar fechas (m√°s recientes primero)
                        const sortedDates = Object.keys(orientationsByDate).sort((a, b) => {
                            if (a === 'unknown-date') return 1;
                            if (b === 'unknown-date') return -1;
                            return new Date(b) - new Date(a);
                        });
                        
                        console.log('üîç DEBUG: Orientation dates found:', sortedDates);
                        
                        // Renderizar por fecha
                        let totalIndex = 0;
                        sortedDates.forEach(date => {
                            const isToday = date === today;
                            
                            // Crear separador de fecha
                            const dateSeparator = document.createElement('div');
                            dateSeparator.style.cssText = `
                                background: ${isToday ? '#4CAF50' : '#2196F3'};
                                color: white;
                                padding: 12px 20px;
                                margin: 20px 0 10px 0;
                                border-radius: 8px;
                                font-weight: bold;
                                text-align: center;
                                font-size: 16px;
                            `;
                            
                            if (date === 'unknown-date') {
                                dateSeparator.textContent = 'üéØ Date not available';
                            } else {
                                const dateObj = new Date(date + 'T12:00:00');
                                const formattedDate = dateObj.toLocaleDateString('en-US', {
                                    weekday: 'long',
                                    year: 'numeric',
                                    month: 'long',
                                    day: 'numeric'
                                });
                                dateSeparator.textContent = isToday ? `üìÖ Today - ${formattedDate}` : `üìÖ ${formattedDate}`;
                            }
                            
                            orientationsList.appendChild(dateSeparator);
                            
                            // Renderizar orientations de esta fecha
                            orientationsByDate[date].forEach(item => {
                                totalIndex++;
                                const orientation = item.data;
                                const orientationId = item.id;
                                const orientationCard = createOrientationCard(orientation, true, orientationId, false, totalIndex);
                                orientationsList.appendChild(orientationCard);
                            });
                        });
                    });
                    
                // Store listener for cleanup
                realtimeListeners.push({
                    type: 'staff-orientations-active',
                    unsubscribe: unsubscribe
                });
                    
            } catch (error) {
                console.error('Error loading orientations:', error);
                orientationsList.innerHTML = '<p>Error loading orientations. Please refresh.</p>';
            }
        }
        
        // Load dashboard data for staff
        async function loadDashboardData() {
            // Don't start listeners on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Skipping loadDashboardData on document-completion page');
                return;
            }
            
            if (!currentUser) return;
            
            try {
                // Check if user is from recruiting, management, or front-desk team
                const staffDoc = await db.collection('staff').where('email', '==', currentUser.email).get();
                let isRecruiting = false;
                let isManagement = false;
                let isFrontDesk = false;
                
                staffDoc.forEach(doc => {
                    const staffData = doc.data();
                    if (staffData.team === 'recruiting') {
                        isRecruiting = true;
                    }
                    if (staffData.team === 'management') {
                        isManagement = true;
                    }
                    if (staffData.team === 'front-desk') {
                        isFrontDesk = true;
                    }
                });
                
                // Load orientations for all staff members
                loadStaffOrientations();
                
                // Siempre iniciar listener de visitas para notificaciones
                startVisitsListener();
                
            } catch (error) {
                console.error('Error loading dashboard data:', error);
            }
        }

        // Listener solo para notificaciones de visitas (sin renderizar UI)
        function startVisitsListener() {
            if (!currentUser) return;
            
            console.log('Iniciando listener de notificaciones de visitas...');
            
            // Listen for real-time updates on visits for this staff member
            const visitsRef = db.collection('visits')
                .where('staffMember', '==', currentUser.displayName || currentUser.email)
                .where('status', '==', 'pending');
            
            const unsubscribe = visitsRef.onSnapshot(snapshot => {
                console.log('Cambio detectado en visitas para notificaciones');
                
                if (snapshot.empty) {
                    return;
                }
                
                // Verificar si hay nuevas visitas
                let hasNewVisitsDetected = false;
                snapshot.docChanges().forEach(change => {
                    if (change.type === 'added') {
                        hasNewVisitsDetected = true;
                        console.log('Nueva visita detectada para notificaci√≥n');
                    }
                });
                
                // Mostrar notificaci√≥n si hay nuevas visitas
                if (hasNewVisitsDetected && snapshot.docChanges().length > 0) {
                    console.log('Disparando notificaci√≥n de nueva visita');
                    showRealtimeNotification('üîî New visit registered!', 'You have a new pending visit.');
                    showVisitsIndicator(); // Mostrar indicador visual en el bot√≥n
                }
                
            }, error => {
                console.error('Error in visits notification listener:', error);
            });
            
            // Store the unsubscribe function to clean up later
            realtimeListeners.push(unsubscribe);
        }

        // ===== ORIENTATION STATUS MODAL FUNCTIONS =====
        
        // Open orientation status modal
        async function updateOrientationStatus(orientationId) {
            console.log('updateOrientationStatus called with ID:', orientationId); // Debug log
            
            try {
                const orientationDoc = await db.collection('new-hire-orientations').doc(orientationId).get();
                console.log('Document exists:', orientationDoc.exists); // Debug log
                
                if (orientationDoc.exists) {
                    const orientation = orientationDoc.data();
                    console.log('Orientation data:', orientation); // Debug log
                    
                    // Set the orientation ID
                    document.getElementById('orientation-id').value = orientationId;
                    
                    // Set name display
                    document.getElementById('orientation-name-display').textContent = orientation.name;
                    
                    // Set checkbox values
                    document.getElementById('modal-badge-printed').checked = orientation.badgePrinted || false;
                    document.getElementById('modal-pending-steps').checked = orientation.hasPendingSteps || false;
                    
                    // Set fingerprint status - use new field if available, otherwise use old field
                    const fingerprintStatus = orientation.fingerprintStatus || (orientation.waitingFingerprintResults ? 'pending' : 'ready');
                    document.getElementById('modal-fingerprint-status').value = fingerprintStatus;
                    
                    // Set pending details
                    document.getElementById('modal-pending-details').value = orientation.pendingStepsDetails || '';
                    
                    // Show/hide pending steps field based on current status
                    const pendingField = document.getElementById('modal-pending-steps-field');
                    if (orientation.hasPendingSteps) {
                        pendingField.style.display = 'block';
                    } else {
                        pendingField.style.display = 'none';
                    }
                    
                    // Show modal
                    document.getElementById('orientation-status-modal').style.display = 'block';
                    console.log('Modal should be visible now'); // Debug log
                } else {
                    console.error('Orientation document not found');
                    showErrorMessage('Orientation not found.');
                }
            } catch (error) {
                console.error('Error loading orientation:', error);
                showErrorMessage('Error loading orientation details: ' + error.message);
            }
        }
        
        // Save orientation status
        async function saveOrientationStatus(event) {
            event.preventDefault();
            
            console.log('saveOrientationStatus called'); // Debug log
            
            try {
                const orientationId = document.getElementById('orientation-id').value;
                console.log('Orientation ID:', orientationId); // Debug log
                
                if (!orientationId) {
                    console.error('No orientation ID found');
                    showErrorMessage('Error: No orientation ID found.');
                    return;
                }
                
                const fingerprintStatus = document.getElementById('modal-fingerprint-status').value;
                
                const updateData = {
                    badgePrinted: document.getElementById('modal-badge-printed').checked,
                    hasPendingSteps: document.getElementById('modal-pending-steps').checked,
                    pendingStepsDetails: document.getElementById('modal-pending-details').value,
                    fingerprintStatus: fingerprintStatus,
                    // Keep old field for backward compatibility but set based on new status
                    waitingFingerprintResults: fingerprintStatus === 'pending',
                    lastUpdated: new Date().toISOString(),
                    updatedBy: currentUser ? currentUser.email : 'unknown'
                };
                
                console.log('Update data:', updateData); // Debug log
                
                await db.collection('new-hire-orientations').doc(orientationId).update(updateData);
                
                console.log('Update successful'); // Debug log
                showSuccessMessage('Orientation status updated successfully!');
                closeOrientationStatusModal();
                
                // Refresh the orientations list if on staff view
                if (document.getElementById('new-hire-orientations').style.display !== 'none') {
                    loadStaffOrientations();
                }
                
            } catch (error) {
                console.error('Error updating orientation:', error);
                showErrorMessage('Error updating orientation status: ' + error.message);
            }
        }
        
        // Close orientation status modal
        function closeOrientationStatusModal() {
            document.getElementById('orientation-status-modal').style.display = 'none';
            
            // Clear form
            document.getElementById('orientation-id').value = '';
            document.getElementById('orientation-name-display').textContent = '';
            document.getElementById('modal-badge-printed').checked = false;
            document.getElementById('modal-pending-steps').checked = false;
            document.getElementById('modal-fingerprint-status').value = 'pending';
            document.getElementById('modal-pending-details').value = '';
            document.getElementById('modal-pending-steps-field').style.display = 'none';
        }
        
        // Toggle pending steps field in modal
        function toggleModalPendingStepsField() {
            const checkbox = document.getElementById('modal-pending-steps');
            const field = document.getElementById('modal-pending-steps-field');
            
            if (checkbox.checked) {
                field.style.display = 'block';
            } else {
                field.style.display = 'none';
                document.getElementById('modal-pending-details').value = '';
            }
        }
        
        // ===== BULK DELETE FUNCTIONS (ADMIN ONLY) =====
        
        // Update delete button state based on selected checkboxes
        function updateDeleteButton(type) {
            const checkboxes = document.querySelectorAll(`.${type.slice(0, -1)}-checkbox:checked`);
            const deleteButton = document.getElementById(`delete-selected-${type}-btn`);
            const selectAllButton = document.getElementById(`select-all-${type}-btn`);
            
            if (checkboxes.length > 0) {
                deleteButton.disabled = false;
                deleteButton.textContent = `Delete Selected (${checkboxes.length})`;
            } else {
                deleteButton.disabled = true;
                deleteButton.textContent = 'Delete Selected';
            }
            
            // Update select all button text
            const allCheckboxes = document.querySelectorAll(`.${type.slice(0, -1)}-checkbox`);
            if (checkboxes.length === allCheckboxes.length && allCheckboxes.length > 0) {
                selectAllButton.textContent = 'Deselect All';
            } else {
                selectAllButton.textContent = 'Select All';
            }
        }
        
        // Select/Deselect all orientations
        function selectAllOrientations() {
            const checkboxes = document.querySelectorAll('.orientation-checkbox');
            const selectAllBtn = document.getElementById('select-all-orientations-btn');
            const shouldSelect = selectAllBtn.textContent === 'Select All';
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = shouldSelect;
            });
            
            updateDeleteButton('orientations');
        }
        
        // Select/Deselect all info sessions
        function selectAllInfoSessions() {
            const checkboxes = document.querySelectorAll('.info-session-checkbox');
            const selectAllBtn = document.getElementById('select-all-info-sessions-btn');
            const shouldSelect = selectAllBtn.textContent === 'Select All';
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = shouldSelect;
            });
            
            updateDeleteButton('info-sessions');
        }
        
        // Select/Deselect all fingerprints
        function selectAllFingerprints() {
            const checkboxes = document.querySelectorAll('.fingerprint-checkbox');
            const selectAllBtn = document.getElementById('select-all-fingerprints-btn');
            const shouldSelect = selectAllBtn.textContent === 'Select All';
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = shouldSelect;
            });
            
            updateDeleteButton('fingerprints');
        }
        
        // Select/Deselect all badges
        function selectAllBadges() {
            const checkboxes = document.querySelectorAll('.badge-checkbox');
            const selectAllBtn = document.getElementById('select-all-badges-btn');
            const shouldSelect = selectAllBtn.textContent === 'Select All';
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = shouldSelect;
            });
            
            updateDeleteButton('badges');
        }
        
        // Delete selected orientations
        async function deleteSelectedOrientations() {
            const selectedCheckboxes = document.querySelectorAll('.orientation-checkbox:checked');
            const count = selectedCheckboxes.length;
            
            if (count === 0) return;
            
            if (confirm(`Are you sure you want to delete ${count} selected orientation(s)? This action cannot be undone.`)) {
                try {
                    const batch = db.batch();
                    selectedCheckboxes.forEach(checkbox => {
                        const orientationId = checkbox.getAttribute('data-id');
                        const orientationRef = db.collection('new-hire-orientations').doc(orientationId);
                        batch.delete(orientationRef);
                    });
                    
                    await batch.commit();
                    showSuccessMessage(`${count} orientation(s) deleted successfully!`);
                    
                    // Refresh the list (this should trigger when the admin loads orientations)
                    // Since we don't have the exact function, we'll reload the page section
                    document.getElementById('admin-orientations-list').innerHTML = '<p>Refreshing...</p>';
                    
                } catch (error) {
                    console.error('Error deleting orientations:', error);
                    showErrorMessage('Error deleting orientations. Please try again.');
                }
            }
        }
        
        // Delete selected info sessions
        async function deleteSelectedInfoSessions() {
            const selectedCheckboxes = document.querySelectorAll('.info-session-checkbox:checked');
            const count = selectedCheckboxes.length;
            
            if (count === 0) return;
            
            if (confirm(`Are you sure you want to delete ${count} selected info session(s)? This action cannot be undone.`)) {
                try {
                    const batch = db.batch();
                    selectedCheckboxes.forEach(checkbox => {
                        const sessionId = checkbox.getAttribute('data-id');
                        const sessionRef = db.collection('info-sessions').doc(sessionId);
                        batch.delete(sessionRef);
                    });
                    
                    await batch.commit();
                    showSuccessMessage(`${count} info session(s) deleted successfully!`);
                    document.getElementById('admin-info-sessions-list').innerHTML = '<p>Refreshing...</p>';
                    
                } catch (error) {
                    console.error('Error deleting info sessions:', error);
                    showErrorMessage('Error deleting info sessions. Please try again.');
                }
            }
        }
        
        // Delete selected fingerprints
        async function deleteSelectedFingerprints() {
            const selectedCheckboxes = document.querySelectorAll('.fingerprint-checkbox:checked');
            const count = selectedCheckboxes.length;
            
            if (count === 0) return;
            
            if (confirm(`Are you sure you want to delete ${count} selected fingerprint(s)? This action cannot be undone.`)) {
                try {
                    const batch = db.batch();
                    selectedCheckboxes.forEach(checkbox => {
                        const fingerprintId = checkbox.getAttribute('data-id');
                        const fingerprintRef = db.collection('fingerprints').doc(fingerprintId);
                        batch.delete(fingerprintRef);
                    });
                    
                    await batch.commit();
                    showSuccessMessage(`${count} fingerprint(s) deleted successfully!`);
                    document.getElementById('admin-fingerprints-list').innerHTML = '<p>Refreshing...</p>';
                    
                } catch (error) {
                    console.error('Error deleting fingerprints:', error);
                    showErrorMessage('Error deleting fingerprints. Please try again.');
                }
            }
        }
        
        // Delete selected badges
        async function deleteSelectedBadges() {
            const selectedCheckboxes = document.querySelectorAll('.badge-checkbox:checked');
            const count = selectedCheckboxes.length;
            
            if (count === 0) return;
            
            if (confirm(`Are you sure you want to delete ${count} selected badge(s)? This action cannot be undone.`)) {
                try {
                    const batch = db.batch();
                    selectedCheckboxes.forEach(checkbox => {
                        const badgeId = checkbox.getAttribute('data-id');
                        const badgeRef = db.collection('badges').doc(badgeId);
                        batch.delete(badgeRef);
                    });
                    
                    await batch.commit();
                    showSuccessMessage(`${count} badge(s) deleted successfully!`);
                    document.getElementById('admin-badges-list').innerHTML = '<p>Refreshing...</p>';
                    
                } catch (error) {
                    console.error('Error deleting badges:', error);
                    showErrorMessage('Error deleting badges. Please try again.');
                }
            }
        }

        // Handle URL hash for direct navigation
        function handleHashNavigation() {
            const hash = window.location.hash.substring(1);
            console.log('Hash detected:', hash);
            
            if (hash === 'document-completion-form') {
                showDocumentCompletionOnly();
            } else if (hash.startsWith('event-registration')) {
                const parts = hash.split('/');
                console.log('Event hash parts:', parts);
                if (parts.length === 2) {
                    // Wait for Firebase to be ready
                    if (typeof db !== 'undefined') {
                        loadEventRegistrationForm(parts[1]);
                    } else {
                        // Retry after Firebase loads
                        setTimeout(() => {
                            if (typeof db !== 'undefined') {
                                loadEventRegistrationForm(parts[1]);
                            } else {
                                showErrorMessage('Please wait for page to load completely.');
                            }
                        }, 2000);
                    }
                } else {
                    console.error('Invalid event hash format');
                }
            } else if (hash) {
                console.log('Unknown hash:', hash);
            }
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            // Small delay to ensure Firebase is loaded
            setTimeout(handleHashNavigation, 1000);
        });
        window.addEventListener('hashchange', handleHashNavigation);

        // Event Management Functions
        
        // Add separator line when event name changes
        async function addEventSeparator(eventName) {
            try {
                const { staffData, staffId } = await getStaffRecord();
                const today = new Date().toISOString().split('T')[0];
                const timestamp = new Date().toISOString();
                
                const separatorData = {
                    type: 'separator',
                    eventName: eventName,
                    recruiterEmail: currentUser.email,
                    recruiterId: staffId,
                    recruiterName: staffData.name,
                    timestamp: timestamp,
                    date: today,
                    message: `--- NEW ENTRIES AFTER EVENT NAME CHANGE TO: ${eventName} ---`,
                    createdAt: new Date().toISOString()
                };
                
                await db.collection('event-registrations').add(separatorData);
                console.log('‚úÖ Event separator added for:', eventName);
                
            } catch (error) {
                console.error('Error adding event separator:', error);
            }
        }

        // Update event name
        async function updateEventName() {
            if (!currentUser) return;
            
            try {
                const newName = document.getElementById('event-name-input').value.trim();
                if (!newName) {
                    showErrorMessage('Please enter an event name.');
                    return;
                }
                
                // Get or create staff info
                const { staffData, staffId } = await getStaffRecord();
                const eventData = {
                    recruiterEmail: currentUser.email,
                    recruiterId: staffId,
                    eventName: newName,
                    address: "5600 W. Cermak Rd., Cicero, IL 60804", // Fixed address
                    updatedAt: new Date().toISOString()
                };
                
                // Check if event exists for this recruiter
                const existingEvent = await db.collection('recruiter-events')
                    .where('recruiterEmail', '==', currentUser.email)
                    .get();
                
                if (existingEvent.empty) {
                    // Create new event
                    await db.collection('recruiter-events').add(eventData);
                } else {
                    // Update existing event
                    const docId = existingEvent.docs[0].id;
                    await db.collection('recruiter-events').doc(docId).update({
                        eventName: newName,
                        updatedAt: new Date().toISOString()
                    });
                }
                
                // Add separator line for new entries
                await addEventSeparator(newName);
                
                showSuccessMessage('Event name updated successfully!');
                loadEventData();
                
            } catch (error) {
                console.error('Error updating event name:', error);
                showErrorMessage('Error updating event name. Please try again.');
            }
        }

        // Copy event link to clipboard
        async function copyEventLink() {
            if (!currentUser) {
                showErrorMessage('Please login first.');
                return;
            }
            
            try {
                // Get or create staff info to create unique link
                const { staffData, staffId } = await getStaffRecord();
                const eventLink = window.location.origin + window.location.pathname + '#event-registration/' + staffId;
                
                // Show the link in the UI first
                document.getElementById('event-link-text').textContent = eventLink;
                document.getElementById('event-link-display').style.display = 'block';
                
                // Try to copy to clipboard
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(eventLink);
                        showSuccessMessage('Event link copied to clipboard!');
                    } else {
                        // Fallback for older browsers or non-HTTPS
                        const textArea = document.createElement('textarea');
                        textArea.value = eventLink;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        showSuccessMessage('Event link copied to clipboard!');
                    }
                } catch (clipboardError) {
                    showSuccessMessage('Event link generated! Copy from the box below.');
                }
                
            } catch (error) {
                console.error('Error generating event link:', error);
                showErrorMessage('Error generating event link. Please try again.');
            }
        }

        // Generate QR code for event
        async function generateEventQR() {
            if (!currentUser) {
                showErrorMessage('Please login first.');
                return;
            }
            
            try {
                // Get or create staff info to create unique link
                const { staffData, staffId } = await getStaffRecord();
                const eventLink = window.location.origin + window.location.pathname + '#event-registration/' + staffId;
                
                // Clear previous QR code
                const qrContainer = document.getElementById('event-qr-code');
                qrContainer.innerHTML = 'Generating QR code...';
                
                // Generate QR code using API
                const qrApiUrl = 'https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=' + encodeURIComponent(eventLink);
                
                const qrImg = document.createElement('img');
                qrImg.src = qrApiUrl;
                qrImg.alt = 'QR Code';
                qrImg.style.maxWidth = '200px';
                qrImg.style.border = '1px solid #ddd';
                
                const downloadLink = document.createElement('a');
                downloadLink.href = qrApiUrl;
                downloadLink.download = 'event-qr-code.png';
                downloadLink.className = 'btn btn-secondary';
                downloadLink.style.fontSize = '12px';
                downloadLink.style.marginTop = '10px';
                downloadLink.textContent = 'üíæ Download QR';
                
                qrContainer.innerHTML = '';
                qrContainer.appendChild(qrImg);
                qrContainer.appendChild(document.createElement('br'));
                qrContainer.appendChild(document.createElement('br'));
                qrContainer.appendChild(downloadLink);
                
                document.getElementById('event-qr-display').style.display = 'block';
                showSuccessMessage('QR code generated successfully!');
                
            } catch (error) {
                console.error('Error generating QR code:', error);
                showErrorMessage('Error generating QR code. Please try again.');
            }
        }


        // Copy registrations list in easy-to-copy format
        async function copyRegistrationsList() {
            if (!currentUser) return;
            
            try {
                const staffSnapshot = await db.collection('staff')
                    .where('email', '==', currentUser.email)
                    .get();
                
                if (staffSnapshot.empty) return;
                
                const staffId = staffSnapshot.docs[0].id;
                
                // Get registrations for this recruiter's event
                const registrations = await db.collection('event-registrations')
                    .where('recruiterId', '==', staffId)
                    .get();
                
                if (registrations.empty) {
                    showErrorMessage('No registrations to copy.');
                    return;
                }
                
                let listText = 'EVENT REGISTRATIONS LIST:\n\n';
                let count = 1;
                
                registrations.docs.forEach(doc => {
                    const data = doc.data();
                    const preferredDate = formatRegistrationDate(data);
                    const candidateType = data.candidateType === 'new-hire' ? 'New Hire' : data.candidateType === 'reactivation' ? 'Reactivation' : 'N/A';
                    
                    listText += `${count}. ${data.name}\n`;
                    listText += `   Email: ${data.email}\n`;
                    listText += `   Phone: ${data.phone}\n`;
                    listText += `   Preferred Date: ${preferredDate}\n`;
                    listText += `   Type: ${candidateType}\n`;
                    listText += `   English Speaker: ${data.speaksEnglish ? 'Yes' : 'No'}\n`;
                    listText += `   60+ College Credits: ${data.has60Credits ? 'Yes' : 'No'}\n\n`;
                    
                    count++;
                });
                
                // Try to copy to clipboard
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(listText);
                        showSuccessMessage('Registrations list copied to clipboard!');
                    } else {
                        // Fallback for older browsers or non-HTTPS
                        const textArea = document.createElement('textarea');
                        textArea.value = listText;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        showSuccessMessage('Registrations list copied to clipboard!');
                    }
                } catch (clipboardError) {
                    // If clipboard fails, show the text in a popup
                    alert('Copy this text:\n\n' + listText);
                }
                
            } catch (error) {
                console.error('Error copying registrations list:', error);
                showErrorMessage('Error generating list. Please try again.');
            }
        }

        // Clear my event registrations with confirmation
        async function clearMyEventRegistrations() {
            if (!currentUser) return;
            
            // Ask for confirmation
            if (!confirm('Are you sure you want to delete ALL your event registrations? This action cannot be undone.')) {
                return;
            }
            
            try {
                const staffSnapshot = await db.collection('staff')
                    .where('email', '==', currentUser.email)
                    .get();
                
                if (staffSnapshot.empty) return;
                
                const staffId = staffSnapshot.docs[0].id;
                
                // Get all registrations for this recruiter's event
                const registrations = await db.collection('event-registrations')
                    .where('recruiterId', '==', staffId)
                    .get();
                
                if (registrations.empty) {
                    showSuccessMessage('No registrations to clear.');
                    return;
                }
                
                // Delete all registrations in batch
                const batch = db.batch();
                registrations.forEach(doc => {
                    batch.delete(doc.ref);
                });
                
                await batch.commit();
                
                showSuccessMessage(`Successfully deleted ${registrations.size} registration(s).`);
                
                // Reload the registrations list to reflect changes
                await loadEventRegistrations();
                await loadEventStatistics();
                
            } catch (error) {
                console.error('Error clearing event registrations:', error);
                showErrorMessage('Error clearing registrations. Please try again.');
            }
        }

        // Delete individual event registration
        async function deleteEventRegistration(registrationId, registrationName) {
            // Ask for confirmation
            if (!confirm(`Are you sure you want to delete the registration for "${registrationName}"? This action cannot be undone.`)) {
                return;
            }
            
            try {
                await db.collection('event-registrations').doc(registrationId).delete();
                
                showSuccessMessage(`Successfully deleted registration for ${registrationName}.`);
                
                // The real-time listener will automatically update the display
                
            } catch (error) {
                console.error('Error deleting event registration:', error);
                showErrorMessage('Error deleting registration. Please try again.');
            }
        }

        // Delete selected event registrations
        async function deleteSelectedRegistrations() {
            const selectedCheckboxes = document.querySelectorAll('.registration-checkbox:checked');
            
            if (selectedCheckboxes.length === 0) {
                showErrorMessage('Please select at least one registration to delete.');
                return;
            }
            
            const count = selectedCheckboxes.length;
            const registrationNames = Array.from(selectedCheckboxes).map(cb => {
                const row = cb.closest('tr');
                const nameCell = row.cells[1]; // Name is in the second column (index 1)
                return nameCell ? nameCell.textContent.trim() : 'Unknown';
            });
            
            // Show confirmation with names
            const namesPreview = registrationNames.slice(0, 5).join(', ') + (registrationNames.length > 5 ? '...' : '');
            const confirmed = confirm(`Are you sure you want to delete ${count} registration(s)?\n\nThis includes: ${namesPreview}\n\nThis action cannot be undone.`);
            
            if (!confirmed) return;
            
            try {
                // Delete all selected registrations in batch
                const batch = db.batch();
                selectedCheckboxes.forEach(checkbox => {
                    const registrationId = checkbox.getAttribute('data-id');
                    if (registrationId) {
                        const docRef = db.collection('event-registrations').doc(registrationId);
                        batch.delete(docRef);
                    }
                });
                
                await batch.commit();
                
                showSuccessMessage(`Successfully deleted ${count} registration(s).`);
                
                // Clear selections
                clearAllSelections();
                
                // The real-time listener will automatically update the display
                
            } catch (error) {
                console.error('Error deleting selected registrations:', error);
                showErrorMessage('Error deleting registrations. Please try again.');
            }
        }

        // Find and show duplicate registrations
        async function findAndShowDuplicates() {
            try {
                console.log('üîç Searching for duplicate registrations...');
                
                // Get all event registrations
                const registrationsSnapshot = await db.collection('event-registrations').get();
                
                if (registrationsSnapshot.empty) {
                    showErrorMessage('No registrations found.');
                    return;
                }
                
                // Group registrations by email (primary duplicate detection)
                const emailGroups = {};
                const phoneGroups = {};
                const nameGroups = {};
                
                registrationsSnapshot.forEach(doc => {
                    const data = doc.data();
                    const id = doc.id;
                    
                    // Group by email
                    if (data.email) {
                        const email = data.email.toLowerCase().trim();
                        if (!emailGroups[email]) emailGroups[email] = [];
                        emailGroups[email].push({id, data});
                    }
                    
                    // Group by phone
                    if (data.phone) {
                        const phone = data.phone.replace(/\D/g, ''); // Remove non-digits
                        if (!phoneGroups[phone]) phoneGroups[phone] = [];
                        phoneGroups[phone].push({id, data});
                    }
                    
                    // Group by name (exact match)
                    if (data.name) {
                        const name = data.name.toLowerCase().trim();
                        if (!nameGroups[name]) nameGroups[name] = [];
                        nameGroups[name].push({id, data});
                    }
                });
                
                // Find duplicates
                const duplicates = {
                    email: [],
                    phone: [],
                    name: []
                };
                
                // Find email duplicates
                Object.keys(emailGroups).forEach(email => {
                    if (emailGroups[email].length > 1) {
                        duplicates.email.push({
                            key: email,
                            registrations: emailGroups[email]
                        });
                    }
                });
                
                // Find phone duplicates
                Object.keys(phoneGroups).forEach(phone => {
                    if (phoneGroups[phone].length > 1) {
                        duplicates.phone.push({
                            key: phone,
                            registrations: phoneGroups[phone]
                        });
                    }
                });
                
                // Find name duplicates
                Object.keys(nameGroups).forEach(name => {
                    if (nameGroups[name].length > 1) {
                        duplicates.name.push({
                            key: name,
                            registrations: nameGroups[name]
                        });
                    }
                });
                
                const totalEmailDupes = duplicates.email.reduce((sum, group) => sum + group.registrations.length, 0);
                const totalPhoneDupes = duplicates.phone.reduce((sum, group) => sum + group.registrations.length, 0);
                const totalNameDupes = duplicates.name.reduce((sum, group) => sum + group.registrations.length, 0);
                
                console.log(`Found duplicates: ${duplicates.email.length} email groups, ${duplicates.phone.length} phone groups, ${duplicates.name.length} name groups`);
                
                if (duplicates.email.length === 0 && duplicates.phone.length === 0 && duplicates.name.length === 0) {
                    showSuccessMessage('üéâ No duplicate registrations found! Your data is clean.');
                    return;
                }
                
                // Show duplicates modal/interface
                showDuplicatesModal(duplicates);
                
            } catch (error) {
                console.error('Error finding duplicates:', error);
                showErrorMessage('Error finding duplicates. Please try again.');
            }
        }

        // Show duplicates in a modal-like interface
        function showDuplicatesModal(duplicates) {
            const listContainer = document.getElementById('event-registrations-list');
            if (!listContainer) return;
            
            let html = '<div class="visit-card" style="border: 2px solid #ffc107;">';
            html += '<h4 style="color: #856404;">üîç Duplicate Registrations Found</h4>';
            html += '<div style="margin-bottom: 15px;">';
            html += '<button class="btn" onclick="loadEventRegistrations()" style="background: #6c757d; color: white; margin-right: 10px;">‚Üê Back to All Registrations</button>';
            html += '<button class="btn btn-success" onclick="deleteAllDuplicates()">üóëÔ∏è Delete All Duplicates (Keep Newest)</button>';
            html += '</div>';
            
            // Email duplicates
            if (duplicates.email.length > 0) {
                html += '<div style="margin-bottom: 25px; padding: 15px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px;">';
                html += '<h5 style="color: #856404; margin-bottom: 15px;">üìß Email Duplicates (' + duplicates.email.length + ' groups)</h5>';
                
                duplicates.email.forEach((group, groupIndex) => {
                    html += '<div style="margin-bottom: 20px; border: 1px solid #ffc107; border-radius: 4px; overflow: hidden;">';
                    html += '<div style="background: #ffc107; color: #212529; padding: 10px; font-weight: bold;">Email: ' + group.key + ' (' + group.registrations.length + ' registrations)</div>';
                    html += '<table style="width: 100%; border-collapse: collapse;">';
                    html += '<thead><tr style="background: #f8f9fa;">';
                    html += '<th style="padding: 8px; border: 1px solid #ddd;">Select</th>';
                    html += '<th style="padding: 8px; border: 1px solid #ddd;">Name</th>';
                    html += '<th style="padding: 8px; border: 1px solid #ddd;">Phone</th>';
                    html += '<th style="padding: 8px; border: 1px solid #ddd;">Date</th>';
                    html += '<th style="padding: 8px; border: 1px solid #ddd;">Type</th>';
                    html += '<th style="padding: 8px; border: 1px solid #ddd;">Action</th>';
                    html += '</tr></thead><tbody>';
                    
                    // Sort by submission date (newest first)
                    const sortedRegs = group.registrations.sort((a, b) => {
                        const aTime = a.data.submittedAt?.toDate?.() || new Date(a.data.registrationTime || 0);
                        const bTime = b.data.submittedAt?.toDate?.() || new Date(b.data.registrationTime || 0);
                        return bTime - aTime;
                    });
                    
                    sortedRegs.forEach((reg, index) => {
                        const isNewest = index === 0;
                        const preferredDate = formatRegistrationDate(reg.data);
                        const candidateTypeDisplay = reg.data.candidateType === 'new-hire' ? 'üÜï New' : reg.data.candidateType === 'reactivation' ? 'üîÑ Reactivation' : 'N/A';
                        
                        html += '<tr style="background: ' + (isNewest ? '#d4edda' : '#f8d7da') + ';">';
                        html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">';
                        if (!isNewest) {
                            html += '<input type="checkbox" class="duplicate-checkbox" data-id="' + reg.id + '" checked>';
                        } else {
                            html += '<span style="color: #28a745; font-weight: bold;">KEEP</span>';
                        }
                        html += '</td>';
                        html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (reg.data.name || 'No Name') + '</td>';
                        html += '<td style="padding: 8px; border: 1px solid #ddd;">' + (reg.data.phone || 'No Phone') + '</td>';
                        html += '<td style="padding: 8px; border: 1px solid #ddd;">' + preferredDate + '</td>';
                        html += '<td style="padding: 8px; border: 1px solid #ddd;">' + candidateTypeDisplay + '</td>';
                        html += '<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">';
                        if (!isNewest) {
                            html += '<button onclick="deleteEventRegistration(\'' + reg.id + '\', \'' + (reg.data.name || 'Unknown') + '\')" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 11px;">üóëÔ∏è</button>';
                        }
                        html += '</td>';
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table></div>';
                });
                
                html += '</div>';
            }
            
            // Phone duplicates (similar structure)
            if (duplicates.phone.length > 0) {
                html += '<div style="margin-bottom: 25px; padding: 15px; background: #e2e3f3; border: 1px solid #b8b9f3; border-radius: 8px;">';
                html += '<h5 style="color: #4c4d8b; margin-bottom: 15px;">üì± Phone Duplicates (' + duplicates.phone.length + ' groups)</h5>';
                // Similar implementation as email duplicates...
                html += '<p style="color: #6c757d; font-style: italic;">Phone duplicate details can be expanded here...</p>';
                html += '</div>';
            }
            
            // Name duplicates (similar structure)
            if (duplicates.name.length > 0) {
                html += '<div style="margin-bottom: 25px; padding: 15px; background: #f3e2e2; border: 1px solid #f3b8b8; border-radius: 8px;">';
                html += '<h5 style="color: #8b4c4c; margin-bottom: 15px;">üë§ Name Duplicates (' + duplicates.name.length + ' groups)</h5>';
                // Similar implementation as email duplicates...
                html += '<p style="color: #6c757d; font-style: italic;">Name duplicate details can be expanded here...</p>';
                html += '</div>';
            }
            
            html += '<div style="margin-top: 20px; padding: 15px; background: #d1ecf1; border: 1px solid #bee5eb; border-radius: 8px;">';
            html += '<h6 style="color: #0c5460;">üîß Bulk Actions</h6>';
            html += '<button class="btn btn-danger" onclick="deleteSelectedDuplicates()" style="margin-right: 10px;">üóëÔ∏è Delete Selected</button>';
            html += '<button class="btn" onclick="selectAllDuplicates()">Select All Duplicates</button>';
            html += '<button class="btn" onclick="clearDuplicateSelections()" style="margin-left: 10px;">Clear Selection</button>';
            html += '</div>';
            
            html += '</div>';
            
            listContainer.innerHTML = html;
        }

        // Delete all duplicates (keep newest)
        async function deleteAllDuplicates() {
            const confirmed = confirm('This will delete ALL duplicate registrations, keeping only the newest entry for each duplicate group. This action cannot be undone.\n\nAre you sure you want to continue?');
            if (!confirmed) return;
            
            const checkboxes = document.querySelectorAll('.duplicate-checkbox');
            if (checkboxes.length === 0) {
                showErrorMessage('No duplicates to delete.');
                return;
            }
            
            try {
                const batch = db.batch();
                checkboxes.forEach(checkbox => {
                    const regId = checkbox.getAttribute('data-id');
                    if (regId) {
                        batch.delete(db.collection('event-registrations').doc(regId));
                    }
                });
                
                await batch.commit();
                showSuccessMessage(`Successfully deleted ${checkboxes.length} duplicate registrations.`);
                
                // Refresh the view
                loadEventRegistrations();
                
            } catch (error) {
                console.error('Error deleting duplicates:', error);
                showErrorMessage('Error deleting duplicates. Please try again.');
            }
        }

        // Delete selected duplicates
        async function deleteSelectedDuplicates() {
            const selectedCheckboxes = document.querySelectorAll('.duplicate-checkbox:checked');
            
            if (selectedCheckboxes.length === 0) {
                showErrorMessage('Please select duplicates to delete.');
                return;
            }
            
            const confirmed = confirm(`Delete ${selectedCheckboxes.length} selected duplicate registrations? This action cannot be undone.`);
            if (!confirmed) return;
            
            try {
                const batch = db.batch();
                selectedCheckboxes.forEach(checkbox => {
                    const regId = checkbox.getAttribute('data-id');
                    if (regId) {
                        batch.delete(db.collection('event-registrations').doc(regId));
                    }
                });
                
                await batch.commit();
                showSuccessMessage(`Successfully deleted ${selectedCheckboxes.length} selected duplicates.`);
                
                // Refresh the duplicates view
                setTimeout(() => findAndShowDuplicates(), 500);
                
            } catch (error) {
                console.error('Error deleting selected duplicates:', error);
                showErrorMessage('Error deleting duplicates. Please try again.');
            }
        }

        // Select all duplicates
        function selectAllDuplicates() {
            document.querySelectorAll('.duplicate-checkbox').forEach(checkbox => {
                checkbox.checked = true;
            });
        }

        // Clear duplicate selections
        function clearDuplicateSelections() {
            document.querySelectorAll('.duplicate-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
        }

        // Helper function to safely format registration dates
        function formatRegistrationDate(data) {
            // Try multiple date fields for compatibility with different registration versions
            const dateFields = ['preferredDate', 'registrationDate', 'date'];
            
            for (const field of dateFields) {
                if (data[field]) {
                    try {
                        const date = new Date(data[field]);
                        if (!isNaN(date.getTime())) {
                            return date.toLocaleDateString();
                        }
                    } catch (e) {
                        console.warn(`Invalid ${field}:`, data[field]);
                    }
                }
            }
            
            // Fallback to submittedAt timestamp
            if (data.submittedAt) {
                try {
                    if (data.submittedAt.toDate) {
                        // Firestore timestamp
                        return data.submittedAt.toDate().toLocaleDateString();
                    } else {
                        // Regular date
                        const date = new Date(data.submittedAt);
                        if (!isNaN(date.getTime())) {
                            return date.toLocaleDateString();
                        }
                    }
                } catch (e) {
                    console.warn('Invalid submittedAt:', data.submittedAt);
                }
            }
            
            return 'No Date';
        }

        // Data integrity verification function
        async function verifyDataIntegrity() {
            console.log('üîç Verifying data integrity...');
            
            try {
                const collections = [
                    'visits',
                    'info-sessions', 
                    'fingerprints',
                    'badges',
                    'new-hire-orientations',
                    'event-registrations',
                    'document-completions',
                    'staff'
                ];
                
                const results = {};
                
                for (const collectionName of collections) {
                    const snapshot = await db.collection(collectionName).get();
                    results[collectionName] = snapshot.size;
                    console.log(`üìä ${collectionName}: ${snapshot.size} documents`);
                }
                
                console.log('‚úÖ Data integrity check completed:', results);
                return results;
                
            } catch (error) {
                console.error('‚ùå Error checking data integrity:', error);
                return null;
            }
        }

        // Auto-run data integrity check on page load (for admins)
        function initDataIntegrityCheck() {
            // Only run for staff/admin users
            if (currentUser && document.getElementById('staff-dashboard')) {
                setTimeout(verifyDataIntegrity, 3000);
            }
        }

        // Load event registration form - visitor-only view
        function loadEventRegistrationForm(recruiterId) {
            console.log('Loading event form for recruiter ID:', recruiterId);
            
            // Hide all navigation and other elements for visitors (but keep screens available)
            document.querySelectorAll('.nav-buttons, .dashboard-section').forEach(element => {
                element.style.display = 'none';
            });
            
            // Hide all screens first, then show the registration form using the standard showScreen method
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
                screen.style.display = ''; // Remove any inline display styles
            });
            
            // Use the standard showScreen method to show the registration form
            const eventForm = document.getElementById('event-registration-form');
            eventForm.classList.add('active');
            
            // Ensure success screen is also available (remove any hidden styles)
            const successScreen = document.getElementById('event-registration-success');
            if (successScreen) {
                successScreen.style.display = '';
                console.log('‚úÖ Success screen prepared and available');
            }
            
            // Set form data
            document.getElementById('event-form-title').textContent = 'Event Registration';
            document.getElementById('event-form-subtitle').textContent = 'Please fill out the form below to register for this event';
            document.getElementById('event-form-subtitle').innerHTML = 'Please fill out the form below to register for this event';
            eventForm.setAttribute('data-recruiter-id', recruiterId);
            
            // Load event details in background
            if (typeof db !== 'undefined') {
                loadEventDetailsAsync(recruiterId);
            }
        }
        
        // Load event details asynchronously
        async function loadEventDetailsAsync(recruiterId) {
            try {
                const recruiterSnapshot = await db.collection('staff').doc(recruiterId).get();
                
                if (recruiterSnapshot.exists) {
                    const recruiterData = recruiterSnapshot.data();
                    
                    let eventSnapshot = await db.collection('recruiter-events')
                        .where('recruiterEmail', '==', recruiterData.email)
                        .get();
                    
                    let eventName = recruiterData.name + "'s Recruitment Event";
                    
                    if (!eventSnapshot.empty) {
                        eventName = eventSnapshot.docs[0].data().eventName;
                    } else {
                        // Create event
                        const eventData = {
                            recruiterId: recruiterId,
                            recruiterEmail: recruiterData.email,
                            recruiterName: recruiterData.name,
                            eventName: eventName,
                            address: "5600 W. Cermak Rd., Cicero, IL 60804",
                            createdAt: new Date().toISOString()
                        };
                        await db.collection('recruiter-events').add(eventData);
                    }
                    
                    document.getElementById('event-form-title').textContent = eventName;
                }
            } catch (error) {
                console.error('Error loading event details:', error);
            }
        }

        // Reset event registration form
        function resetEventRegistrationForm() {
            document.getElementById('event-name').value = '';
            document.getElementById('event-email').value = '';
            document.getElementById('event-phone').value = '';
            document.getElementById('event-zipcode').value = '';
            document.getElementById('event-candidate-type').value = '';
            document.getElementById('event-english').checked = false;
            document.getElementById('event-college-credits').checked = false;
        }

        // Submit event registration
        async function submitEventRegistration(event) {
            event.preventDefault();
            
            try {
                const recruiterId = document.getElementById('event-registration-form').getAttribute('data-recruiter-id');
                console.log('Form recruiterId from attribute:', recruiterId);
                const name = document.getElementById('event-name').value.trim();
                const email = document.getElementById('event-email').value.trim();
                const phone = document.getElementById('event-phone').value.trim();
                const zipcode = document.getElementById('event-zipcode').value.trim();
                const candidateType = document.getElementById('event-candidate-type').value;
                const englishSpeaker = document.getElementById('event-english').checked;
                const hasCredits = document.getElementById('event-college-credits').checked;
                
                // Auto-generate current date and time
                const now = new Date();
                const registrationDate = now.toISOString().split('T')[0];
                const registrationTime = now.toLocaleString();
                
                console.log('Form values:', { name, email, phone, zipcode, candidateType, englishSpeaker, hasCredits, registrationDate });
                
                if (!name || !email || !phone || !zipcode || !candidateType) {
                    showErrorMessage('Please fill in all required fields.');
                    return;
                }
                
                const registrationData = {
                    recruiterId: recruiterId,
                    name: name,
                    email: email,
                    phone: phone,
                    zipcode: zipcode,
                    date: registrationDate,
                    registrationDate: registrationDate,
                    registrationTime: registrationTime,
                    candidateType: candidateType,
                    speaksEnglish: englishSpeaker,
                    has60Credits: hasCredits,
                    assignedTo: recruiterId, // Initially assigned to the event owner
                    status: 'pending',
                    submittedAt: new Date().toISOString(),
                    timestamp: new Date().toISOString()
                };
                
                console.log('Submitting registration data:', registrationData);
                
                const docRef = await db.collection('event-registrations').add(registrationData);
                
                console.log('‚úÖ Event registration saved successfully with ID:', docRef.id);
                console.log('üìä Registration data saved:', registrationData);
                
                // Update success screen with registration details
                const successElements = {
                    'success-name': name,
                    'success-email': email,
                    'success-phone': phone,
                    'success-zipcode': zipcode,
                    'success-date': new Date(registrationDate).toLocaleDateString(),
                    'success-candidate-type': candidateType === 'new-hire' ? 'New Hire' : 'Reactivation',
                    'success-english': englishSpeaker ? 'Yes' : 'No',
                    'success-credits': hasCredits ? 'Yes' : 'No'
                };
                
                // Check if all elements exist before updating
                for (const [elementId, value] of Object.entries(successElements)) {
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.textContent = value;
                        console.log(`‚úÖ Updated ${elementId} with: ${value}`);
                    } else {
                        console.error(`‚ùå Element ${elementId} not found!`);
                    }
                }
                
                console.log('üîÑ Calling showScreen for event-registration-success');
                showScreen('event-registration-success');
                
            } catch (error) {
                console.error('Error submitting event registration:', error);
                showErrorMessage('Error submitting registration. Please try again.');
            }
        }

        // Load event data for recruiter dashboard
        async function loadEventData() {
            if (!currentUser) return;
            
            try {
                // Get or create staff info
                const { staffData, staffId } = await getStaffRecord();
                
                // Get or create recruiter's permanent event
                let eventSnapshot = await db.collection('recruiter-events')
                    .where('recruiterEmail', '==', currentUser.email)
                    .get();
                
                if (eventSnapshot.empty) {
                    // Create permanent event for this recruiter
                    const defaultEventData = {
                        recruiterId: staffId,
                        recruiterEmail: currentUser.email,
                        recruiterName: staffData.name,
                        eventName: staffData.name + "'s Recruitment Event",
                        address: "5600 W. Cermak Rd., Cicero, IL 60804",
                        createdAt: new Date().toISOString()
                    };
                    
                    await db.collection('recruiter-events').add(defaultEventData);
                    document.getElementById('event-name-input').value = defaultEventData.eventName;
                } else {
                    const eventData = eventSnapshot.docs[0].data();
                    document.getElementById('event-name-input').value = eventData.eventName || '';
                }
                
                // Load event statistics
                await loadEventStatistics();
                
                // Load registrations list
                console.log('About to load event registrations...');
                await loadEventRegistrations();
                console.log('Finished loading event registrations.');
                
                // Load other recruiters for assignment dropdown
                await loadRecruitersForAssignment();
                
            } catch (error) {
                console.error('Error loading event data:', error);
            }
        }

        // Load event statistics
        async function loadEventStatistics() {
            if (!currentUser) return;
            
            try {
                const staffSnapshot = await db.collection('staff')
                    .where('email', '==', currentUser.email)
                    .get();
                
                if (staffSnapshot.empty) return;
                
                const staffId = staffSnapshot.docs[0].id;
                
                // Get all registrations for this recruiter's event
                const registrations = await db.collection('event-registrations')
                    .where('recruiterId', '==', staffId)
                    .get();
                
                const totalRegistrations = registrations.size;
                let englishSpeakers = 0;
                let collegeCredits = 0;
                
                registrations.forEach(doc => {
                    const data = doc.data();
                    if (data.speaksEnglish) englishSpeakers++;
                    if (data.has60Credits) collegeCredits++;
                });
                
                document.getElementById('total-registrations').textContent = totalRegistrations;
                document.getElementById('english-speakers').textContent = englishSpeakers;
                document.getElementById('college-credits').textContent = collegeCredits;
                
            } catch (error) {
                console.error('Error loading event statistics:', error);
            }
        }

        // Load event registrations list
        // Global variable to store the real-time listener
        let eventRegistrationsListener = null;

        async function loadEventRegistrations() {
            console.log('loadEventRegistrations called, currentUser:', currentUser?.email);
            if (!currentUser) {
                console.log('No current user, returning');
                return;
            }
            
            try {
                const staffSnapshot = await db.collection('staff')
                    .where('email', '==', currentUser.email)
                    .get();
                
                if (staffSnapshot.empty) return;
                
                const staffId = staffSnapshot.docs[0].id;
                console.log('Setting up real-time registrations for staffId:', staffId);
                
                // Stop any existing listeners
                if (eventRegistrationsListener) {
                    if (Array.isArray(eventRegistrationsListener)) {
                        eventRegistrationsListener.forEach(unsubscribe => unsubscribe());
                    } else {
                        eventRegistrationsListener();
                    }
                    eventRegistrationsListener = null;
                }
                
                console.log('üîÑ Setting up dual real-time listeners for staffId:', staffId);
                
                // Set up TWO real-time listeners - one for each query
                const listeners = [];
                let registrationsData = new Map(); // Use Map to store and deduplicate
                
                const updateRegistrationsDisplay = () => {
                    const allRegistrations = Array.from(registrationsData.values());
                    const registrations = { docs: allRegistrations, empty: allRegistrations.length === 0, size: allRegistrations.length };
                    
                    console.log('üìä Updated display with', registrations.size, 'registrations');
                    
                    displayRegistrations(registrations, staffId);
                };
                
                // Listener 1: registrations where user is the recruiter
                const recruiterListener = db.collection('event-registrations')
                    .where('recruiterId', '==', staffId)
                    .onSnapshot((snapshot) => {
                        console.log('üîÑ Recruiter listener: received', snapshot.size, 'docs');
                        
                        // Handle changes
                        snapshot.docChanges().forEach(change => {
                            if (change.type === 'added' || change.type === 'modified') {
                                registrationsData.set(change.doc.id, change.doc);
                                console.log('‚úÖ Updated registration:', change.doc.data().name);
                            } else if (change.type === 'removed') {
                                registrationsData.delete(change.doc.id);
                                console.log('üóëÔ∏è Removed registration:', change.doc.data().name);
                            }
                        });
                        
                        updateRegistrationsDisplay();
                    }, (error) => {
                        console.error('‚ùå Recruiter listener error:', error);
                    });
                
                // Listener 2: registrations assigned to user
                const assignedListener = db.collection('event-registrations')
                    .where('assignedTo', '==', staffId)
                    .onSnapshot((snapshot) => {
                        console.log('üìã Assigned listener: received', snapshot.size, 'docs');
                        
                        // Handle changes
                        snapshot.docChanges().forEach(change => {
                            if (change.type === 'added' || change.type === 'modified') {
                                registrationsData.set(change.doc.id, change.doc);
                                console.log('‚úÖ Updated assigned registration:', change.doc.data().name);
                            } else if (change.type === 'removed') {
                                registrationsData.delete(change.doc.id);
                                console.log('üóëÔ∏è Removed assigned registration:', change.doc.data().name);
                            }
                        });
                        
                        updateRegistrationsDisplay();
                    }, (error) => {
                        console.error('‚ùå Assigned listener error:', error);
                    });
                
                // Store both listeners
                eventRegistrationsListener = [recruiterListener, assignedListener];
                
            } catch (error) {
                console.error('Error setting up event registrations listener:', error);
                const listContainer = document.getElementById('event-registrations-list');
                if (listContainer) {
                    listContainer.innerHTML = '<div class="visit-card" style="background: #ffe6e6; border: 1px solid red; padding: 10px;"><p>ERROR setting up real-time updates: ' + error.message + '</p></div>';
                }
            }
        }
        
        // Function to display registrations (extracted from listener)
        async function displayRegistrations(registrations, staffId) {
            const listContainer = document.getElementById('event-registrations-list');
            if (!listContainer) return;
            
            if (registrations.empty) {
                listContainer.innerHTML = '<div class="visit-card"><p style="text-align: center; color: #666;">No registrations yet.</p></div>';
                return;
            }
            
            try {
                // Group registrations by assigned recruiter
                const groupedRegistrations = {};
                const recruiterNames = {};
                
                // Get recruiter names first
                const allRecruiters = await db.collection('staff').where('team', '==', 'recruiting').get();
                allRecruiters.forEach(doc => {
                    recruiterNames[doc.id] = doc.data().name;
                });
                
                // Group registrations (handle separators specially)
                registrations.docs.forEach(doc => {
                    const data = doc.data();
                    
                    // Handle separator entries
                    if (data.type === 'separator') {
                        if (!groupedRegistrations['separators']) {
                            groupedRegistrations['separators'] = [];
                        }
                        groupedRegistrations['separators'].push({ doc, data });
                        return;
                    }
                    
                    const assignedToId = data.assignedTo || data.recruiterId;
                    
                    if (!groupedRegistrations[assignedToId]) {
                        groupedRegistrations[assignedToId] = [];
                    }
                    groupedRegistrations[assignedToId].push({ doc, data });
                });
                
                let html = '<div class="visit-card"><h4>üìù Event Registrations <span style="color: #28a745; font-size: 14px;">‚óè Live</span></h4>';
                
                // Add action buttons
                html += '<div style="margin-bottom: 15px;"><button class="btn btn-success" onclick="copyRegistrationsList()" style="margin-right: 10px;">üìã Copy All</button><button class="btn btn-success" onclick="exportEventLists()" style="margin-right: 10px; background: #28a745;">üìä Export to Excel</button><button class="btn btn-warning" onclick="findAndShowDuplicates()" style="margin-right: 10px; background: #ffc107; color: #212529;">üîç Find Duplicates</button><button class="btn btn-primary" onclick="saveEventAttendances()" style="margin-right: 10px;">üíæ Save My Event Attendances</button><button class="btn btn-danger" onclick="clearMyEventRegistrations()">üóëÔ∏è Clear All Data</button></div>';
                
                // Show separators first if they exist
                if (groupedRegistrations['separators']) {
                    html += '<div style="margin-bottom: 25px;">';
                    groupedRegistrations['separators'].forEach(({ doc, data }) => {
                        html += `<div style="text-align: center; padding: 15px; background: linear-gradient(135deg, #ff6b6b, #feca57); color: white; font-weight: bold; font-size: 16px; border-radius: 8px; margin-bottom: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            üìç ${data.message}
                            <div style="font-size: 12px; opacity: 0.9; margin-top: 5px;">Changed at: ${new Date(data.timestamp).toLocaleString()}</div>
                        </div>`;
                    });
                    html += '</div>';
                    delete groupedRegistrations['separators']; // Remove from regular processing
                }
                
                // Create grouped sections by recruiter
                Object.keys(groupedRegistrations).forEach(recruiterId => {
                    const recruiterName = recruiterNames[recruiterId] || 'Unknown Recruiter';
                    const isYou = recruiterId === staffId;
                    const groupName = isYou ? `${recruiterName} (You)` : recruiterName;
                    const registrationsForRecruiter = groupedRegistrations[recruiterId];
                    
                    html += `
                        <div style="margin-bottom: 25px; border: 2px solid ${isYou ? '#007bff' : '#28a745'}; border-radius: 8px; overflow: hidden;">
                            <div style="background: ${isYou ? '#007bff' : '#28a745'}; color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center;">
                                <h5 style="margin: 0; font-size: 16px;">üë§ ${groupName} (${registrationsForRecruiter.length})</h5>
                                <button class="btn" onclick="copyRecruiterList('${recruiterId}')" style="background: white; color: ${isYou ? '#007bff' : '#28a745'}; border: none; padding: 8px 15px; border-radius: 4px; font-size: 12px;">üìã Copy This List</button>
                            </div>
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: #f8f9fa;">
                                        <th style="padding: 10px; text-align: left; border-right: 1px solid #ddd; width: 40px;">
                                            <input type="checkbox" onclick="toggleRecruiterGroup('${recruiterId}', this)" style="transform: scale(1.1);">
                                        </th>
                                        <th style="padding: 10px; text-align: left; border-right: 1px solid #ddd;">Name</th>
                                        <th style="padding: 10px; text-align: left; border-right: 1px solid #ddd;">Email</th>
                                        <th style="padding: 10px; text-align: left; border-right: 1px solid #ddd;">Phone</th>
                                        <th style="padding: 10px; text-align: left; border-right: 1px solid #ddd;">Zip Code</th>
                                        <th style="padding: 10px; text-align: left; border-right: 1px solid #ddd;">Date</th>
                                        <th style="padding: 10px; text-align: center; border-right: 1px solid #ddd;">Type</th>
                                        <th style="padding: 10px; text-align: center; border-right: 1px solid #ddd;">English</th>
                                        <th style="padding: 10px; text-align: center; border-right: 1px solid #ddd;">Credits</th>
                                        <th style="padding: 10px; text-align: center; width: 80px;">Action</th>
                                    </tr>
                                </thead>
                                <tbody>
                    `;
                    
                    // Process registrations for this recruiter
                    registrationsForRecruiter.forEach(({ doc, data }) => {
                        const preferredDate = formatRegistrationDate(data);
                        const candidateTypeDisplay = data.candidateType === 'new-hire' ? 'üÜï New' : data.candidateType === 'reactivation' ? 'üîÑ Reactivation' : 'N/A';
                        
                        html += `
                            <tr style="border-bottom: 1px solid #eee;">
                                <td style="padding: 12px; border-right: 1px solid #eee; text-align: center;">
                                    <input type="checkbox" class="registration-checkbox" data-recruiter="${recruiterId}" data-id="${doc.id}" style="transform: scale(1.2);">
                                </td>
                                <td style="padding: 12px; border-right: 1px solid #eee; font-weight: 500;">${data.name || 'No Name'}</td>
                                <td style="padding: 12px; border-right: 1px solid #eee;">${data.email || 'No Email'}</td>
                                <td style="padding: 12px; border-right: 1px solid #eee;">${data.phone || 'No Phone'}</td>
                                <td style="padding: 12px; border-right: 1px solid #eee;">${data.zipcode || 'No Zip'}</td>
                                <td style="padding: 12px; border-right: 1px solid #eee;">${preferredDate}</td>
                                <td style="padding: 12px; border-right: 1px solid #eee; text-align: center;">${candidateTypeDisplay}</td>
                                <td style="padding: 12px; border-right: 1px solid #eee; text-align: center;">${data.speaksEnglish ? '‚úÖ' : '‚ùå'}</td>
                                <td style="padding: 12px; border-right: 1px solid #eee; text-align: center;">${data.has60Credits ? '‚úÖ' : '‚ùå'}</td>
                                <td style="padding: 8px; text-align: center;">
                                    <button onclick="deleteEventRegistration('${doc.id}', '${data.name || 'Unknown'}')" 
                                            style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; font-size: 12px; cursor: pointer;"
                                            title="Delete this registration">
                                        üóëÔ∏è
                                    </button>
                                </td>
                            </tr>
                        `;
                    });
                    
                    html += '</tbody></table></div>';
                });
                
                // Add split section after all grouped tables
                html += `
                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 8px;">
                        <h5 style="margin: 0 0 15px 0;">üë• Manage Selected Registrations</h5>
                        <div style="margin-bottom: 15px;">
                            <button class="btn" onclick="selectAllRegistrations()">Select All</button>
                            <button class="btn" onclick="clearAllSelections()" style="margin-left: 10px;">Clear Selection</button>
                            <button class="btn btn-danger" onclick="deleteSelectedRegistrations()" style="margin-left: 10px; background: #dc3545; color: white;">üóëÔ∏è Delete Selected</button>
                        </div>
                        <div>
                            <h6 style="margin-bottom: 10px;">Assign to Recruiters:</h6>
                            <div id="recruiters-checkboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px;"></div>
                            <button class="btn btn-primary" onclick="assignSelectedToMultipleRecruiters()">Split Among Selected Recruiters</button>
                        </div>
                    </div>
                `;
                
                html += '</div>'; // Close main visit-card div
                listContainer.innerHTML = html;
                
                // Load recruiters for split functionality
                await loadRecruitersForSplit();
                
            } catch (error) {
                console.error('Error displaying registrations:', error);
                listContainer.innerHTML = '<div class="visit-card" style="background: #ffe6e6; border: 1px solid red; padding: 10px;"><p>ERROR displaying registrations: ' + error.message + '</p></div>';
            }
        }

        // Toggle all registrations checkbox
        function toggleAllRegistrations(checkbox) {
            const registrationCheckboxes = document.querySelectorAll('.registration-checkbox');
            registrationCheckboxes.forEach(cb => {
                cb.checked = checkbox.checked;
            });
        }

        // Toggle recruiter group checkbox
        function toggleRecruiterGroup(recruiterId, checkbox) {
            const groupCheckboxes = document.querySelectorAll(`[data-recruiter="${recruiterId}"]`);
            groupCheckboxes.forEach(cb => {
                cb.checked = checkbox.checked;
            });
        }

        // Copy specific recruiter list
        async function copyRecruiterList(recruiterId) {
            if (!currentUser) return;
            
            try {
                const recruiterDoc = await db.collection('staff').doc(recruiterId).get();
                const recruiterName = recruiterDoc.exists ? recruiterDoc.data().name : 'Unknown Recruiter';
                
                const registrations = await db.collection('event-registrations')
                    .where('assignedTo', '==', recruiterId)
                    .get();
                
                if (registrations.empty) {
                    showErrorMessage('No registrations for this recruiter.');
                    return;
                }
                
                let listText = `${recruiterName.toUpperCase()}'S REGISTRATIONS:\n\n`;
                let count = 1;
                
                registrations.forEach(doc => {
                    const data = doc.data();
                    const preferredDate = formatRegistrationDate(data);
                    const candidateType = data.candidateType === 'new-hire' ? 'New Hire' : data.candidateType === 'reactivation' ? 'Reactivation' : 'N/A';
                    
                    listText += `${count}. ${data.name}\n`;
                    listText += `   Email: ${data.email}\n`;
                    listText += `   Phone: ${data.phone}\n`;
                    listText += `   Date: ${preferredDate}\n`;
                    listText += `   Type: ${candidateType}\n`;
                    listText += `   English: ${data.speaksEnglish ? 'Yes' : 'No'}\n`;
                    listText += `   Credits: ${data.has60Credits ? 'Yes' : 'No'}\n\n`;
                    
                    count++;
                });
                
                // Copy to clipboard
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(listText);
                        showSuccessMessage(`${recruiterName}'s list copied to clipboard!`);
                    } else {
                        const textArea = document.createElement('textarea');
                        textArea.value = listText;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        showSuccessMessage(`${recruiterName}'s list copied to clipboard!`);
                    }
                } catch (clipboardError) {
                    alert('Copy this text:\n\n' + listText);
                }
                
            } catch (error) {
                console.error('Error copying recruiter list:', error);
                showErrorMessage('Error generating list. Please try again.');
            }
        }

        // Load recruiters for assignment checkboxes
        async function loadRecruitersForAssignment() {
            try {
                const recruiters = await db.collection('staff')
                    .where('team', '==', 'recruiting')
                    .get();
                
                const container = document.getElementById('recruiters-checkboxes');
                container.innerHTML = '';
                
                recruiters.forEach(doc => {
                    const data = doc.data();
                    const isCurrentUser = data.email === currentUser.email;
                    container.innerHTML += `
                        <label style="display: flex; align-items: center; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white;">
                            <input type="checkbox" class="recruiter-checkbox" data-id="${doc.id}" style="margin-right: 8px;">
                            <span>${data.name}${isCurrentUser ? ' (Me)' : ''}</span>
                        </label>
                    `;
                });
                
            } catch (error) {
                console.error('Error loading recruiters for assignment:', error);
            }
        }

        // Load recruiters for split functionality  
        async function loadRecruitersForSplit() {
            try {
                console.log('üîÑ Loading recruiters for split...');
                
                const recruiters = await db.collection('staff')
                    .where('team', '==', 'recruiting')
                    .get();
                
                console.log('üë• Found recruiters:', recruiters.size);
                
                const container = document.getElementById('recruiters-checkboxes');
                if (!container) {
                    console.log('‚ùå Container "recruiters-checkboxes" not found');
                    return;
                }
                
                container.innerHTML = '';
                
                recruiters.forEach(doc => {
                    const data = doc.data();
                    const isCurrentUser = currentUser && data.email === currentUser.email;
                    console.log('üë§ Adding recruiter:', data.name, isCurrentUser ? '(current user)' : '');
                    
                    container.innerHTML += `
                        <label style="display: flex; align-items: center; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;">
                            <input type="checkbox" class="recruiter-checkbox" data-id="${doc.id}" style="margin-right: 8px;" onchange="console.log('Recruiter checkbox changed:', this.checked, '${data.name}')">
                            <span>${data.name}${isCurrentUser ? ' (Me)' : ''}</span>
                        </label>
                    `;
                });
                
                console.log('‚úÖ Recruiters loaded successfully');
                
            } catch (error) {
                console.error('‚ùå Error loading recruiters for split:', error);
            }
        }

        // Select all registrations
        function selectAllRegistrations() {
            const checkboxes = document.querySelectorAll('.registration-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
        }

        // Clear all selections
        function clearAllSelections() {
            const checkboxes = document.querySelectorAll('.registration-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
        }

        // Assign selected registrations to multiple recruiters
        async function assignSelectedToMultipleRecruiters() {
            console.log('üîÑ assignSelectedToMultipleRecruiters called');
            
            const selectedRegistrations = document.querySelectorAll('.registration-checkbox:checked');
            const selectedRecruiters = document.querySelectorAll('.recruiter-checkbox:checked');
            
            console.log('üìù Selected registrations:', selectedRegistrations.length);
            console.log('üë• Selected recruiters:', selectedRecruiters.length);
            
            // Debug: Log the actual elements found
            console.log('Registration checkboxes found:', document.querySelectorAll('.registration-checkbox').length);
            console.log('Recruiter checkboxes found:', document.querySelectorAll('.recruiter-checkbox').length);
            
            if (selectedRegistrations.length === 0) {
                console.log('‚ùå No registrations selected');
                showErrorMessage('Please select registrations to assign.');
                return;
            }
            
            if (selectedRecruiters.length === 0) {
                console.log('‚ùå No recruiters selected');
                showErrorMessage('Please select at least one recruiter.');
                return;
            }
            
            console.log('‚úÖ Validation passed, proceeding with split...');
            
            try {
                const batch = db.batch();
                const recruiterIds = Array.from(selectedRecruiters).map(cb => cb.getAttribute('data-id'));
                
                // Distribute registrations evenly among selected recruiters
                Array.from(selectedRegistrations).forEach((checkbox, index) => {
                    const registrationId = checkbox.getAttribute('data-id');
                    const assignToId = recruiterIds[index % recruiterIds.length]; // Round robin distribution
                    
                    const registrationRef = db.collection('event-registrations').doc(registrationId);
                    batch.update(registrationRef, {
                        assignedTo: assignToId,
                        reassignedAt: new Date().toISOString()
                    });
                });
                
                await batch.commit();
                showSuccessMessage(`Successfully split ${selectedRegistrations.length} registrations among ${selectedRecruiters.length} recruiters!`);
                
                // Clear selections
                document.querySelectorAll('.registration-checkbox').forEach(cb => cb.checked = false);
                document.querySelectorAll('.recruiter-checkbox').forEach(cb => cb.checked = false);
                clearAllSelections();
                document.querySelectorAll('.recruiter-checkbox').forEach(cb => cb.checked = false);
                
                // Reload the list
                await loadEventRegistrations();
                await loadEventStatistics();
                
            } catch (error) {
                console.error('Error splitting registrations:', error);
                showErrorMessage('Error splitting registrations. Please try again.');
            }
        }

        // Save event attendances with 7-day retention
        async function saveEventAttendances() {
            if (!currentUser) return;
            
            try {
                const { staffData, staffId } = await getStaffRecord();
                const today = new Date().toISOString().split('T')[0];
                const timestamp = new Date().toISOString();
                
                // Get current event registrations
                const registrationsSnapshot = await db.collection('event-registrations')
                    .where('recruiterId', '==', staffId)
                    .get();
                
                if (registrationsSnapshot.empty) {
                    showErrorMessage('No event registrations found to save.');
                    return;
                }
                
                // Prepare attendances data
                const attendancesData = [];
                registrationsSnapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.type !== 'separator') {
                        attendancesData.push({
                            originalId: doc.id,
                            name: data.name,
                            email: data.email,
                            phone: data.phone,
                            zipcode: data.zipcode,
                            eventName: data.eventName,
                            candidateType: data.candidateType,
                            speaksEnglish: data.speaksEnglish,
                            has60Credits: data.has60Credits,
                            preferredStartDate: data.preferredStartDate,
                            registeredAt: data.createdAt || data.timestamp,
                            savedAt: timestamp
                        });
                    }
                });
                
                // Save to event-attendances collection with 7-day retention
                const attendanceRecord = {
                    recruiterEmail: currentUser.email,
                    recruiterId: staffId,
                    recruiterName: staffData.name,
                    eventName: staffData.name + "'s Recruitment Event",
                    date: today,
                    timestamp: timestamp,
                    totalAttendees: attendancesData.length,
                    attendees: attendancesData,
                    retentionDays: 7,
                    expiresAt: new Date(Date.now() + (7 * 24 * 60 * 60 * 1000)), // 7 days from now
                    createdAt: new Date().toISOString()
                };
                
                // Save the attendance record
                const attendanceRef = await db.collection('event-attendances').add(attendanceRecord);
                
                // Clean up old attendance records (older than 7 days)
                const sevenDaysAgo = new Date(Date.now() - (7 * 24 * 60 * 60 * 1000));
                const oldRecords = await db.collection('event-attendances')
                    .where('recruiterEmail', '==', currentUser.email)
                    .where('expiresAt', '<', sevenDaysAgo)
                    .get();
                
                // Delete expired records
                const batch = db.batch();
                oldRecords.forEach(doc => {
                    batch.delete(doc.ref);
                });
                
                if (!oldRecords.empty) {
                    await batch.commit();
                    console.log(`üóëÔ∏è Cleaned up ${oldRecords.size} expired attendance records`);
                }
                
                showSuccessMessage(`‚úÖ Event attendances saved! Total: ${attendancesData.length} attendees. Will be kept for 7 days.`);
                console.log('üíæ Event attendances saved:', attendanceRef.id, 'Total attendees:', attendancesData.length);
                
            } catch (error) {
                console.error('Error saving event attendances:', error);
                showErrorMessage('Error saving event attendances. Please try again.');
            }
        }

        // Clear all event registrations
        async function clearAllEventRegistrations() {
            if (!currentUser) return;
            
            if (!confirm('Are you sure you want to delete ALL event registrations? This action cannot be undone.')) {
                return;
            }
            
            try {
                const staffSnapshot = await db.collection('staff')
                    .where('email', '==', currentUser.email)
                    .get();
                
                if (staffSnapshot.empty) return;
                
                const staffId = staffSnapshot.docs[0].id;
                
                // Get all registrations for this recruiter's event
                const registrations = await db.collection('event-registrations')
                    .where('recruiterId', '==', staffId)
                    .get();
                
                if (registrations.empty) {
                    showSuccessMessage('No registrations to clear.');
                    return;
                }
                
                // Delete all registrations in batch
                const batch = db.batch();
                registrations.forEach(doc => {
                    batch.delete(doc.ref);
                });
                
                await batch.commit();
                showSuccessMessage(`Cleared ${registrations.size} registration(s) successfully!`);
                
                // Reload data
                await loadEventStatistics();
                await loadEventRegistrations();
                
            } catch (error) {
                console.error('Error clearing event registrations:', error);
                showErrorMessage('Error clearing registrations. Please try again.');
            }
        }

        // Export event lists to Excel
        async function exportEventLists() {
            if (!currentUser) return;
            
            try {
                // Get all recruiters
                const recruiters = await db.collection('staff')
                    .where('team', '==', 'recruiting')
                    .get();
                
                // Get all registrations for this event
                const staffSnapshot = await db.collection('staff')
                    .where('email', '==', currentUser.email)
                    .get();
                
                if (staffSnapshot.empty) return;
                
                const staffId = staffSnapshot.docs[0].id;
                const staffData = staffSnapshot.docs[0].data();
                
                const registrations = await db.collection('event-registrations')
                    .where('recruiterId', '==', staffId)
                    .get();
                
                if (registrations.empty) {
                    showErrorMessage('No registrations found to export.');
                    return;
                }
                
                // Group registrations by assigned recruiter
                const recruiterLists = {};
                const recruiterNames = {};
                
                recruiters.forEach(doc => {
                    const recruiterData = doc.data();
                    recruiterNames[doc.id] = recruiterData.name;
                    recruiterLists[doc.id] = {
                        name: recruiterData.name,
                        email: recruiterData.email,
                        registrations: []
                    };
                });
                
                // Filter out separators and group by recruiter
                registrations.forEach(doc => {
                    const data = doc.data();
                    if (data.type !== 'separator') {
                        const assignedToId = data.assignedTo || data.recruiterId;
                        if (recruiterLists[assignedToId]) {
                            recruiterLists[assignedToId].registrations.push(data);
                        }
                    }
                });
                
                // Create CSV data for Excel
                let csvContent = '\uFEFF'; // UTF-8 BOM for proper encoding
                
                // Create a summary sheet first
                csvContent += `Event Attendees Export\n`;
                csvContent += `Generated,${new Date().toLocaleString()}\n`;
                csvContent += `Event Owner,${staffData.name} (${currentUser.email})\n`;
                csvContent += `Total Attendees,${registrations.size - (registrations.docs.filter(d => d.data().type === 'separator').length)}\n\n`;
                
                // Add detailed data grouped by recruiter
                Object.entries(recruiterLists).forEach(([recruiterId, recruiter]) => {
                    if (recruiter.registrations.length > 0) {
                        csvContent += `\n=== ${recruiter.name} (${recruiter.registrations.length} attendees) ===\n`;
                        csvContent += `Name,Email,Phone,Zip Code,Preferred Date,Candidate Type,English Speaker,60+ Credits\n`;
                        
                        recruiter.registrations.forEach(reg => {
                            const name = (reg.name || '').replace(/,/g, ';');
                            const email = reg.email || '';
                            const phone = reg.phone || '';
                            const zipcode = reg.zipcode || '';
                            const preferredDate = formatRegistrationDate(reg);
                            const candidateType = reg.candidateType === 'new-hire' ? 'New Hire' : 
                                                reg.candidateType === 'reactivation' ? 'Reactivation' : 'N/A';
                            const speaksEnglish = reg.speaksEnglish ? 'Yes' : 'No';
                            const has60Credits = reg.has60Credits ? 'Yes' : 'No';
                            
                            csvContent += `"${name}","${email}","${phone}","${zipcode}","${preferredDate}","${candidateType}","${speaksEnglish}","${has60Credits}"\n`;
                        });
                        
                        csvContent += `\n`;
                    }
                });
                
                // Create and download the file
                const eventName = staffData.name.replace(/[^a-zA-Z0-9]/g, '_');
                const today = new Date().toISOString().split('T')[0];
                const filename = `Event_Attendees_${eventName}_${today}.csv`;
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showSuccessMessage(`üìä Excel file downloaded: ${filename}`);
                console.log('üìä Event attendees exported to Excel:', filename);
                
            } catch (error) {
                console.error('Error exporting event lists:', error);
                showErrorMessage('Error exporting to Excel. Please try again.');
            }
        }

        // Old Visits Archive Functions
        
        // Load old visits for a specific date
        async function loadOldVisitsForDate() {
            const selectedDate = document.getElementById('archive-date-select').value;
            if (!selectedDate) return;
            
            try {
                const archiveDoc = await db.collection('daily-archives').doc(selectedDate).get();
                const contentDiv = document.getElementById('old-visits-content');
                
                if (!archiveDoc.exists) {
                    contentDiv.innerHTML = '<p style="text-align: center; color: #666;">No archived data found for this date</p>';
                    return;
                }
                
                const archiveData = archiveDoc.data();
                let html = `<h4>Archive for ${new Date(selectedDate).toLocaleDateString()}</h4>`;
                
                // Display each category
                const categories = [
                    { key: 'visits', title: 'üë• Visits', icon: 'üìù' },
                    { key: 'badges', title: 'üé´ Badges', icon: 'üé´' },
                    { key: 'fingerprints', title: 'üëÜ Fingerprints', icon: 'üëÜ' },
                    { key: 'infoSessions', title: 'üìö Info Sessions', icon: 'üìö' },
                    { key: 'newHireOrientations', title: 'üéØ New Hire Orientations', icon: 'üéØ' }
                ];
                
                categories.forEach(category => {
                    const data = archiveData[category.key] || [];
                    html += `
                        <div style="margin-bottom: 30px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">
                            <div style="background: #f8f9fa; padding: 15px; border-bottom: 1px solid #ddd;">
                                <h5 style="margin: 0;">${category.icon} ${category.title} (${data.length})</h5>
                            </div>
                    `;
                    
                    if (data.length === 0) {
                        html += '<div style="padding: 20px; text-align: center; color: #666;">No records</div>';
                    } else {
                        html += '<div style="padding: 15px;"><table style="width: 100%; border-collapse: collapse;">';
                        html += '<thead><tr style="background: #f8f9fa;"><th style="padding: 10px; text-align: left; border: 1px solid #ddd;">Name</th><th style="padding: 10px; text-align: left; border: 1px solid #ddd;">Email</th><th style="padding: 10px; text-align: left; border: 1px solid #ddd;">Date</th><th style="padding: 10px; text-align: left; border: 1px solid #ddd;">Details</th></tr></thead><tbody>';
                        
                        data.forEach(record => {
                            const date = record.submittedAt ? new Date(record.submittedAt.seconds * 1000).toLocaleDateString() : 'N/A';
                            const details = record.department || record.purpose || record.sessionDate || 'N/A';
                            html += `
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;">${record.name || 'N/A'}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">${record.email || 'N/A'}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">${date}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">${details}</td>
                                </tr>
                            `;
                        });
                        
                        html += '</tbody></table></div>';
                    }
                    
                    html += '</div>';
                });
                
                contentDiv.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading old visits:', error);
                document.getElementById('old-visits-content').innerHTML = '<p style="color: red;">Error loading archived data</p>';
            }
        }
        
        // Load today's archives
        function loadTodaysOldVisits() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('archive-date-select').value = today;
            loadOldVisitsForDate();
        }
        
        // Load yesterday's archives
        function loadYesterdaysOldVisits() {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = yesterday.toISOString().split('T')[0];
            document.getElementById('archive-date-select').value = yesterdayStr;
            loadOldVisitsForDate();
        }
        
        // Daily archive function (to be called at 6 AM)
        async function performDailyArchive() {
            // For automatic archives, allow anyone, for manual archives, require admin
            if (arguments.length > 0 && (!currentUser || !isAdmin)) return;
            
            try {
                const today = new Date().toISOString().split('T')[0];
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toISOString().split('T')[0];
                
                // Collect data from all collections
                const collections = [
                    { name: 'visits', key: 'visits' },
                    { name: 'badges', key: 'badges' },
                    { name: 'fingerprints', key: 'fingerprints' },
                    { name: 'info-sessions', key: 'infoSessions' },
                    { name: 'new-hire-orientations', key: 'newHireOrientations' }
                ];
                const archiveData = {};
                
                for (const collection of collections) {
                    const snapshot = await db.collection(collection.name).get();
                    archiveData[collection.key] = [];
                    
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        archiveData[collection.key].push({
                            id: doc.id,
                            ...data
                        });
                    });
                }
                
                // Save to daily archive
                await db.collection('daily-archives').doc(yesterdayStr).set(archiveData);
                
                // IMPORTANT: Do NOT delete records, just archive them for statistics
                // Records will remain in their original collections permanently
                // Info Sessions will filter by date to show only recent ones
                console.log('üìÅ Daily archive completed for:', yesterdayStr, '- Records preserved in original collections');
                showSuccessMessage('Backup archive created successfully - All original records remain preserved permanently');
                
            } catch (error) {
                console.error('Error performing daily archive:', error);
                showErrorMessage('Error performing daily archive: ' + error.message);
            }
        }
        
        // DISABLED: Daily archive functionality has been disabled
        // Records will now be preserved permanently without automatic deletion
        function checkDailyArchive() {
            // Function disabled - no automatic archiving will occur
            console.log('Daily archive check disabled - records preserved permanently');
        }
        
        // DISABLED: Automatic archive scheduling has been removed
        // setInterval(checkDailyArchive, 60 * 60 * 1000); // DISABLED
        
        // DISABLED: Page load archive check has been removed
        // window.addEventListener('load', checkDailyArchive); // DISABLED
        
        // Admin functions for manual archive
        function confirmManualArchive() {
            if (confirm('Create a backup archive of current data? All original records will remain preserved in their collections. This is just for backup purposes.')) {
                performDailyArchive();
            }
        }
        
        // Check archive status
        async function checkArchiveStatus() {
            try {
                const lastArchiveDate = localStorage.getItem('lastArchiveDate');
                const statusElement = document.getElementById('last-archive-info');
                
                if (lastArchiveDate) {
                    statusElement.innerHTML = `Last automatic archive: ${new Date(lastArchiveDate).toLocaleDateString()}`;
                } else {
                    statusElement.innerHTML = 'No automatic archive recorded yet';
                }
                
                // Check if there are recent archives
                const today = new Date().toISOString().split('T')[0];
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toISOString().split('T')[0];
                
                const todayArchive = await db.collection('daily-archives').doc(today).get();
                const yesterdayArchive = await db.collection('daily-archives').doc(yesterdayStr).get();
                
                let archiveInfo = statusElement.innerHTML;
                archiveInfo += '<br><br><strong>Recent Archives:</strong><br>';
                archiveInfo += `Today (${today}): ${todayArchive.exists ? '‚úÖ Exists' : '‚ùå No archive'}<br>`;
                archiveInfo += `Yesterday (${yesterdayStr}): ${yesterdayArchive.exists ? '‚úÖ Exists' : '‚ùå No archive'}`;
                
                statusElement.innerHTML = archiveInfo;
                
            } catch (error) {
                console.error('Error checking archive status:', error);
                document.getElementById('last-archive-info').innerHTML = 'Error checking status';
            }
        }

        // ===== QUEUE MANAGEMENT FUNCTIONS =====
        
        // Load queue management information
        async function loadQueueManagement() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const statusDiv = document.getElementById('queue-status-info');
                
                console.log('üî¢ Loading queue management for date:', today);
                
                // Get current queue counter
                const counterDoc = await db.collection('daily-counters').doc(today).get();
                let currentQueueNumber = 0;
                
                if (counterDoc.exists) {
                    currentQueueNumber = counterDoc.data().lastQueueNumber || 0;
                }
                
                // Get today's document completions count
                const completionsSnapshot = await db.collection('document-queue')
                    .where('date', '==', today)
                    .get();
                
                const totalCompletions = completionsSnapshot.size;
                const pendingCompletions = await db.collection('document-queue')
                    .where('date', '==', today)
                    .where('status', '==', 'pending-recruiter-contact')
                    .get();
                
                statusDiv.innerHTML = `
                    <strong>Today's Queue Status (${today}):</strong><br>
                    üî¢ Last Queue Number Used: <strong>${currentQueueNumber}</strong><br>
                    üìä Total Document Completions: <strong>${totalCompletions}</strong><br>
                    ‚è≥ Pending Completions: <strong>${pendingCompletions.size}</strong><br>
                    ‚úÖ Contacted Completions: <strong>${totalCompletions - pendingCompletions.size}</strong>
                `;
                
                console.log('‚úÖ Queue status loaded successfully');
                
            } catch (error) {
                console.error('‚ùå Error loading queue management:', error);
                document.getElementById('queue-status-info').innerHTML = 'Error loading queue status';
            }
        }
        
        // Confirm queue reset
        function confirmResetQueue() {
            const today = new Date().toLocaleDateString();
            if (confirm(`‚ö†Ô∏è Are you sure you want to reset today's queue numbers back to 1?\n\nThis will affect all NEW document completions submitted after this reset.\n\nToday's date: ${today}`)) {
                resetQueueNumbers();
            }
        }
        
        // Reset queue numbers
        async function resetQueueNumbers() {
            try {
                const today = new Date().toISOString().split('T')[0];
                console.log('üîÑ Resetting queue numbers for:', today);
                
                showSuccessMessage('Resetting queue numbers...');
                
                // Reset the daily counter to 0 (next number will be 1)
                await db.collection('daily-counters').doc(today).set({
                    lastQueueNumber: 0,
                    date: today,
                    lastUpdated: new Date().toISOString(),
                    resetBy: 'admin',
                    resetAt: new Date().toISOString()
                }, { merge: true });
                
                console.log('‚úÖ Queue numbers reset successfully');
                showSuccessMessage('‚úÖ Queue numbers have been reset! Next document completion will start from #1.');
                
                // Refresh the queue status
                loadQueueManagement();
                
            } catch (error) {
                console.error('‚ùå Error resetting queue numbers:', error);
                showErrorMessage('Error resetting queue numbers. Please try again.');
            }
        }
        
        // Confirm clear completions
        function confirmClearCompletions() {
            const today = new Date().toLocaleDateString();
            if (confirm(`‚ö†Ô∏è DANGER: Are you sure you want to DELETE ALL document completions for today?\n\nThis action CANNOT be undone!\n\nToday's date: ${today}\n\nType 'DELETE' in the next prompt to confirm.`)) {
                const confirmation = prompt('Type "DELETE" to confirm this permanent action:');
                if (confirmation === 'DELETE') {
                    clearTodaysCompletions();
                } else {
                    showErrorMessage('Deletion cancelled - confirmation text did not match.');
                }
            }
        }
        
        // Clear today's document completions
        async function clearTodaysCompletions() {
            try {
                const today = new Date().toISOString().split('T')[0];
                console.log('üóëÔ∏è Clearing all document completions for:', today);
                
                showSuccessMessage('Deleting document completions...');
                
                // Get all today's completions
                const completionsSnapshot = await db.collection('document-queue')
                    .where('date', '==', today)
                    .get();
                
                if (completionsSnapshot.empty) {
                    showSuccessMessage('No document completions found for today.');
                    return;
                }
                
                // Delete in batches
                const batch = db.batch();
                let deleteCount = 0;
                
                completionsSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                    deleteCount++;
                });
                
                await batch.commit();
                
                // Also reset the queue counter
                await db.collection('daily-counters').doc(today).set({
                    lastQueueNumber: 0,
                    date: today,
                    lastUpdated: new Date().toISOString(),
                    clearedBy: 'admin',
                    clearedAt: new Date().toISOString()
                }, { merge: true });
                
                console.log(`‚úÖ Deleted ${deleteCount} document completions`);
                showSuccessMessage(`‚úÖ Successfully deleted ${deleteCount} document completions and reset queue numbers.`);
                
                // Refresh the queue status
                loadQueueManagement();
                
            } catch (error) {
                console.error('‚ùå Error clearing document completions:', error);
                showErrorMessage('Error clearing document completions. Please try again.');
            }
        }
        
        // ===== DEBUG FUNCTIONS =====
        
        // Debug function to check document completions status
        async function debugDocumentCompletions() {
            if (!currentUser) {
                console.log('‚ùå No current user logged in');
                return;
            }
            
            console.log('üîç DEBUG: Document Completions Status');
            console.log('==========================================');
            console.log('üë§ Current user:', currentUser.email);
            
            try {
                const today = new Date().toISOString().split('T')[0];
                console.log('üìÖ Today\'s date:', today);
                
                // Check button visibility
                const button = document.getElementById('document-completions-btn');
                const indicator = document.getElementById('completions-indicator');
                
                console.log('üî≤ Button exists:', !!button);
                console.log('üî≤ Button visible:', button ? button.style.display : 'N/A');
                console.log('üî≤ Indicator exists:', !!indicator);
                console.log('üî≤ Indicator visible:', indicator ? indicator.style.display : 'N/A');
                
                // Check completions in database
                const completionsSnapshot = await db.collection('document-queue')
                    .where('date', '==', today)
                    .get();
                
                console.log('üìä Total completions today:', completionsSnapshot.size);
                
                let myAssigned = 0;
                let otherAssigned = 0;
                
                completionsSnapshot.forEach((doc, index) => {
                    const completion = doc.data();
                    const isMine = completion.recruiterEmail === currentUser.email;
                    
                    console.log(`üìã Completion ${index + 1}:`);
                    console.log('   Name:', completion.name);
                    console.log('   Queue:', completion.queueNumber);
                    console.log('   Assigned to:', completion.recruiterEmail);
                    console.log('   Status:', completion.status);
                    console.log('   Is mine:', isMine);
                    console.log('   Documents:', completion.documents);
                    
                    if (isMine) {
                        myAssigned++;
                    } else {
                        otherAssigned++;
                    }
                });
                
                console.log('üî¢ Summary:');
                console.log('   My assigned:', myAssigned);
                console.log('   Others assigned:', otherAssigned);
                console.log('==========================================');
                
                return {
                    totalCompletions: completionsSnapshot.size,
                    myAssigned: myAssigned,
                    otherAssigned: otherAssigned
                };
                
            } catch (error) {
                console.error('‚ùå Debug error:', error);
            }
        }
        
        // Make debug function globally available
        window.debugDocumentCompletions = debugDocumentCompletions;
        
        // Force show document completions button (for debugging)
        function forceShowDocumentCompletionsButton() {
            console.log('üîß FORCE SHOWING Document Completions Button');
            
            const button = document.getElementById('document-completions-btn');
            const indicator = document.getElementById('completions-indicator');
            
            if (button) {
                button.style.display = 'block';
                button.style.visibility = 'visible';
                button.style.opacity = '1';
                console.log('‚úÖ Button forced to show');
                
                // Also set up the listener
                setupDocumentCompletionsListener();
                console.log('‚úÖ Listener set up');
                
                // Load completions
                loadDocumentCompletions();
                console.log('‚úÖ Completions loaded');
                
                return true;
            } else {
                console.error('‚ùå Button not found in DOM');
                return false;
            }
        }
        
        // Make force function globally available
        window.forceShowDocumentCompletionsButton = forceShowDocumentCompletionsButton;
        
        // Also check if user is recruiter
        function checkUserPermissions() {
            if (!currentUser) {
                console.log('‚ùå No user logged in');
                return;
            }
            
            console.log('üë§ Current user:', currentUser.email);
            
            // Check staff record
            db.collection('staff').where('email', '==', currentUser.email).get().then(snapshot => {
                console.log('üë§ Staff records found:', snapshot.size);
                
                snapshot.forEach(doc => {
                    const staff = doc.data();
                    console.log('üë§ Staff data:', staff);
                });
            });
        }
        
        window.checkUserPermissions = checkUserPermissions;
        
        // Force load document completions in My Status (for debugging)
        function forceLoadStatusCompletions() {
            console.log('üîß FORCING load of document completions in My Status');
            
            // First check if elements exist
            const statusSection = document.getElementById('recruiter-status');
            const completionsList = document.getElementById('status-document-completions-list');
            const indicator = document.getElementById('status-completions-indicator');
            
            console.log('üîç Element check:');
            console.log('   Status section exists:', !!statusSection);
            console.log('   Completions list exists:', !!completionsList);
            console.log('   Indicator exists:', !!indicator);
            
            if (!currentUser) {
                console.log('‚ùå No current user - please login first');
                return;
            }
            
            // Force call the function
            loadDocumentCompletionsForStatus();
            
            // Also show the My Status section
            if (statusSection) {
                showDashboardSection('recruiter-status');
                console.log('‚úÖ Forced My Status section to show');
            }
            
            return 'Function executed - check console for results';
        }
        
        window.forceLoadStatusCompletions = forceLoadStatusCompletions;
        
        // Create test document completion for debugging
        async function createTestCompletion() {
            if (!currentUser) {
                console.log('‚ùå Please login first');
                return;
            }
            
            console.log('üß™ Creating test document completion assigned to you...');
            
            const today = new Date().toISOString().split('T')[0];
            const testCompletion = {
                type: 'document-completion',
                name: 'Test Candidate ' + Math.floor(Math.random() * 1000),
                queueNumber: Math.floor(Math.random() * 100) + 1,
                assignedRecruiter: currentUser.displayName || 'Test Recruiter',
                recruiterEmail: currentUser.email,
                recruiterId: 'test-id',
                documents: {
                    ob365: true,
                    drugScreening: true,
                    i9: true,
                    fingerprintsAccount: Math.random() > 0.5
                },
                status: 'pending-recruiter-contact',
                timestamp: new Date().toISOString(),
                date: today,
                completedAt: new Date().toLocaleString()
            };
            
            try {
                const docRef = await db.collection('document-queue').add(testCompletion);
                console.log('‚úÖ Test completion created with ID:', docRef.id);
                console.log('üìã Test data:', testCompletion);
                return 'Test completion created successfully!';
            } catch (error) {
                console.error('‚ùå Error creating test completion:', error);
                return 'Error creating test completion';
            }
        }
        
        window.createTestCompletion = createTestCompletion;
        
        // ===== SIMPLE DOCUMENT COMPLETIONS (ALWAYS WORKS) =====
        
        // Load simple document completions for ANY logged in user
        async function loadSimpleDocumentCompletions() {
            // Don't start listeners on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Skipping loadSimpleDocumentCompletions on document-completion page');
                return;
            }
            
            console.log('üéÜ ===== LOADING SIMPLE DOCUMENT COMPLETIONS =====');
            console.log('üéÜ Current user:', currentUser ? currentUser.email : 'None');
            
            const completionsList = document.getElementById('simple-completions-display');
            const countIndicator = document.getElementById('simple-completions-count');
            const navIndicator = document.getElementById('simple-nav-indicator');
            
            if (!completionsList) {
                console.error('‚ùå Simple completions list element not found!');
                return;
            }
            
            completionsList.innerHTML = '<p style="text-align: center; color: #666; padding: 40px 0;">Loading...</p>';
            
            try {
                const workDay = getWorkDay();
                console.log('üéÜ Loading completions for work day:', workDay);
                
                // Remove existing listener
                const existingListener = realtimeListeners.find(l => l.type === 'simple-completions');
                if (existingListener) {
                    existingListener.unsubscribe();
                    realtimeListeners = realtimeListeners.filter(l => l.type !== 'simple-completions');
                }
                
                // Set up real-time listener for ALL completions (not just assigned to current user)
                let query = db.collection('document-queue').where('date', '==', workDay);
                
                // Apply filter based on current selection
                if (currentCompletionsFilter === 'pending') {
                    query = query.where('status', '==', 'pending-recruiter-contact');
                } else if (currentCompletionsFilter === 'attended') {
                    query = query.where('status', '==', 'attended');
                }
                // For 'all', no additional status filter is needed
                
                const unsubscribe = query
                    .onSnapshot(snapshot => {
                        console.log('üéÜ Simple completions update: Found', snapshot.size, 'total completions');
                        
                        // Update last update time
                        const lastUpdateElement = document.getElementById('last-update-time');
                        if (lastUpdateElement) {
                            lastUpdateElement.textContent = new Date().toLocaleTimeString();
                        }
                        
                        // Update indicators with animation
                        const totalCount = snapshot.size;
                        if (countIndicator) {
                            // Flash animation on count change
                            if (countIndicator.textContent !== totalCount.toString()) {
                                countIndicator.classList.add('update-flash');
                                setTimeout(() => countIndicator.classList.remove('update-flash'), 500);
                            }
                            countIndicator.textContent = totalCount;
                        }
                        if (navIndicator) {
                            if (totalCount > 0) {
                                navIndicator.textContent = totalCount;
                                navIndicator.style.display = 'inline';
                            } else {
                                navIndicator.style.display = 'none';
                            }
                        }
                        
                        if (snapshot.empty) {
                            completionsList.innerHTML = `
                                <div style="text-align: center; padding: 60px 20px; background: #f8f9fa; border-radius: 12px; border: 2px dashed #dee2e6;">
                                    <div style="font-size: 48px; margin-bottom: 16px;">‚úÖ</div>
                                    <h4 style="color: #28a745; margin: 0 0 8px 0;">All Clear!</h4>
                                    <p style="color: #666; margin: 0;">No pending document completions right now.</p>
                                </div>
                            `;
                            return;
                        }
                        
                        completionsList.innerHTML = '';
                        
                        // Group completions by assigned recruiter
                        const completionsByRecruiter = {};
                        
                        snapshot.forEach((doc) => {
                            const completion = doc.data();
                            const recruiterEmail = completion.recruiterEmail;
                            
                            if (!completionsByRecruiter[recruiterEmail]) {
                                completionsByRecruiter[recruiterEmail] = [];
                            }
                            
                            completionsByRecruiter[recruiterEmail].push({ id: doc.id, ...completion });
                        });
                        
                        // Create sections for each recruiter
                        Object.keys(completionsByRecruiter).forEach(async (recruiterEmail) => {
                            const recruiterCompletions = completionsByRecruiter[recruiterEmail];
                            const isCurrentUser = currentUser && currentUser.email === recruiterEmail;
                            
                            // Create recruiter section
                            const recruiterSection = document.createElement('div');
                            recruiterSection.style.marginBottom = '30px';
                            
                            const recruiterHeader = document.createElement('div');
                            recruiterHeader.style.cssText = `
                                background: ${isCurrentUser ? 'linear-gradient(135deg, #28a745, #20c997)' : 'linear-gradient(135deg, #6c757d, #495057)'};
                                color: white;
                                padding: 15px 20px;
                                border-radius: 8px;
                                margin-bottom: 15px;
                                display: flex;
                                justify-content: space-between;
                                align-items: center;
                            `;
                            
                            recruiterHeader.innerHTML = `
                                <div>
                                    <h4 style="margin: 0; font-size: 18px;">
                                        ${isCurrentUser ? 'üë§ YOUR ASSIGNMENTS' : 'üë• ' + (recruiterCompletions[0].assignedRecruiter || recruiterEmail)}
                                    </h4>
                                    <p style="margin: 0; opacity: 0.9; font-size: 14px;">
                                        ${recruiterCompletions.length} candidate${recruiterCompletions.length !== 1 ? 's' : ''} waiting
                                    </p>
                                </div>
                                <span style="background: white; color: ${isCurrentUser ? '#28a745' : '#6c757d'}; border-radius: 50%; padding: 8px 12px; font-weight: bold; font-size: 16px;">
                                    ${recruiterCompletions.length}
                                </span>
                            `;
                            
                            recruiterSection.appendChild(recruiterHeader);
                            
                            // Add completion cards with PC/RR check
                            recruiterCompletions.forEach(completion => {
                                const card = createSimpleCompletionCard(completion, isCurrentUser);
                                recruiterSection.appendChild(card);
                            });
                            
                            completionsList.appendChild(recruiterSection);
                        });
                        
                        // Show notifications for new assignments and changes
                        if (currentUser) {
                            let hasNewAssignments = false;
                            let hasStatusChanges = false;
                            
                            snapshot.docChanges().forEach(change => {
                                const completion = change.doc.data();
                                
                                if (change.type === 'added') {
                                    // New completion added
                                    if (completion.recruiterEmail === currentUser.email) {
                                        // New assignment for current user
                                        if (completion.timestamp) {
                                            const completionTime = new Date(completion.timestamp);
                                            const now = new Date();
                                            const diffInSeconds = (now - completionTime) / 1000;
                                            
                                            if (diffInSeconds < 15) {
                                                hasNewAssignments = true;
                                                console.log('üéâ NEW completion assigned to me in simple view!');
                                                playSuccessSound();
                                                showSuccessMessage(`üéâ NEW: ${completion.name} (Queue #${completion.queueNumber}) assigned to you!`);
                                            }
                                        }
                                    } else {
                                        // New completion for other recruiters - still show notification
                                        console.log('üìã New completion added for:', completion.assignedRecruiter);
                                        hasStatusChanges = true;
                                    }
                                } else if (change.type === 'modified') {
                                    // Status changed (like marked as attended)
                                    console.log('üîÑ Completion status changed for:', completion.name);
                                    hasStatusChanges = true;
                                }
                            });
                            
                            // Flash live indicator on any changes
                            if (hasNewAssignments || hasStatusChanges) {
                                const liveIndicator = document.getElementById('live-indicator');
                                if (liveIndicator) {
                                    liveIndicator.style.background = '#ffd700';
                                    liveIndicator.style.color = '#000';
                                    setTimeout(() => {
                                        liveIndicator.style.background = '#28a745';
                                        liveIndicator.style.color = 'white';
                                    }, 1000);
                                }
                            }
                        }
                        
                    }, error => {
                        console.error('‚ùå Error in simple completions listener:', error);
                        completionsList.innerHTML = '<p style="color: #dc3545; text-align: center; padding: 40px 0;">Error loading completions. Please refresh the page.</p>';
                    });
                
                // Store listener
                realtimeListeners.push({
                    type: 'simple-completions',
                    unsubscribe: unsubscribe
                });
                
                console.log('‚úÖ Simple document completions loaded successfully');
                
            } catch (error) {
                console.error('‚ùå Error setting up simple document completions:', error);
                completionsList.innerHTML = '<p style="color: #dc3545; text-align: center; padding: 40px 0;">Error loading completions. Please refresh the page.</p>';
            }
        }
        
        // Check PC/RR status for a given name
        async function checkPCRRStatus(candidateName) {
            try {
                console.log('üîç Checking PC/RR status for:', candidateName);
                
                // Always reload exclusion list for real-time checking
                try {
                    console.log('üîç Loading exclusion list from Firestore...');
                    const exclusionDoc = await db.collection('settings').doc('exclusion-list').get();
                    if (exclusionDoc.exists) {
                        exclusionListData = exclusionDoc.data().data || [];
                        console.log('üîç Exclusion list loaded:', exclusionListData.length, 'records');
                    } else {
                        console.log('üîç No exclusion list found in Firestore');
                        exclusionListData = [];
                    }
                } catch (error) {
                    console.error('‚ùå Error loading exclusion list for PC/RR check:', error);
                    return { found: false, matches: [] };
                }
                
                if (!exclusionListData || exclusionListData.length === 0) {
                    console.log('üîç No exclusion list data available');
                    return { found: false, matches: [] };
                }
                
                // Parse the name into components
                const nameParts = candidateName.toLowerCase().trim().split(' ');
                const firstName = nameParts[0];
                const lastName = nameParts[nameParts.length - 1];
                
                console.log('üîç Searching for:', { firstName, lastName, originalName: candidateName });
                
                // Search for matches in the exclusion list
                const matches = exclusionListData.filter(record => {
                    if (!record.name) return false;
                    
                    const recordName = record.name.toLowerCase().trim();
                    const recordParts = recordName.split(' ');
                    const recordFirst = recordParts[0];
                    const recordLast = recordParts[recordParts.length - 1];
                    
                    // Check if both first and last names match
                    const match = firstName === recordFirst && lastName === recordLast;
                    if (match) {
                        console.log('üîç MATCH FOUND:', record);
                    }
                    return match;
                });
                
                const result = {
                    found: matches.length > 0,
                    matches: matches
                };
                
                console.log('üîç PC/RR Check Result for', candidateName, ':', result);
                return result;
                
            } catch (error) {
                console.error('‚ùå Error in PC/RR status check:', error);
                return { found: false, matches: [] };
            }
        }

        // Create simple completion card with PC/RR checking
        function createSimpleCompletionCard(completion, isCurrentUser) {
            const card = document.createElement('div');
            card.style.cssText = `
                background: ${isCurrentUser ? '#f8fff9' : '#f8f9fa'};
                border: 2px solid ${isCurrentUser ? '#28a745' : '#dee2e6'};
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 15px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            `;
            
            const timeString = completion.completedAt || 'Unknown time';
            
            // Create PC/RR status container that will be populated asynchronously
            const pcrrContainer = document.createElement('div');
            pcrrContainer.style.marginBottom = '15px';
            pcrrContainer.innerHTML = `
                <h5 style="margin-bottom: 10px; color: #333; font-size: 16px; font-weight: bold;">üîç PC/RR Status:</h5>
                <p style="margin: 5px 0; color: #666; background: #fff3cd; padding: 8px 16px; border-radius: 8px; font-size: 14px; text-align: center; font-weight: bold;">
                    üîÑ Checking PC/RR List...
                </p>
            `;
            
            // Asynchronously check PC/RR status and update the display
            console.log('üîç Starting PC/RR check for:', completion.name);
            checkPCRRStatus(completion.name).then(pcrrStatus => {
                console.log('üîç PC/RR check completed for', completion.name, 'Result:', pcrrStatus);
                
                let pcrrDisplay = '';
                if (pcrrStatus.found) {
                    // Use the same style as info sessions
                    pcrrDisplay = `
                        <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; padding: 10px; margin: 10px 0;">
                            <h5 style="color: #856404; margin: 0 0 5px 0;">‚ö†Ô∏è Possible PC or RR List</h5>
                            <p style="color: #856404; margin: 5px 0; font-size: 13px;">This name appears on the exclusion list. Verify with SSN.</p>
                            ${pcrrStatus.matches.map(match => `
                                <div style="font-size: 12px; color: #856404;">
                                    Code: <strong>${match.code}</strong> - SSN: ***${match.ssn ? match.ssn.slice(-4) : 'N/A'}
                                </div>
                            `).join('')}
                        </div>
                    `;
                    console.log('üö® PC/RR ALERT for', completion.name, '- Found in exclusion list');
                } else {
                    pcrrDisplay = `
                        <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 5px; padding: 8px; margin: 10px 0;">
                            <p style="color: #155724; margin: 0; font-size: 13px; text-align: center; font-weight: bold;">
                                ‚úÖ Clear - Not in PC/RR exclusion list
                            </p>
                        </div>
                    `;
                }
                
                // Update the PC/RR container to match info sessions style
                pcrrContainer.innerHTML = pcrrDisplay;
                
            }).catch(error => {
                console.error('‚ùå Error checking PC/RR status for', completion.name, ':', error);
                pcrrContainer.innerHTML = `
                    <div style="background: #f8d7da; border: 1px solid #f1aeb5; border-radius: 5px; padding: 8px; margin: 10px 0;">
                        <p style="color: #dc3545; margin: 0; font-size: 13px; text-align: center; font-weight: bold;">
                            ‚ùå Error checking PC/RR status
                        </p>
                    </div>
                `;
            });
            
            card.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                    <div>
                        <h4 style="margin: 0; color: ${isCurrentUser ? '#28a745' : '#333'}; font-size: 20px;">
                            üë§ ${completion.name}
                        </h4>
                        <p style="margin: 5px 0; color: #666; font-size: 14px;">
                            ‚è∞ Completed: ${timeString}
                        </p>
                        <p style="margin: 5px 0; color: #666; font-size: 14px;">
                            üë• Assigned to: ${completion.assignedRecruiter}
                        </p>
                        ${completion.status === 'attended' ? `
                            <p style="margin: 5px 0; color: #28a745; font-size: 14px; font-weight: bold;">
                                ‚úÖ Attended by: ${completion.attendedByName || completion.attendedBy || 'Staff'}
                            </p>
                        ` : ''}
                    </div>
                    <div style="text-align: right;">
                        <span style="background: #dc3545; color: white; padding: 8px 16px; border-radius: 25px; font-size: 16px; font-weight: bold; display: block; margin-bottom: 8px;">
                            Queue #${completion.queueNumber}
                        </span>
                        ${isCurrentUser ? '<span style="background: #28a745; color: white; padding: 4px 12px; border-radius: 15px; font-size: 12px; font-weight: bold;">YOUR ASSIGNMENT</span>' : ''}
                    </div>
                </div>
            `;
            
            // Add PC/RR status container
            card.appendChild(pcrrContainer);
            
            // Add documents status section
            const documentsContainer = document.createElement('div');
            documentsContainer.style.marginBottom = '15px';
            documentsContainer.innerHTML = `
                <h5 style="margin-bottom: 10px; color: #333; font-size: 14px;">üìã Documents Status:</h5>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px;">
                    <div style="font-size: 13px; padding: 4px 8px; background: ${false ? '#d4edda' : '#f8d7da'}; border-radius: 4px;">
                        ${false ? '‚úÖ' : '‚ùå'} OB365
                    </div>
                    <div style="font-size: 13px; padding: 4px 8px; background: ${false ? '#d4edda' : '#f8d7da'}; border-radius: 4px;">
                        ${false ? '‚úÖ' : '‚ùå'} Drug Screen
                    </div>
                    <div style="font-size: 13px; padding: 4px 8px; background: ${false ? '#d4edda' : '#f8d7da'}; border-radius: 4px;">
                        ${false ? '‚úÖ' : '‚ùå'} I-9 Form
                    </div>
                    <div style="font-size: 13px; padding: 4px 8px; background: ${false ? '#d4edda' : '#fff3cd'}; border-radius: 4px;">
                        ${false ? '‚úÖ' : '‚ÑπÔ∏è'} Fingerprints
                    </div>
                </div>
            `;
            card.appendChild(documentsContainer);
            
            // Add action buttons section
            const actionsContainer = document.createElement('div');
            actionsContainer.style.cssText = 'text-align: center; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;';
            // Escape single quotes in name for onclick handlers
            const safeName = completion.name.replace(/'/g, "\\'");
            
            actionsContainer.innerHTML = `
                ${isCurrentUser ? `
                    <button class="btn btn-success" onclick="markAsContacted('${completion.id}')" style="font-size: 13px; padding: 8px 16px; background: #28a745; border: none; border-radius: 6px;">
                        üìû Contact Candidate
                    </button>
                ` : ''}
                ${completion.status !== 'attended' ? `
                    <button class="btn" onclick="markAsAttended('${completion.id}', '${safeName}', ${completion.queueNumber})" style="font-size: 13px; padding: 8px 16px; background: #17a2b8; color: white; border: none; border-radius: 6px;">
                        ‚úÖ Mark as Attended
                    </button>
                ` : `
                    <span style="background: #28a745; color: white; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: bold;">
                        ‚úÖ Already Attended
                    </span>
                `}
                <button class="btn" onclick="deleteCompletion('${completion.id}', '${safeName}')" style="font-size: 13px; padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 6px;" title="Eliminar registro">
                    üóëÔ∏è Delete
                </button>
            `;
            card.appendChild(actionsContainer);
            
            return card;
        }
        
        // Mark visitor as attended (for all staff)
        async function markAsAttended(completionId, candidateName, queueNumber) {
            console.log('üéØ markAsAttended called with:', { completionId, candidateName, queueNumber });
            
            if (!currentUser) {
                console.error('‚ùå No current user');
                showErrorMessage('You must be logged in to mark attendance.');
                return;
            }
            
            if (confirm(`Mark ${candidateName} (Queue #${queueNumber}) as attended?`)) {
                try {
                    console.log('‚úÖ Marking as attended:', candidateName, 'ID:', completionId);
                    console.log('üîç Current user:', currentUser ? currentUser.email : 'No user');
                    console.log('üîç Document ID type:', typeof completionId);
                    console.log('üîç Document ID value:', completionId);
                    
                    // First, verify the document exists
                    const docRef = db.collection('document-queue').doc(completionId);
                    const docSnapshot = await docRef.get();
                    
                    if (!docSnapshot.exists) {
                        console.error('‚ùå Document does not exist:', completionId);
                        showErrorMessage('Error: Document not found. Please refresh and try again.');
                        return;
                    }
                    
                    console.log('‚úÖ Document exists, current data:', docSnapshot.data());
                    
                    // Update the completion record
                    await docRef.update({
                        status: 'attended',
                        attendedBy: currentUser.email,
                        attendedByName: currentUser.displayName || currentUser.email,
                        attendedAt: new Date().toISOString(),
                        lastUpdated: new Date().toISOString()
                    });
                    
                    showSuccessMessage(`${candidateName} marked as attended!`);
                    playSuccessSound();
                    
                    // The real-time listener will automatically refresh the view
                    
                } catch (error) {
                    console.error('Error marking as attended:', error);
                    showErrorMessage('Error updating attendance status. Please try again.');
                }
            }
        }
        
        // Global filter state
        let currentCompletionsFilter = 'pending'; // Default to show only pending
        
        // Filter completions
        function filterCompletions(filter) {
            currentCompletionsFilter = filter;
            
            // Update button styles
            document.getElementById('filter-pending-btn').style.opacity = filter === 'pending' ? '1' : '0.6';
            document.getElementById('filter-attended-btn').style.opacity = filter === 'attended' ? '1' : '0.6';
            document.getElementById('filter-all-btn').style.opacity = filter === 'all' ? '1' : '0.6';
            
            // Reload completions with new filter
            loadSimpleDocumentCompletions();
        }
        
        // Manual refresh completions
        function manualRefreshCompletions() {
            console.log('üîÑ Manual refresh requested by user');
            
            // Visual feedback
            const refreshBtn = document.getElementById('refresh-btn');
            if (refreshBtn) {
                refreshBtn.textContent = '‚ü≥ Refreshing...';
                refreshBtn.disabled = true;
                
                setTimeout(() => {
                    refreshBtn.textContent = 'üîÑ Refresh';
                    refreshBtn.disabled = false;
                }, 1000);
            }
            
            // Flash live indicator
            const liveIndicator = document.getElementById('live-indicator');
            if (liveIndicator) {
                liveIndicator.style.background = '#007bff';
                liveIndicator.textContent = 'üîÑ UPDATING';
                setTimeout(() => {
                    liveIndicator.style.background = '#28a745';
                    liveIndicator.textContent = 'üî¥ LIVE';
                }, 1000);
            }
            
            // Force reload
            loadSimpleDocumentCompletions();
            
            // Show user feedback
            showSuccessMessage('Dashboard refreshed!');
        }
        
        // Delete completion record (for all staff)
        async function deleteCompletion(completionId, candidateName, queueNumber) {
            if (!currentUser) {
                showErrorMessage('You must be logged in to delete records.');
                return;
            }
            
            // Double confirmation for delete action
            const safeName = candidateName.replace(/'/g, "\\'");
            const firstConfirm = confirm(`‚ö†Ô∏è DELETE CONFIRMATION\n\nAre you sure you want to remove ${safeName} (Queue #${queueNumber}) from the completion queue?\n\nThis action cannot be undone.`);
            
            if (!firstConfirm) return;
            
            const secondConfirm = confirm(`üóëÔ∏è FINAL CONFIRMATION\n\nThis will permanently delete:\n‚Ä¢ ${safeName}\n‚Ä¢ Queue #${queueNumber}\n‚Ä¢ All completion data\n\nClick OK to proceed with deletion.`);
            
            if (!secondConfirm) return;
            
            try {
                console.log('üóëÔ∏è Deleting completion:', candidateName, 'ID:', completionId);
                
                // Get the completion record first for logging
                const completionDoc = await db.collection('document-queue').doc(completionId).get();
                const completionData = completionDoc.data();
                
                // Delete the main record
                await db.collection('document-queue').doc(completionId).delete();
                
                // Log the deletion for audit purposes
                await db.collection('system-logs').add({
                    type: 'completion-deleted',
                    deletedBy: currentUser.email,
                    deletedByName: currentUser.displayName || currentUser.email,
                    deletedData: {
                        name: candidateName,
                        queueNumber: queueNumber,
                        assignedRecruiter: completionData?.assignedRecruiter || 'Unknown',
                        originalCompletedAt: completionData?.completedAt || 'Unknown',
                        status: completionData?.status || 'Unknown'
                    },
                    timestamp: new Date().toISOString(),
                    date: new Date().toISOString().split('T')[0]
                });
                
                showSuccessMessage(`${candidateName} (Queue #${queueNumber}) deleted successfully!`);
                playSuccessSound();
                
                console.log('‚úÖ Completion deleted and logged successfully');
                
                // The real-time listener will automatically refresh the view
                
            } catch (error) {
                console.error('Error deleting completion:', error);
                
                // Log the error
                try {
                    await db.collection('system-errors').add({
                        type: 'completion-deletion-error',
                        attemptedBy: currentUser.email,
                        targetCompletion: {
                            id: completionId,
                            name: candidateName,
                            queueNumber: queueNumber
                        },
                        error: error.message,
                        timestamp: new Date().toISOString()
                    });
                } catch (logError) {
                    console.error('Could not log deletion error:', logError);
                }
                
                showErrorMessage('Error deleting record. Please try again or contact admin.');
            }
        }
        
        // ===== QUEUE POSITION TRACKING =====
        
        let queuePositionListener = null;
        
        // Start tracking user's position in queue
        function startQueuePositionTracking(userQueueNumber) {
            console.log('üöÄ Starting queue position tracking for queue number:', userQueueNumber);
            
            if (queuePositionListener) {
                queuePositionListener();
                queuePositionListener = null;
            }
            
            const today = new Date().toISOString().split('T')[0];
            
            // Real-time listener for all pending completions
            queuePositionListener = db.collection('document-queue')
                .where('date', '==', today)
                .where('status', '==', 'pending-recruiter-contact')
                .onSnapshot(snapshot => {
                    console.log('üìä Queue position update:', snapshot.size, 'people in queue');
                    
                    // Get all queue numbers and sort them
                    const allQueueNumbers = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        allQueueNumbers.push(data.queueNumber);
                    });
                    
                    allQueueNumbers.sort((a, b) => a - b);
                    console.log('üìä All queue numbers:', allQueueNumbers);
                    
                    // Find user's position
                    const userPosition = allQueueNumbers.indexOf(userQueueNumber) + 1;
                    const totalInQueue = allQueueNumbers.length;
                    
                    console.log('üìä User queue number:', userQueueNumber, 'Position:', userPosition, 'of', totalInQueue);
                    
                    // Update display
                    updateQueuePositionDisplay(userPosition, totalInQueue, userQueueNumber);
                }, error => {
                    console.error('Error in queue position tracking:', error);
                    updateQueuePositionDisplay(null, null, userQueueNumber, 'Error tracking position');
                });
        }
        
        // Update queue position display
        function updateQueuePositionDisplay(position, total, queueNumber, errorMsg) {
            const positionDisplay = document.getElementById('position-display');
            const positionText = document.getElementById('position-text');
            const waitTime = document.getElementById('wait-time');
            const lastUpdate = document.getElementById('position-last-update');
            
            if (lastUpdate) {
                lastUpdate.textContent = new Date().toLocaleTimeString();
            }
            
            if (errorMsg) {
                if (positionDisplay) positionDisplay.textContent = '‚ö†Ô∏è';
                if (positionText) positionText.textContent = errorMsg;
                if (waitTime) waitTime.textContent = 'Please refresh the page or contact front desk';
                return;
            }
            
            if (position === null || position === 0) {
                // User is no longer in queue (probably attended)
                if (positionDisplay) positionDisplay.textContent = '‚úÖ';
                if (positionText) positionText.textContent = 'You\'ve been attended!';
                if (waitTime) waitTime.textContent = 'Thank you for your patience';
                return;
            }
            
            // Update position display
            if (positionDisplay) {
                positionDisplay.textContent = `#${position}`;
                // Flash effect on position change
                positionDisplay.style.animation = 'flash 0.5s ease-in-out';
                setTimeout(() => positionDisplay.style.animation = '', 500);
            }
            
            // Update position text
            if (positionText) {
                if (position === 1) {
                    positionText.textContent = 'üéâ YOU\'RE NEXT!';
                    positionText.style.color = '#ff6b6b';
                } else if (position <= 3) {
                    positionText.textContent = `Almost there! ${position - 1} people ahead of you`;
                    positionText.style.color = '#ffa726';
                } else {
                    positionText.textContent = `${position - 1} people ahead of you out of ${total} total`;
                    positionText.style.color = '#1565c0';
                }
            }
            
            // Update estimated wait time
            if (waitTime) {
                const estimatedMinutes = Math.max(1, (position - 1) * 3); // 3 minutes per person
                if (position === 1) {
                    waitTime.textContent = '‚è∞ Your recruiter should contact you any moment!';
                } else {
                    waitTime.textContent = `‚è∞ Estimated wait time: ${estimatedMinutes} minutes`;
                }
            }
        }
        
        // Auto-load simple completions when dashboard loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                console.log('üéÜ Auto-loading simple completions after page load...');
                loadSimpleDocumentCompletions();
            }, 3000);
        });
        
        // Make functions globally available
        window.loadSimpleDocumentCompletions = loadSimpleDocumentCompletions;
        
        // Alias for real-time refreshing
        function loadStatusDocumentCompletions() {
            return loadDocumentCompletionsForStatus();
        }
        
        // Load document completions for the status section (with real-time updates)
        async function loadDocumentCompletionsForStatus() {
            if (!currentUser) {
                console.log('‚ùå Cannot load document completions for status: No current user');
                return;
            }
            
            console.log('üìã ===== LOADING DOCUMENT COMPLETIONS FOR MY STATUS =====');
            console.log('üìã Setting up document completions in My Status for:', currentUser.email);
            console.log('üìã Function loadDocumentCompletionsForStatus() called successfully');
            
            try {
                const completionsList = document.getElementById('status-document-completions-list');
                const indicator = document.getElementById('status-completions-indicator');
                
                if (!completionsList) {
                    console.error('‚ùå Status completions list element not found');
                    return;
                }
                
                completionsList.innerHTML = '<p style="color: #666; text-align: center; margin: 20px 0;">Loading document completions...</p>';
                
                // Remove existing listener if any
                const existingListener = realtimeListeners.find(l => l.type === 'status-document-completions');
                if (existingListener) {
                    console.log('üìã Removing existing status listener');
                    existingListener.unsubscribe();
                    realtimeListeners = realtimeListeners.filter(l => l.type !== 'status-document-completions');
                }
                
                // Get today's pending completions with real-time listener
                const today = new Date().toISOString().split('T')[0];
                console.log('üìã Setting up real-time listener for status completions on date:', today);
                
                const unsubscribe = db.collection('document-queue')
                    .where('date', '==', today)
                    .where('status', '==', 'pending-recruiter-contact')
                    .where('recruiterEmail', '==', currentUser.email) // Only my assignments
                    .onSnapshot(snapshot => {
                        console.log('üìã Status real-time update: Found', snapshot.size, 'completions assigned to me');
                        
                        // Update indicator
                        if (indicator) {
                            if (snapshot.size > 0) {
                                indicator.textContent = snapshot.size;
                                indicator.style.display = 'block';
                                indicator.classList.add('pulse-animation');
                            } else {
                                indicator.style.display = 'none';
                                indicator.classList.remove('pulse-animation');
                            }
                        }
                        
                        if (snapshot.empty) {
                            completionsList.innerHTML = '<p style="color: #28a745; text-align: center; margin: 20px 0; font-weight: bold;">‚úÖ No pending document completions assigned to you!</p>';
                            return;
                        }
                        
                        completionsList.innerHTML = '';
                        
                        snapshot.forEach((doc, index) => {
                            const completion = doc.data();
                            console.log(`üìã Status completion ${index + 1}:`, completion.name, 'Queue #' + completion.queueNumber);
                            
                            const completionCard = createStatusDocumentCompletionCard(completion, doc.id);
                            completionsList.appendChild(completionCard);
                        });
                        
                        // Show notification for new completions
                        snapshot.docChanges().forEach(change => {
                            if (change.type === 'added') {
                                const completion = change.doc.data();
                                // Check if this is a new completion (less than 10 seconds old)
                                if (completion.timestamp) {
                                    const completionTime = new Date(completion.timestamp);
                                    const now = new Date();
                                    const diffInSeconds = (now - completionTime) / 1000;
                                    
                                    if (diffInSeconds < 10) {
                                        console.log('üéâ NEW completion in status!');
                                        playSuccessSound();
                                        showSuccessMessage(`üéâ NEW: ${completion.name} (Queue #${completion.queueNumber}) assigned to you!`);
                                    }
                                }
                            }
                        });
                    }, error => {
                        console.error('‚ùå Error in real-time status document completions:', error);
                        completionsList.innerHTML = '<p style="color: #dc3545; text-align: center; margin: 20px 0;">Error loading completions. Please refresh.</p>';
                    });
                
                // Store the listener
                realtimeListeners.push({
                    type: 'status-document-completions',
                    unsubscribe: unsubscribe
                });
                
                console.log('üìã Status document completions listener set up successfully');
                
            } catch (error) {
                console.error('‚ùå Error setting up status document completions:', error);
                const completionsList = document.getElementById('status-document-completions-list');
                if (completionsList) {
                    completionsList.innerHTML = '<p style="color: #dc3545; text-align: center; margin: 20px 0;">Error loading completions. Please refresh.</p>';
                }
            }
        }
        
        // Create a simplified document completion card for the status section
        function createStatusDocumentCompletionCard(completion, completionId) {
            const card = document.createElement('div');
            card.className = 'visit-card';
            card.style.marginBottom = '15px';
            card.style.border = '2px solid #28a745';
            card.style.borderRadius = '8px';
            card.style.backgroundColor = '#f8fff9';
            
            const timeString = completion.completedAt || 'Unknown time';
            
            card.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                    <div>
                        <h4 style="margin: 0; color: #28a745; font-size: 18px;">
                            üë§ ${completion.name}
                        </h4>
                        <p style="margin: 5px 0; color: #666; font-size: 14px;">
                            ‚è∞ Completed: ${timeString}
                        </p>
                    </div>
                    <div style="text-align: right;">
                        <span style="background: #dc3545; color: white; padding: 6px 12px; border-radius: 20px; font-size: 14px; font-weight: bold;">
                            Queue #${completion.queueNumber}
                        </span>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <h5 style="margin-bottom: 8px; color: #333; font-size: 14px;">üìã Documents Completed:</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 6px;">
                        <div style="font-size: 13px;">‚úÖ OB365: ${false ? 'Done' : 'Pending'}</div>
                        <div style="font-size: 13px;">üß™ Drug Screen: ${false ? 'Done' : 'Pending'}</div>
                        <div style="font-size: 13px;">üìù I-9: ${false ? 'Done' : 'Pending'}</div>
                        <div style="font-size: 13px;">üëÜ Fingerprints: ${false ? 'Done' : 'Not Required'}</div>
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-success" onclick="markAsContacted('${completionId}')" style="font-size: 16px; padding: 10px 20px;">
                        üìû Contact Candidate
                    </button>
                    <button class="btn btn-danger" onclick="deleteCompletion('${completionId}', '${completion.name}')" style="font-size: 14px; padding: 8px 16px; margin-left: 10px;">
                        üóëÔ∏è Delete
                    </button>
                </div>
            `;
            
            return card;
        }
        
        // ===== PUBLIC DOCUMENT COMPLETIONS (NO LOGIN REQUIRED) =====
        
        let publicCompletionsListener = null;
        
        // Helper function to show full completions list for staff
        function showFullCompletionsList(pendingCompletions, completionsList) {
            // Group by recruiter
            const byRecruiter = {};
            pendingCompletions.forEach(completion => {
                const email = completion.recruiterEmail;
                if (!byRecruiter[email]) {
                    byRecruiter[email] = [];
                }
                byRecruiter[email].push(completion);
            });
            
            completionsList.innerHTML = '';
            
            // Create sections for each recruiter
            Object.keys(byRecruiter).forEach(recruiterEmail => {
                const recruiterCompletions = byRecruiter[recruiterEmail];
                const recruiterName = recruiterCompletions[0].assignedRecruiter || recruiterEmail;
                
                const recruiterSection = document.createElement('div');
                recruiterSection.style.marginBottom = '40px';
                
                // Recruiter header
                const header = document.createElement('div');
                header.style.cssText = `
                    background: linear-gradient(135deg, #007bff, #0056b3);
                    color: white;
                    padding: 20px;
                    border-radius: 12px;
                    margin-bottom: 20px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
                `;
                
                header.innerHTML = `
                    <div>
                        <h3 style="margin: 0; font-size: 22px;">üë• ${recruiterName}</h3>
                        <p style="margin: 5px 0 0 0; opacity: 0.9; font-size: 16px;">${recruiterCompletions.length} candidate${recruiterCompletions.length !== 1 ? 's' : ''} awaiting contact</p>
                    </div>
                    <div style="text-align: right;">
                        <span style="background: white; color: #007bff; border-radius: 50%; padding: 12px 16px; font-weight: bold; font-size: 20px; min-width: 50px; display: inline-block; text-align: center;">
                            ${recruiterCompletions.length}
                        </span>
                    </div>
                `;
                
                recruiterSection.appendChild(header);
                
                // Add completion cards
                recruiterCompletions.sort((a, b) => a.queueNumber - b.queueNumber).forEach(completion => {
                    const card = createPublicCompletionCard(completion);
                    recruiterSection.appendChild(card);
                });
                
                completionsList.appendChild(recruiterSection);
            });
        }
        
        // Load public document completions (shows count for all, details for staff only)
        async function loadPublicDocumentCompletions() {
            console.log('üåç ===== LOADING PUBLIC DOCUMENT COMPLETIONS =====');
            
            const completionsList = document.getElementById('public-completions-list');
            const totalCountElement = document.getElementById('public-total-count');
            const todayCompletedElement = document.getElementById('public-today-completed');
            const lastUpdateElement = document.getElementById('public-last-update');
            const navIndicator = document.getElementById('public-completions-indicator');
            const staffLoginPrompt = document.getElementById('staff-login-prompt');
            
            // Check if user is staff
            const isStaff = currentUser && (currentUser.role === 'staff' || isAdmin);
            console.log('üåç User is staff:', isStaff);
            
            if (!completionsList) {
                console.error('‚ùå Public completions list not found');
                return;
            }
            
            // Remove existing listener
            if (publicCompletionsListener) {
                publicCompletionsListener();
                publicCompletionsListener = null;
            }
            
            try {
                const today = new Date().toISOString().split('T')[0];
                console.log('üåç Loading public completions for:', today);
                
                // Set up real-time listener
                publicCompletionsListener = db.collection('document-queue')
                    .where('date', '==', today)
                    .onSnapshot(async (snapshot) => {
                        console.log('üåç Public update: Found', snapshot.size, 'total completions today');
                        
                        // Update last update time
                        const now = new Date();
                        if (lastUpdateElement) {
                            lastUpdateElement.textContent = now.toLocaleTimeString();
                        }
                        
                        // Count all completions (regardless of status)
                        let totalCompletions = snapshot.size;
                        let pendingCount = totalCompletions; // For simplicity, show all as pending in public view
                        let completedCount = 0;
                        const pendingCompletions = [];
                        
                        snapshot.forEach(doc => {
                            const completion = doc.data();
                            pendingCompletions.push({ id: doc.id, ...completion });
                        });
                        
                        // Update counters (always show)
                        if (totalCountElement) totalCountElement.textContent = pendingCount;
                        if (todayCompletedElement) todayCompletedElement.textContent = completedCount;
                        if (navIndicator) {
                            if (pendingCount > 0) {
                                navIndicator.textContent = pendingCount;
                                navIndicator.style.display = 'block';
                            } else {
                                navIndicator.style.display = 'none';
                            }
                        }
                        
                        // Display completions based on user type
                        if (pendingCount === 0) {
                            completionsList.innerHTML = `
                                <div style="text-align: center; padding: 60px 20px; background: #d4f4dd; border-radius: 15px; border: 2px solid #28a745;">
                                    <div style="font-size: 72px; margin-bottom: 20px;">‚úÖ</div>
                                    <h3 style="color: #28a745; margin: 0 0 10px 0;">All Clear!</h3>
                                    <p style="color: #155724; margin: 0; font-size: 18px;">No pending document completions right now.</p>
                                </div>
                            `;
                            if (staffLoginPrompt) staffLoginPrompt.style.display = 'none';
                            return;
                        }
                        
                        // Show different content based on user type
                        if (isStaff) {
                            // Staff can see full details
                            console.log('üåç Showing full details for staff user');
                            if (staffLoginPrompt) staffLoginPrompt.style.display = 'none';
                            showFullCompletionsList(pendingCompletions, completionsList);
                        } else {
                            // Public users only see count and login prompt
                            console.log('üåç Showing count only for public user');
                            completionsList.innerHTML = `
                                <div style="text-align: center; padding: 60px 20px; background: #f8f9fa; border-radius: 15px; border: 2px dashed #dee2e6;">
                                    <div style="font-size: 72px; margin-bottom: 20px;">üìã</div>
                                    <h3 style="color: #333; margin: 0 0 15px 0;">${pendingCount} People in Queue</h3>
                                    <p style="color: #666; margin: 0 0 10px 0; font-size: 18px;">Document completions are being processed</p>
                                    <p style="color: #6c757d; margin: 0; font-size: 14px;">Queue details are only visible to staff</p>
                                </div>
                            `;
                            if (staffLoginPrompt) staffLoginPrompt.style.display = 'block';
                        }
                        
                    }, error => {
                        console.error('‚ùå Error in public completions listener:', error);
                        completionsList.innerHTML = `
                            <div style="text-align: center; padding: 60px 20px; background: #f8d7da; border-radius: 15px; border: 2px solid #dc3545;">
                                <div style="font-size: 48px; margin-bottom: 20px;">‚ùå</div>
                                <h3 style="color: #dc3545; margin: 0 0 10px 0;">Connection Error</h3>
                                <p style="color: #721c24; margin: 0;">Unable to load document completions. Please refresh the page.</p>
                            </div>
                        `;
                    });
                
            } catch (error) {
                console.error('‚ùå Error setting up public completions:', error);
            }
        }
        
        // Create public completion card
        function createPublicCompletionCard(completion) {
            const card = document.createElement('div');
            card.style.cssText = `
                background: white;
                border: 2px solid #e9ecef;
                border-radius: 12px;
                padding: 25px;
                margin-bottom: 20px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                transition: all 0.3s ease;
            `;
            
            const timeString = completion.completedAt || 'Unknown time';
            
            card.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px;">
                    <div>
                        <h4 style="margin: 0; color: #333; font-size: 24px; font-weight: bold;">
                            üë§ ${completion.name}
                        </h4>
                        <p style="margin: 8px 0 4px 0; color: #666; font-size: 16px;">
                            ‚è∞ Completed: ${timeString}
                        </p>
                        <p style="margin: 4px 0 0 0; color: #6c757d; font-size: 14px;">
                            üë• Assigned to: ${completion.assignedRecruiter}
                        </p>
                    </div>
                    <div>
                        <span style="background: linear-gradient(135deg, #dc3545, #c82333); color: white; padding: 12px 18px; border-radius: 30px; font-size: 18px; font-weight: bold; box-shadow: 0 4px 8px rgba(220,53,69,0.3);">
                            Queue #${completion.queueNumber}
                        </span>
                    </div>
                </div>
                
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                    <h5 style="margin: 0 0 15px 0; color: #495057; font-size: 16px;">üìã Document Status:</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px; font-size: 15px; font-weight: 500;">
                            <span style="width: 24px; height: 24px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 12px; ${false ? 'background: #28a745; color: white;' : 'background: #dc3545; color: white;'}">
                                ${false ? '‚úì' : '√ó'}
                            </span>
                            <span style="color: ${false ? '#28a745' : '#dc3545'};">OB365</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; font-size: 15px; font-weight: 500;">
                            <span style="width: 24px; height: 24px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 12px; ${false ? 'background: #28a745; color: white;' : 'background: #dc3545; color: white;'}">
                                ${false ? '‚úì' : '√ó'}
                            </span>
                            <span style="color: ${false ? '#28a745' : '#dc3545'};">Drug Screen</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; font-size: 15px; font-weight: 500;">
                            <span style="width: 24px; height: 24px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 12px; ${false ? 'background: #28a745; color: white;' : 'background: #dc3545; color: white;'}">
                                ${false ? '‚úì' : '√ó'}
                            </span>
                            <span style="color: ${false ? '#28a745' : '#dc3545'};">I-9 Form</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; font-size: 15px; font-weight: 500;">
                            <span style="width: 24px; height: 24px; border-radius: 50%; display: inline-flex; align-items: center; justify-  center; font-size: 12px; ${false ? 'background: #28a745; color: white;' : 'background: #ffc107; color: black;'}">
                                ${false ? '‚úì' : 'i'}
                            </span>
                            <span style="color: ${false ? '#28a745' : '#6c757d'};">Fingerprints ${false ? 'Done' : 'Optional'}</span>
                        </div>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        // Override the showScreen function to handle public completions
        const originalShowScreen = window.showScreen || function(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
            }
        };
        
        window.showScreen = function(screenId) {
            console.log('üîÑ Showing screen:', screenId);
            
            // Call original function
            originalShowScreen(screenId);
            
            // Special handling for public completions
            if (screenId === 'completions-public') {
                console.log('üåç Loading public document completions screen...');
                setTimeout(() => {
                    loadPublicDocumentCompletions();
                }, 500);
            }
        };
        
        // Make public function available
        window.loadPublicDocumentCompletions = loadPublicDocumentCompletions;
        
        // ===== LIVE DASHBOARD (SUPER SIMPLE) =====
        
        let liveDashboardListener = null;
        
        // Load live dashboard - ULTRA SIMPLE
        function loadLiveDashboard() {
            // Don't load dashboard on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Document completion page detected - skipping live dashboard');
                return;
            }
            
            console.log('üî¥ LOADING LIVE DASHBOARD - ULTRA SIMPLE');
            
            const contentDiv = document.getElementById('live-completions-content');
            const countDiv = document.getElementById('live-count-display');
            const updateDiv = document.getElementById('live-last-update');
            
            if (!contentDiv) {
                console.log('‚ùå Live dashboard elements not found - likely on document-completion page, skipping dashboard');
                return;
            }
            
            console.log('‚úÖ Live dashboard elements found, setting up listener...');
            
            // Remove existing listener
            if (liveDashboardListener) {
                liveDashboardListener();
                liveDashboardListener = null;
            }
            
            try {
                const today = new Date().toISOString().split('T')[0];
                
                // Simple real-time listener
                liveDashboardListener = db.collection('document-queue')
                    .where('date', '==', today)
                    .where('status', '==', 'pending-recruiter-contact')
                    .onSnapshot((snapshot) => {
                        console.log('üî¥ Live update:', snapshot.size, 'pending completions');
                        
                        // Update count
                        if (countDiv) countDiv.textContent = snapshot.size;
                        
                        // Update time
                        if (updateDiv) updateDiv.textContent = new Date().toLocaleTimeString();
                        
                        // Update content
                        if (snapshot.empty) {
                            contentDiv.innerHTML = `
                                <div style="text-align: center; padding: 30px 0;">
                                    <div style="font-size: 48px; margin-bottom: 15px;">‚úÖ</div>
                                    <div style="font-size: 20px; font-weight: bold; margin-bottom: 5px;">All Clear!</div>
                                    <div style="font-size: 16px; opacity: 0.8;">No pending document completions</div>
                                </div>
                            `;
                        } else {
                            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">';
                            
                            snapshot.forEach(doc => {
                                const completion = doc.data();
                                html += `
                                    <div style="background: white; color: #333; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                            <h4 style="margin: 0; color: #ff6b6b; font-size: 18px;">üë§ ${completion.name}</h4>
                                            <span style="background: #dc3545; color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">Queue #${completion.queueNumber}</span>
                                        </div>
                                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">
                                            üë• ${completion.assignedRecruiter}
                                        </div>
                                        <div style="font-size: 12px; color: #999;">
                                            ‚è∞ ${completion.completedAt || 'Recently completed'}
                                        </div>
                                        <div style="margin-top: 10px; font-size: 11px;">
                                            <span style="color: ${false ? '#28a745' : '#dc3545'};">OB365:${false ? '‚úì' : '‚ùå'}</span> | 
                                            <span style="color: ${false ? '#28a745' : '#dc3545'};">Drug:${false ? '‚úì' : '‚ùå'}</span> | 
                                            <span style="color: ${false ? '#28a745' : '#dc3545'};">I-9:${false ? '‚úì' : '‚ùå'}</span> | 
                                            <span style="color: ${false ? '#28a745' : '#6c757d'};">FP:${false ? '‚úì' : 'N/A'}</span>
                                        </div>
                                    </div>
                                `;
                            });
                            
                            html += '</div>';
                            contentDiv.innerHTML = html;
                        }
                        
                    }, (error) => {
                        console.error('‚ùå Live dashboard error:', error);
                        if (contentDiv) {
                            contentDiv.innerHTML = `
                                <div style="text-align: center; padding: 30px 0; color: #ffcccc;">
                                    <div style="font-size: 32px; margin-bottom: 10px;">‚ùå</div>
                                    <div style="font-size: 16px;">Error loading data</div>
                                </div>
                            `;
                        }
                    });
                
                console.log('‚úÖ Live dashboard listener set up successfully');
                
            } catch (error) {
                console.error('‚ùå Error setting up live dashboard:', error);
            }
        }
        
        // Auto-load live dashboard when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Don't start dashboard on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Document completion page - skipping live dashboard startup');
                return;
            }
            
            console.log('üî¥ DOM loaded, starting live dashboard in 2 seconds...');
            setTimeout(() => {
                loadLiveDashboard();
            }, 2000);
        });
        
        // Also try loading when window loads (backup)
        window.addEventListener('load', function() {
            // Don't start dashboard on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Document completion page - skipping window load dashboard');
                return;
            }
            
            console.log('üî¥ Window loaded, ensuring live dashboard is running...');
            setTimeout(() => {
                if (!liveDashboardListener) {
                    loadLiveDashboard();
                }
            }, 3000);
        });
        
        // Make it globally available for manual testing
        window.loadLiveDashboard = loadLiveDashboard;
        
        // ===== STAFF DASHBOARD COMPLETIONS (FOR ALL STAFF) =====
        
        let staffCompletionsListener = null;
        
        // Load staff completions dashboard - visible to ALL staff
        function loadStaffCompletions() {
            console.log('üìã ===== LOADING STAFF COMPLETIONS DASHBOARD =====');
            console.log('üìã For ALL staff members - no special permissions needed');
            
            const listDiv = document.getElementById('staff-completions-list');
            const countDiv = document.getElementById('staff-completions-count');
            const completedTodayDiv = document.getElementById('staff-completed-today');
            const totalPendingDiv = document.getElementById('staff-total-pending');
            const lastUpdateDiv = document.getElementById('staff-last-update');
            
            if (!listDiv) {
                console.log('‚ùå Staff completions elements not found');
                return;
            }
            
            console.log('‚úÖ Staff completions elements found, setting up...');
            
            // Remove existing listener
            if (staffCompletionsListener) {
                staffCompletionsListener();
                staffCompletionsListener = null;
            }
            
            try {
                const today = new Date().toISOString().split('T')[0];
                
                // Real-time listener for ALL completions today
                staffCompletionsListener = db.collection('document-queue')
                    .where('date', '==', today)
                    .onSnapshot((snapshot) => {
                        console.log('üìã Staff dashboard update:', snapshot.size, 'total completions today');
                        
                        // Update last update time
                        if (lastUpdateDiv) lastUpdateDiv.textContent = new Date().toLocaleTimeString();
                        
                        // Count pending vs completed
                        let pendingCount = 0;
                        let completedCount = 0;
                        const pendingCompletions = [];
                        
                        snapshot.forEach(doc => {
                            const completion = doc.data();
                            if (completion.status === 'pending-recruiter-contact') {
                                pendingCount++;
                                pendingCompletions.push({ id: doc.id, ...completion });
                            } else {
                                completedCount++;
                            }
                        });
                        
                        // Update counters
                        if (countDiv) countDiv.textContent = pendingCount;
                        if (completedTodayDiv) completedTodayDiv.textContent = completedCount;
                        if (totalPendingDiv) totalPendingDiv.textContent = pendingCount;
                        
                        // Display completions
                        if (pendingCount === 0) {
                            listDiv.innerHTML = `
                                <div style="text-align: center; padding: 40px 0;">
                                    <div style="font-size: 48px; margin-bottom: 15px;">‚úÖ</div>
                                    <div style="font-size: 22px; font-weight: bold; margin-bottom: 8px;">All Clear!</div>
                                    <div style="font-size: 16px; opacity: 0.9;">No pending document completions</div>
                                    <div style="font-size: 14px; opacity: 0.7; margin-top: 10px;">Total completed today: ${completedCount}</div>
                                </div>
                            `;
                            return;
                        }
                        
                        // Sort by queue number
                        pendingCompletions.sort((a, b) => a.queueNumber - b.queueNumber);
                        
                        // Group by recruiter for display
                        const byRecruiter = {};
                        pendingCompletions.forEach(completion => {
                            const recruiterName = completion.assignedRecruiter || 'Unassigned';
                            if (!byRecruiter[recruiterName]) {
                                byRecruiter[recruiterName] = [];
                            }
                            byRecruiter[recruiterName].push(completion);
                        });
                        
                        // Build HTML
                        let html = '<div style="display: grid; gap: 20px;">';
                        
                        Object.keys(byRecruiter).forEach(recruiterName => {
                            const recruiterCompletions = byRecruiter[recruiterName];
                            const isCurrentUser = currentUser && recruiterCompletions.some(c => c.recruiterEmail === currentUser.email);
                            
                            html += `
                                <div style="background: ${isCurrentUser ? 'rgba(40, 167, 69, 0.2)' : 'rgba(255,255,255,0.15)'}; padding: 20px; border-radius: 10px; border: ${isCurrentUser ? '2px solid rgba(40, 167, 69, 0.5)' : '1px solid rgba(255,255,255,0.2)'};">  
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                        <h4 style="margin: 0; font-size: 18px; ${isCurrentUser ? 'color: #90EE90;' : ''}">
                                            ${isCurrentUser ? 'üë§ YOUR ASSIGNMENTS: ' : 'üë• '}${recruiterName}
                                        </h4>
                                        <span style="background: ${isCurrentUser ? '#28a745' : 'rgba(255,255,255,0.3)'}; color: white; padding: 6px 12px; border-radius: 15px; font-size: 14px; font-weight: bold;">
                                            ${recruiterCompletions.length} candidate${recruiterCompletions.length !== 1 ? 's' : ''}
                                        </span>
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                            `;
                            
                            recruiterCompletions.forEach(completion => {
                                html += `
                                    <div style="background: white; color: #333; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                            <h5 style="margin: 0; color: #ff6b6b; font-size: 16px;">üë§ ${completion.name}</h5>
                                            <span style="background: #dc3545; color: white; padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">Queue #${completion.queueNumber}</span>
                                        </div>
                                        <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                                            ‚è∞ ${completion.completedAt || 'Recently completed'}
                                        </div>
                                        <div style="font-size: 11px; display: flex; gap: 8px; flex-wrap: wrap;">
                                            <span style="padding: 2px 6px; border-radius: 10px; ${false ? 'background: #d4edda; color: #155724;' : 'background: #f8d7da; color: #721c24;'}">
                                                OB365:${false ? '‚úì' : '‚ùå'}
                                            </span>
                                            <span style="padding: 2px 6px; border-radius: 10px; ${false ? 'background: #d4edda; color: #155724;' : 'background: #f8d7da; color: #721c24;'}">
                                                Drug:${false ? '‚úì' : '‚ùå'}
                                            </span>
                                            <span style="padding: 2px 6px; border-radius: 10px; ${false ? 'background: #d4edda; color: #155724;' : 'background: #f8d7da; color: #721c24;'}">
                                                I-9:${false ? '‚úì' : '‚ùå'}
                                            </span>
                                            <span style="padding: 2px 6px; border-radius: 10px; ${false ? 'background: #d4edda; color: #155724;' : 'background: #fff3cd; color: #856404;'}">
                                                FP:${false ? '‚úì' : 'N/A'}
                                            </span>
                                        </div>
                                        ${isCurrentUser ? `<div style="text-align: center; margin-top: 10px;"><button onclick="markAsContacted('${completion.id}')" style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 11px; cursor: pointer;">üìû Contact</button></div>` : ''}
                                    </div>
                                `;
                            });
                            
                            html += '</div></div>';
                        });
                        
                        html += '</div>';
                        listDiv.innerHTML = html;
                        
                    }, (error) => {
                        console.error('‚ùå Staff completions error:', error);
                        if (listDiv) {
                            listDiv.innerHTML = `
                                <div style="text-align: center; padding: 30px 0; color: rgba(255,255,255,0.8);">
                                    <div style="font-size: 32px; margin-bottom: 10px;">‚ùå</div>
                                    <div style="font-size: 16px;">Error loading completions</div>
                                    <div style="font-size: 14px; opacity: 0.7; margin-top: 5px;">Please refresh the page</div>
                                </div>
                            `;
                        }
                    });
                
            } catch (error) {
                console.error('‚ùå Error setting up staff completions:', error);
            }
        }
        
        // Auto-load staff completions when dashboard loads
        function loadDashboardData() {
            console.log('üìã Loading dashboard data - including staff completions');
            showDashboardSection('my-visits');
            
            // Always load staff completions for everyone
            setTimeout(() => {
                loadStaffCompletions();
            }, 1000);
        }
        
        // Make it globally available
        window.loadStaffCompletions = loadStaffCompletions;
        
        // ===== SUPER SIMPLE COMPLETIONS DISPLAY =====
        
        let simpleCompletionsListener = null;
        
        // Load super simple completions display
        function loadSimpleCompletionsDisplay() {
            console.log('üü° Loading SIMPLE completions display');
            
            const displayDiv = document.getElementById('simple-completions-display');
            if (!displayDiv) {
                console.log('Simple display div not found');
                return;
            }
            
            // Remove existing listener
            if (simpleCompletionsListener) {
                simpleCompletionsListener();
                simpleCompletionsListener = null;
            }
            
            const today = new Date().toISOString().split('T')[0];
            
            // Simple listener
            simpleCompletionsListener = db.collection('document-queue')
                .where('date', '==', today)
                .where('status', '==', 'pending-recruiter-contact')
                .onSnapshot((snapshot) => {
                    console.log('üü° Simple update:', snapshot.size, 'completions');
                    
                    if (snapshot.empty) {
                        displayDiv.innerHTML = '<p style="color: #28a745; font-weight: bold; margin: 0;">‚úÖ No pending document completions!</p>';
                        return;
                    }
                    
                    let html = '<div style="font-size: 14px; line-height: 1.8;">';
                    
                    snapshot.forEach((doc, index) => {
                        const comp = doc.data();
                        html += `
                            <div style="background: white; padding: 12px; margin: 8px 0; border-radius: 6px; border-left: 4px solid #dc3545;">
                                <strong>üë§ ${comp.name}</strong> (Queue #${comp.queueNumber}) 
                                ‚Üí <span style="color: #0066cc;">üë• ${comp.assignedRecruiter}</span>
                                <br>
                                <small style="color: #666;">‚è∞ ${comp.completedAt || 'Recently completed'}</small>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                    displayDiv.innerHTML = html;
                }, (error) => {
                    console.error('Simple completions error:', error);
                    displayDiv.innerHTML = '<p style="color: #dc3545; margin: 0;">Error loading completions</p>';
                });
        }
        
        // Auto-load when My Visits loads
        const originalLoadMyVisits = window.loadMyVisits || function() {};
        window.loadMyVisits = function() {
            // Don't start listeners on document-completion page
            if (window.location.hash === '#document-completion-form') {
                console.log('üìÑ Skipping My Visits + Simple Completions on document-completion page');
                return;
            }
            
            console.log('üü° Loading My Visits + Simple Completions');
            originalLoadMyVisits();
            setTimeout(() => {
                loadSimpleCompletionsDisplay();
            }, 1000);
        };
        
        // Also load when dashboard loads
        const originalLoadDashboardData = window.loadDashboardData || function() {};
        window.loadDashboardData = function() {
            originalLoadDashboardData();
            setTimeout(() => {
                loadSimpleCompletionsDisplay();
            }, 2000);
        };
        
        // Make globally available
        window.loadSimpleCompletionsDisplay = loadSimpleCompletionsDisplay;
        
        // ===== SUPER SIMPLE ADMIN FUNCTIONS =====
        
        // Admin reset queue - super simple
        async function adminResetQueue() {
            const password = prompt('Enter admin password to reset queue numbers:');
            if (password !== 'admin123') {
                alert('Wrong password!');
                return;
            }
            
            if (!confirm('Reset ALL queue numbers back to 1? This cannot be undone.')) {
                return;
            }
            
            try {
                const today = new Date().toISOString().split('T')[0];
                
                // Reset the counter
                await db.collection('daily-counters').doc(today).set({
                    lastQueueNumber: 0,
                    date: today,
                    resetAt: new Date().toISOString(),
                    resetBy: 'admin'
                });
                
                alert('Queue numbers reset! Next completion will start from #1.');
                
            } catch (error) {
                console.error('Reset error:', error);
                alert('Error resetting queue. Check console.');
            }
        }
        
        // Show completions in alert (emergency backup)
        async function showCompletionsAlert() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const snapshot = await db.collection('document-queue')
                    .where('date', '==', today)
                    .where('status', '==', 'pending-recruiter-contact')
                    .get();
                
                if (snapshot.empty) {
                    alert('No pending document completions today!');
                    return;
                }
                
                let message = `DOCUMENT COMPLETIONS (${snapshot.size} pending):\n\n`;
                
                // Process each completion with PC/RR check
                for (const doc of snapshot.docs) {
                    const comp = doc.data();
                    const pcrrStatus = await checkPCRRStatus(comp.name);
                    
                    message += `${snapshot.docs.indexOf(doc) + 1}. ${comp.name} (Queue #${comp.queueNumber})\n`;
                    message += `   Assigned to: ${comp.assignedRecruiter}\n`;
                    message += `   Completed: ${comp.completedAt || 'Unknown time'}\n`;
                    
                    // Add PC/RR status with detailed info like info sessions
                    if (pcrrStatus.found) {
                        message += `   üö® ‚ö†Ô∏è PC/RR ALERT - VERIFY SSN! üö®\n`;
                        pcrrStatus.matches.forEach(match => {
                            message += `      - Code: ${match.code} | SSN: ***${match.ssn ? match.ssn.slice(-4) : 'N/A'}\n`;
                        });
                    } else {
                        message += `   ‚úÖ PC/RR: Clear - Not in exclusion list\n`;
                    }
                    
                    message += '\n';
                }
                
                alert(message);
                
            } catch (error) {
                alert('Error loading completions: ' + error.message);
            }
        }
        
        // Test PC/RR status function for debugging
        async function testPCRRStatus() {
            try {
                const testName = prompt('Enter a name to test PC/RR status (e.g., "John Smith"):');
                if (!testName) return;
                
                console.log('üß™ Testing PC/RR status for:', testName);
                
                // Check exclusion list first
                const exclusionDoc = await db.collection('settings').doc('exclusion-list').get();
                if (!exclusionDoc.exists) {
                    alert('‚ùå No exclusion list found in database!');
                    return;
                }
                
                const exclusionData = exclusionDoc.data().data || [];
                console.log('üß™ Exclusion list contains', exclusionData.length, 'records');
                
                if (exclusionData.length === 0) {
                    alert('‚ùå Exclusion list is empty!');
                    return;
                }
                
                // Test the PC/RR check function
                const result = await checkPCRRStatus(testName);
                
                let message = `PC/RR TEST RESULTS for "${testName}":\n\n`;
                message += `Exclusion list size: ${exclusionData.length} records\n`;
                message += `Match found: ${result.found ? 'YES' : 'NO'}\n\n`;
                
                if (result.found) {
                    message += `MATCHES FOUND (${result.matches.length}):\n`;
                    result.matches.forEach((match, index) => {
                        message += `${index + 1}. Name: ${match.name}\n`;
                        message += `   Status: ${match.code}\n`;
                        message += `   SSN (last 4): ${match.ssn || 'N/A'}\n\n`;
                    });
                } else {
                    message += `No matches found in exclusion list.\n\n`;
                    message += `Sample exclusion list entries:\n`;
                    exclusionData.slice(0, 3).forEach((record, index) => {
                        message += `${index + 1}. ${record.name} (${record.code})\n`;
                    });
                }
                
                alert(message);
                
            } catch (error) {
                console.error('‚ùå Error in PC/RR test:', error);
                alert('Error testing PC/RR status: ' + error.message);
            }
        }

        // Check current data function for debugging
        async function checkCurrentData() {
            try {
                const collections = [
                    { name: 'visits', displayName: 'Visits', key: 'visits' },
                    { name: 'badges', displayName: 'Badges', key: 'badges' },
                    { name: 'fingerprints', displayName: 'Fingerprints', key: 'fingerprints' },
                    { name: 'info-sessions', displayName: 'Info Sessions', key: 'infoSessions' },
                    { name: 'new-hire-orientations', displayName: 'New Hire Orientations', key: 'newHireOrientations' }
                ];
                
                let message = 'CURRENT DATA COUNTS:\n\n';
                let totalRecords = 0;
                
                for (const collection of collections) {
                    const snapshot = await db.collection(collection.name).get();
                    const count = snapshot.size;
                    totalRecords += count;
                    message += `${collection.displayName}: ${count} records\n`;
                    
                    // Show recent entries
                    if (count > 0) {
                        message += `  Recent entries:\n`;
                        snapshot.docs.slice(0, 3).forEach((doc, index) => {
                            const data = doc.data();
                            const name = data.name || 'N/A';
                            const timeStr = data.submittedAt ? new Date(data.submittedAt.seconds * 1000).toLocaleDateString() : 'N/A';
                            message += `    ${index + 1}. ${name} (${timeStr})\n`;
                        });
                    }
                    message += '\n';
                }
                
                message += `TOTAL RECORDS: ${totalRecords}\n\n`;
                
                // Check if there are archives
                const today = new Date().toISOString().split('T')[0];
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toISOString().split('T')[0];
                
                const todayArchive = await db.collection('daily-archives').doc(today).get();
                const yesterdayArchive = await db.collection('daily-archives').doc(yesterdayStr).get();
                
                message += `ARCHIVES:\n`;
                message += `Today (${today}): ${todayArchive.exists ? 'EXISTS' : 'NOT FOUND'}\n`;
                message += `Yesterday (${yesterdayStr}): ${yesterdayArchive.exists ? 'EXISTS' : 'NOT FOUND'}\n`;
                
                if (yesterdayArchive.exists) {
                    const archiveData = yesterdayArchive.data();
                    message += `  Yesterday archive contains:\n`;
                    Object.keys(archiveData).forEach(key => {
                        const count = archiveData[key] ? archiveData[key].length : 0;
                        message += `    ${key}: ${count} records\n`;
                    });
                }
                
                alert(message);
                
            } catch (error) {
                console.error('Error checking current data:', error);
                alert('Error checking data: ' + error.message);
            }
        }

        // Debug function to check all staff records
        async function debugStaffRecords() {
            console.log('üîç === DEBUGGING STAFF RECORDS ===');
            
            try {
                // Query all staff records
                const staffSnapshot = await db.collection('staff').orderBy('name').get();
                
                console.log(`\nüìä Total staff records found: ${staffSnapshot.size}\n`);
                
                let message = `STAFF RECORDS DEBUG\n`;
                message += `===================\n\n`;
                message += `Total staff records: ${staffSnapshot.size}\n\n`;
                
                let recruitingTeamMembers = [];
                let allStaffData = [];
                
                staffSnapshot.forEach(doc => {
                    const staffData = doc.data();
                    const staffInfo = {
                        id: doc.id,
                        name: staffData.name || 'N/A',
                        email: staffData.email || 'N/A',
                        team: staffData.team || 'N/A',
                        title: staffData.title || 'N/A'
                    };
                    
                    allStaffData.push(staffInfo);
                    
                    // Console log each staff member
                    console.log(`üë§ ${staffInfo.name}`);
                    console.log(`   Email: ${staffInfo.email}`);
                    console.log(`   Team: ${staffInfo.team}`);
                    console.log(`   Title: ${staffInfo.title}`);
                    console.log(`   ID: ${staffInfo.id}`);
                    
                    // Check for Miccael specifically
                    if (staffInfo.name.toLowerCase().includes('miccael') || 
                        staffInfo.email.toLowerCase().includes('miccael')) {
                        console.log('üéØ FOUND MICCAEL!');
                        console.log(`   Full details: Name="${staffInfo.name}", Email="${staffInfo.email}", Team="${staffInfo.team}", Title="${staffInfo.title}"`);
                    }
                    
                    // Track recruiting team members
                    if (staffInfo.team && staffInfo.team.toLowerCase() === 'recruiting') {
                        recruitingTeamMembers.push(staffInfo);
                        console.log('üéØ RECRUITING TEAM MEMBER FOUND!');
                    }
                    
                    console.log(''); // Empty line for readability
                });
                
                // Add all staff to message
                message += `ALL STAFF MEMBERS:\n`;
                message += `==================\n`;
                allStaffData.forEach(staff => {
                    message += `${staff.name} (${staff.email})\n`;
                    message += `  Team: ${staff.team}\n`;
                    message += `  Title: ${staff.title}\n`;
                    
                    // Highlight Miccael if found
                    if (staff.name.toLowerCase().includes('miccael') || 
                        staff.email.toLowerCase().includes('miccael')) {
                        message += `  >>> MICCAEL FOUND! <<<\n`;
                    }
                    
                    message += `\n`;
                });
                
                // Add recruiting team summary
                message += `\nRECRUITING TEAM MEMBERS:\n`;
                message += `========================\n`;
                
                if (recruitingTeamMembers.length === 0) {
                    message += `No recruiting team members found.\n`;
                    console.log('‚ùå No recruiting team members found');
                } else {
                    console.log(`\nüéØ === RECRUITING TEAM SUMMARY ===`);
                    console.log(`Found ${recruitingTeamMembers.length} recruiting team members:`);
                    
                    recruitingTeamMembers.forEach(recruiter => {
                        message += `${recruiter.name} (${recruiter.email})\n`;
                        message += `  Title: ${recruiter.title}\n\n`;
                        
                        console.log(`üéØ ${recruiter.name} - ${recruiter.email} - ${recruiter.title}`);
                    });
                }
                
                // Search for variations of Miccael
                console.log(`\nüîç === SEARCHING FOR MICCAEL VARIATIONS ===`);
                const miccaelVariations = ['miccael', 'micael', 'michael', 'mikael'];
                let miccaelFound = false;
                
                miccaelVariations.forEach(variation => {
                    const foundStaff = allStaffData.filter(staff => 
                        staff.name.toLowerCase().includes(variation) || 
                        staff.email.toLowerCase().includes(variation)
                    );
                    
                    if (foundStaff.length > 0) {
                        console.log(`üéØ Found "${variation}" matches:`, foundStaff);
                        miccaelFound = true;
                        
                        message += `\nFOUND "${variation.toUpperCase()}" MATCHES:\n`;
                        foundStaff.forEach(staff => {
                            message += `  ${staff.name} (${staff.email}) - Team: ${staff.team}\n`;
                        });
                    }
                });
                
                if (!miccaelFound) {
                    console.log('‚ùå No variations of "Miccael" found in staff records');
                    message += `\n‚ùå No variations of "Miccael" found in staff records\n`;
                }
                
                // Show results in alert and console
                alert(message);
                console.log('‚úÖ Debug completed. Check console for detailed output.');
                
                return {
                    totalStaff: allStaffData.length,
                    recruitingTeam: recruitingTeamMembers,
                    allStaff: allStaffData,
                    miccaelFound: miccaelFound
                };
                
            } catch (error) {
                console.error('‚ùå Error debugging staff records:', error);
                alert('Error debugging staff records: ' + error.message);
                throw error;
            }
        }

        // Debug orientation counts discrepancy
        async function debugOrientationCounts() {
            try {
                // Get all orientations (like booking counts does)
                const allOrientationsSnapshot = await db.collection('new-hire-orientations').get();
                const allCount = allOrientationsSnapshot.size;
                
                // Get today's orientations (like daily statistics does)
                const today = new Date().toISOString().split('T')[0];
                const todayOrientationsSnapshot = await db.collection('new-hire-orientations').where('date', '==', today).get();
                const todayCount = todayOrientationsSnapshot.size;
                
                let message = `ORIENTATION COUNTS DEBUG:\n\n`;
                message += `ALL ORIENTATIONS (Booking Counts): ${allCount}\n`;
                message += `TODAY'S ORIENTATIONS (Daily Statistics): ${todayCount}\n\n`;
                
                // Show breakdown by date
                const orientationsByDate = {};
                allOrientationsSnapshot.forEach(doc => {
                    const data = doc.data();
                    const date = data.date;
                    if (!orientationsByDate[date]) {
                        orientationsByDate[date] = 0;
                    }
                    orientationsByDate[date]++;
                });
                
                message += `BREAKDOWN BY DATE:\n`;
                Object.keys(orientationsByDate).sort().forEach(date => {
                    const count = orientationsByDate[date];
                    const isToday = date === today;
                    message += `${date}: ${count} orientations ${isToday ? '(TODAY)' : ''}\n`;
                });
                
                message += `\nThis explains the discrepancy:`;
                message += `\n- Booking Counts = ALL dates combined`;
                message += `\n- Daily Statistics = Only TODAY's date`;
                
                alert(message);
                
            } catch (error) {
                console.error('Error debugging orientation counts:', error);
                alert('Error debugging counts: ' + error.message);
            }
        }

        // Debug function for specific date data
        async function debugDateData(dateStr) {
            console.log(`üîç === DEBUGGING DATA FOR ${dateStr} ===`);
            
            const collections = [
                { name: 'visits', key: 'visits' },
                { name: 'info-sessions', key: 'infoSessions' },
                { name: 'new-hire-orientations', key: 'orientations' },
                { name: 'fingerprints', key: 'fingerprints' },
                { name: 'badges', key: 'badges' }
            ];
            
            let message = `DATA DEBUG FOR ${dateStr}:\n\n`;
            message += `=== CURRENT COLLECTIONS ===\n`;
            
            for (const collection of collections) {
                try {
                    const snapshot = await db.collection(collection.name).where('date', '==', dateStr).get();
                    message += `${collection.name}: ${snapshot.size} records\n`;
                    if (snapshot.size > 0) {
                        snapshot.forEach(doc => {
                            const data = doc.data();
                            message += `  - ${data.name || data.id} (${data.date})\n`;
                        });
                    }
                } catch (error) {
                    message += `${collection.name}: ERROR - ${error.message}\n`;
                }
            }
            
            message += `\n=== ARCHIVED DATA ===\n`;
            try {
                const archiveSnapshot = await db.collection('daily-archives').doc(dateStr).get();
                if (archiveSnapshot.exists) {
                    const archiveData = archiveSnapshot.data();
                    message += `Archive document exists for ${dateStr}\n`;
                    message += `Archive keys: ${Object.keys(archiveData).join(', ')}\n`;
                    
                    Object.keys(archiveData).forEach(key => {
                        if (Array.isArray(archiveData[key])) {
                            const filtered = archiveData[key].filter(item => item.date === dateStr);
                            message += `${key}: ${archiveData[key].length} total, ${filtered.length} for ${dateStr}\n`;
                        }
                    });
                } else {
                    message += `No archive document found for ${dateStr}\n`;
                }
            } catch (error) {
                message += `Archive check ERROR: ${error.message}\n`;
            }
            
            message += `\n=== getDailyStatistics RESULT ===\n`;
            try {
                const stats = await getDailyStatistics(dateStr);
                message += `Visits: ${stats.visits}\n`;
                message += `Info Sessions: ${stats.infoSessions.total}\n`;
                message += `Orientations: ${stats.orientations.total}\n`;
                message += `Fingerprints: ${stats.fingerprints}\n`;
                message += `Badges: ${stats.badges}\n`;
                message += `Total: ${stats.visits + stats.infoSessions.total + stats.orientations.total + stats.fingerprints + stats.badges}\n`;
            } catch (error) {
                message += `getDailyStatistics ERROR: ${error.message}\n`;
            }
            
            console.log(message);
            alert(message);
        }

        // Make functions globally available
        window.adminResetQueue = adminResetQueue;
        window.showCompletionsAlert = showCompletionsAlert;
        window.testPCRRStatus = testPCRRStatus;
        window.checkCurrentData = checkCurrentData;
        window.performDailyArchive = performDailyArchive;
        window.debugOrientationCounts = debugOrientationCounts;
        window.debugStaffRecords = debugStaffRecords;
        window.debugDateData = debugDateData;
        window.debugDocumentQueue = debugDocumentQueue;
        window.debugDocumentCompletions = debugDocumentCompletions;
        window.debugNewDocumentFlow = debugNewDocumentFlow;
        window.searchArchiveData = searchArchiveData;
        window.recoverDataFromArchive = recoverDataFromArchive;
        window.enableAutoSave = enableAutoSave;
        window.saveCurrentSession = saveCurrentSession;
        window.recoverLastSession = recoverLastSession;
        
        // Auto-save system to prevent data loss
        let autoSaveInterval = null;
        let sessionData = {};
        
        function enableAutoSave() {
            console.log('üíæ Enabling auto-save system...');
            
            // Clear existing interval
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
            }
            
            // Save every 30 seconds
            autoSaveInterval = setInterval(async () => {
                await saveCurrentSession();
            }, 30000);
            
            // Also save on page unload
            window.addEventListener('beforeunload', saveCurrentSession);
            
            console.log('‚úÖ Auto-save enabled (every 30 seconds)');
        }
        
        async function saveCurrentSession() {
            try {
                const timestamp = new Date().toISOString();
                const sessionKey = `session_${new Date().toISOString().split('T')[0]}`;
                
                // Collect current session data
                sessionData = {
                    timestamp: timestamp,
                    currentUser: currentUser ? currentUser.email : null,
                    currentSection: getCurrentVisibleSection(),
                    documentCompletions: window.allDocumentCompletions || [],
                    lastActivity: timestamp,
                    autoSaved: true
                };
                
                // Save to localStorage as backup
                localStorage.setItem(sessionKey, JSON.stringify(sessionData));
                
                // Also save to Firebase for persistence
                if (currentUser) {
                    await db.collection('session-backups').doc(`${currentUser.email}_${sessionKey}`).set({
                        ...sessionData,
                        savedAt: new Date().toISOString()
                    }, { merge: true });
                }
                
                console.log('üíæ Session auto-saved at', timestamp);
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Auto-save failed:', error);
            }
        }
        
        function getCurrentVisibleSection() {
            const sections = document.querySelectorAll('.dashboard-section');
            for (let section of sections) {
                if (section.style.display !== 'none') {
                    return section.id || 'unknown';
                }
            }
            return 'none';
        }
        
        // Initialize auto-save when user logs in
        function initAutoSave() {
            if (currentUser) {
                enableAutoSave();
                console.log('üîí Auto-save initialized for user:', currentUser.email);
                
                // Check if there's a recent session to recover
                checkForRecoverableSession();
            }
        }
        
        async function checkForRecoverableSession() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const sessionKey = `session_${today}`;
                
                // Check localStorage first
                const localSession = localStorage.getItem(sessionKey);
                if (localSession) {
                    const sessionData = JSON.parse(localSession);
                    const sessionTime = new Date(sessionData.timestamp);
                    const now = new Date();
                    const hoursDiff = (now - sessionTime) / (1000 * 60 * 60);
                    
                    // If session is less than 2 hours old, offer to recover
                    if (hoursDiff < 2) {
                        console.log('üí° Found recent session data that can be recovered');
                        if (confirm(`üíæ SESSION RECOVERY\n\nA recent session was found saved ${Math.round(hoursDiff * 60)} minutes ago.\n\nWould you like to recover the previous session data?`)) {
                            await recoverLastSession();
                        }
                    }
                }
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Error checking for recoverable session:', error);
            }
        }
        
        async function recoverLastSession() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const sessionKey = `session_${today}`;
                
                // Try localStorage first
                const localSession = localStorage.getItem(sessionKey);
                if (localSession) {
                    const sessionData = JSON.parse(localSession);
                    console.log('üîÑ Recovering session from localStorage:', sessionData.timestamp);
                    
                    // Restore document completions if available
                    if (sessionData.documentCompletions && sessionData.documentCompletions.length > 0) {
                        window.allDocumentCompletions = sessionData.documentCompletions;
                        console.log('üìã Restored', sessionData.documentCompletions.length, 'document completions');
                        
                        // Refresh the current view
                        if (sessionData.currentSection === 'document-completions') {
                            loadDocumentCompletions();
                        }
                    }
                    
                    showSuccessMessage('‚úÖ Sesi√≥n anterior recuperada exitosamente');
                    return 'Session recovered from localStorage';
                }
                
                // Try Firebase backup
                if (currentUser) {
                    const backupDoc = await db.collection('session-backups').doc(`${currentUser.email}_${sessionKey}`).get();
                    if (backupDoc.exists) {
                        const sessionData = backupDoc.data();
                        console.log('üîÑ Recovering session from Firebase:', sessionData.timestamp);
                        
                        // Restore data similar to localStorage recovery
                        if (sessionData.documentCompletions && sessionData.documentCompletions.length > 0) {
                            window.allDocumentCompletions = sessionData.documentCompletions;
                            console.log('üìã Restored', sessionData.documentCompletions.length, 'document completions from Firebase');
                        }
                        
                        showSuccessMessage('‚úÖ Sesi√≥n recuperada desde respaldo en nube');
                        return 'Session recovered from Firebase';
                    }
                }
                
                console.log('‚ùå No recoverable session found');
                return 'No recoverable session found';
                
            } catch (error) {
                console.error('‚ùå Error recovering session:', error);
                return 'Error during session recovery';
            }
        }
        
        // Search archive data for recovery
        async function searchArchiveData(targetDate, targetTime = '9') {
            console.log('üîç ===== SEARCHING ARCHIVE DATA =====');
            console.log('üìÖ Target date:', targetDate);
            console.log('üïò Target time (hour):', targetTime);
            
            try {
                // Search daily archives
                console.log('üìÅ Searching daily-archives collection...');
                const archiveDoc = await db.collection('daily-archives').doc(targetDate).get();
                
                if (archiveDoc.exists) {
                    const archiveData = archiveDoc.data();
                    console.log('‚úÖ Archive found for', targetDate);
                    console.log('üìä Archive contains:');
                    
                    // Check visits
                    if (archiveData.visits && archiveData.visits.length > 0) {
                        console.log('üë• Visits found:', archiveData.visits.length);
                        archiveData.visits.forEach((visit, index) => {
                            const visitTime = visit.timestamp ? new Date(visit.timestamp) : new Date(visit.time);
                            const hour = visitTime.getHours();
                            
                            if (hour.toString() === targetTime || hour === parseInt(targetTime)) {
                                console.log(`üìã MATCH - Visit ${index + 1}:`, {
                                    name: visit.name,
                                    time: visitTime.toLocaleString(),
                                    purpose: visit.purpose,
                                    company: visit.company || 'N/A'
                                });
                            }
                        });
                    }
                    
                    // Check info sessions
                    if (archiveData.infoSessions && archiveData.infoSessions.length > 0) {
                        console.log('üìö Info Sessions found:', archiveData.infoSessions.length);
                        archiveData.infoSessions.forEach((session, index) => {
                            const sessionTime = session.timestamp ? new Date(session.timestamp) : new Date(session.registrationTime);
                            const hour = sessionTime.getHours();
                            
                            if (hour.toString() === targetTime || hour === parseInt(targetTime)) {
                                console.log(`üìã MATCH - Info Session ${index + 1}:`, {
                                    name: session.name,
                                    time: sessionTime.toLocaleString(),
                                    email: session.email,
                                    phone: session.phone
                                });
                            }
                        });
                    }
                    
                    // Check document completions
                    if (archiveData.documentCompletions && archiveData.documentCompletions.length > 0) {
                        console.log('üìã Document Completions found:', archiveData.documentCompletions.length);
                        archiveData.documentCompletions.forEach((completion, index) => {
                            const completionTime = completion.timestamp ? new Date(completion.timestamp) : new Date(completion.completedAt);
                            const hour = completionTime.getHours();
                            
                            if (hour.toString() === targetTime || hour === parseInt(targetTime)) {
                                console.log(`üìã MATCH - Document Completion ${index + 1}:`, {
                                    name: completion.name,
                                    time: completionTime.toLocaleString(),
                                    queueNumber: completion.queueNumber,
                                    status: completion.status
                                });
                            }
                        });
                    }
                    
                } else {
                    console.log('‚ùå No archive found for', targetDate);
                }
                
                // Also search system logs
                console.log('üìù Searching system-logs...');
                const logsSnapshot = await db.collection('system-logs')
                    .where('date', '==', targetDate)
                    .get();
                
                if (!logsSnapshot.empty) {
                    console.log('üìù System logs found:', logsSnapshot.size);
                    logsSnapshot.forEach(doc => {
                        const log = doc.data();
                        if (log.type === 'daily-archive') {
                            console.log('üìÅ Archive log found:', log);
                        }
                    });
                }
                
                return 'Search completed - check console for results';
                
            } catch (error) {
                console.error('‚ùå Error searching archives:', error);
                return 'Error occurred during search';
            }
        }
        
        // Recover data from archive and restore to current collections
        async function recoverDataFromArchive(targetDate, targetTime = '9', confirmRestore = false) {
            console.log('üîÑ ===== RECOVERING DATA FROM ARCHIVE =====');
            console.log('üìÖ Target date:', targetDate);
            console.log('üïò Target time (hour):', targetTime);
            
            if (!confirmRestore) {
                console.log('‚ö†Ô∏è This is a DRY RUN - add true as third parameter to actually restore');
            }
            
            try {
                const archiveDoc = await db.collection('daily-archives').doc(targetDate).get();
                
                if (!archiveDoc.exists) {
                    console.log('‚ùå No archive found for', targetDate);
                    return 'No archive data found for the specified date';
                }
                
                const archiveData = archiveDoc.data();
                let recoveredItems = [];
                let restoredCount = 0;
                
                // Recover visits
                if (archiveData.visits && archiveData.visits.length > 0) {
                    console.log('üë• Processing', archiveData.visits.length, 'archived visits...');
                    
                    for (const visit of archiveData.visits) {
                        const visitTime = visit.timestamp ? new Date(visit.timestamp) : new Date(visit.time);
                        const hour = visitTime.getHours();
                        
                        if (hour.toString() === targetTime || hour === parseInt(targetTime)) {
                            console.log('üìã Found matching visit:', visit.name, 'at', visitTime.toLocaleString());
                            recoveredItems.push({
                                type: 'visit',
                                data: visit
                            });
                            
                            if (confirmRestore) {
                                try {
                                    await db.collection('visits').add({
                                        ...visit,
                                        recovered: true,
                                        recoveredAt: new Date().toISOString(),
                                        recoveredFrom: targetDate
                                    });
                                    restoredCount++;
                                    console.log('‚úÖ Restored visit:', visit.name);
                                } catch (error) {
                                    console.error('‚ùå Failed to restore visit:', visit.name, error);
                                }
                            }
                        }
                    }
                }
                
                console.log('üìä Recovery Summary:');
                console.log('   Items found:', recoveredItems.length);
                console.log('   Items restored:', confirmRestore ? restoredCount : 'DRY RUN - not restored');
                
                if (confirmRestore && restoredCount > 0) {
                    console.log('‚úÖ Data recovery completed successfully!');
                    return `Successfully recovered and restored ${restoredCount} items from ${targetDate}`;
                } else if (recoveredItems.length > 0) {
                    console.log('üí° Found', recoveredItems.length, 'items that can be recovered. Run with confirmRestore=true to actually restore them.');
                    return `Found ${recoveredItems.length} recoverable items. Use recoverDataFromArchive('${targetDate}', '${targetTime}', true) to restore them.`;
                } else {
                    console.log('‚ùå No matching items found for the specified time');
                    return 'No matching items found for recovery';
                }
                
            } catch (error) {
                console.error('‚ùå Error during recovery:', error);
                return 'Error occurred during recovery process';
            }
        }
        
        // Debug new document completion flow
        async function debugNewDocumentFlow() {
            console.log('üîç ===== DEBUG NEW DOCUMENT FLOW =====');
            
            // Check current date formats
            const now = new Date();
            const normalDate = now.toISOString().split('T')[0];
            const workDay = getWorkDay();
            
            console.log('üìÖ Date formats:');
            console.log('   Normal date:', normalDate);
            console.log('   Work day:', workDay);
            console.log('   Current hour:', now.getHours());
            
            // Check what's in document-completions collection for today
            console.log('üìã Checking document-completions collection...');
            const normalDateQuery = await db.collection('document-queue')
                .where('date', '==', normalDate)
                .get();
            
            const workDayQuery = await db.collection('document-queue')
                .where('date', '==', workDay)
                .get();
                
            console.log('üìä Results:');
            console.log('   Normal date (' + normalDate + '):', normalDateQuery.size, 'documents');
            console.log('   Work day (' + workDay + '):', workDayQuery.size, 'documents');
            
            if (normalDateQuery.size > 0) {
                console.log('üìã Documents found for normal date:');
                normalDateQuery.forEach(doc => {
                    const data = doc.data();
                    console.log('   -', data.name, 'Status:', data.status, 'Date:', data.date, 'ID:', doc.id);
                });
            }
            
            if (workDayQuery.size > 0 && workDay !== normalDate) {
                console.log('üìã Documents found for work day:');
                workDayQuery.forEach(doc => {
                    const data = doc.data();
                    console.log('   -', data.name, 'Status:', data.status, 'Date:', data.date, 'ID:', doc.id);
                });
            }
            
            // Check which date the listener is using
            console.log('üîî Current listener is set up for date:', normalDate);
            
            return {
                normalDate,
                workDay,
                normalDateCount: normalDateQuery.size,
                workDayCount: workDayQuery.size
            };
        }

        // Debug Document Queue visibility and functionality
        function debugDocumentQueue() {
            console.log('üîç === DEBUGGING DOCUMENT QUEUE ===');
            
            const button = document.getElementById('document-completions-btn');
            const section = document.getElementById('document-completions');
            const list = document.getElementById('document-completions-list');
            
            console.log('Button exists:', !!button);
            console.log('Button visible:', button ? window.getComputedStyle(button).display !== 'none' : false);
            console.log('Section exists:', !!section);
            console.log('List exists:', !!list);
            
            console.log('Current user:', currentUser ? currentUser.email : 'None');
            console.log('isRecruiting:', typeof isRecruiting !== 'undefined' ? isRecruiting : 'undefined');
            console.log('isManagement:', typeof isManagement !== 'undefined' ? isManagement : 'undefined');
            console.log('isFrontDesk:', typeof isFrontDesk !== 'undefined' ? isFrontDesk : 'undefined');
            console.log('isAdmin:', typeof isAdmin !== 'undefined' ? isAdmin : 'undefined');
            
            // Check specific user
            if (currentUser && currentUser.email === 'rodrigo.bermudez@kellyeducation.com') {
                console.log('üéØ SPECIFIC CHECK FOR rodrigo.bermudez@kellyeducation.com');
                console.log('  - Should have access:', (isRecruiting || isManagement || isAdmin));
                console.log('  - User data:', currentUser);
            }
            
            // Check listeners
            const hasListener = realtimeListeners.some(l => l.type === 'document-completions');
            console.log('Has active listener:', hasListener);
            console.log('Total listeners:', realtimeListeners.length);
            
            // Try to click the button
            if (button) {
                console.log('Attempting to show Document Queue...');
                button.click();
                
                setTimeout(() => {
                    const sectionVisible = section && window.getComputedStyle(section).display !== 'none';
                    console.log('Section visible after click:', sectionVisible);
                    
                    if (list) {
                        console.log('List content:', list.innerHTML.substring(0, 200) + '...');
                    }
                }, 1000);
            }
            
            console.log('=== END DEBUG ===');
        }
        
        // Debug Document Completions data specifically
        async function debugDocumentCompletions() {
            console.log('üîç === DEBUGGING DOCUMENT COMPLETIONS DATA ===');
            
            const today = new Date().toISOString().split('T')[0];
            console.log('Today:', today);
            
            try {
                // Get ALL document completions for today
                const allSnapshot = await db.collection('document-queue')
                    .where('date', '==', today)
                    .get();
                
                console.log('Total completions today:', allSnapshot.size);
                
                // Get pending only
                const pendingSnapshot = await db.collection('document-queue')
                    .where('date', '==', today)
                    .where('status', '==', 'pending-recruiter-contact')
                    .get();
                
                console.log('Pending completions today:', pendingSnapshot.size);
                
                // Get for specific user
                const userEmail = currentUser ? currentUser.email : 'rodrigo.bermudez@kellyeducation.com';
                const userSnapshot = await db.collection('document-queue')
                    .where('date', '==', today)
                    .where('status', '==', 'pending-recruiter-contact')
                    .where('recruiterEmail', '==', userEmail)
                    .get();
                
                console.log(`Completions assigned to ${userEmail}:`, userSnapshot.size);
                
                let message = `DOCUMENT COMPLETIONS DEBUG:\n\n`;
                message += `Date: ${today}\n`;
                message += `Total completions today: ${allSnapshot.size}\n`;
                message += `Pending completions: ${pendingSnapshot.size}\n`;
                message += `Assigned to ${userEmail}: ${userSnapshot.size}\n\n`;
                
                message += `=== ALL COMPLETIONS DETAILS ===\n`;
                allSnapshot.forEach((doc, index) => {
                    const data = doc.data();
                    message += `${index + 1}. ${data.name} - Status: ${data.status} - Assigned to: ${data.recruiterEmail}\n`;
                });
                
                if (pendingSnapshot.size > 0) {
                    message += `\n=== PENDING COMPLETIONS DETAILS ===\n`;
                    pendingSnapshot.forEach((doc, index) => {
                        const data = doc.data();
                        message += `${index + 1}. ${data.name} - Queue: ${data.queueNumber} - Assigned to: ${data.recruiterEmail}\n`;
                        message += `    Timestamp: ${data.timestamp ? new Date(data.timestamp).toLocaleString() : 'N/A'}\n`;
                    });
                }
                
                console.log(message);
                alert(message);
                
            } catch (error) {
                console.error('Error debugging completions:', error);
                alert('Error debugging completions: ' + error.message);
            }
            
            console.log('=== END COMPLETIONS DEBUG ===');
        }
        
        // Function to check and fix recruiter permissions
        async function checkRecruiterPermissions() {
            console.log('üîç === CHECKING RECRUITER PERMISSIONS ===');
            
            try {
                // Get all staff records
                const staffSnapshot = await db.collection('staff').orderBy('name').get();
                
                console.log(`üìä Total staff records: ${staffSnapshot.size}`);
                
                let recruiters = [];
                let needsUpdate = [];
                
                staffSnapshot.forEach(doc => {
                    const staffData = doc.data();
                    const docId = doc.id;
                    
                    console.log(`üë§ ${staffData.name} (${staffData.email}): Team = ${staffData.team || 'NOT SET'}`);
                    
                    // Check for potential recruiters
                    if (staffData.team === 'recruiting') {
                        recruiters.push(staffData);
                        console.log(`‚úÖ ${staffData.name} - RECRUITING permissions OK`);
                    } else if (staffData.name && staffData.name.toLowerCase().includes('micc')) {
                        console.log(`‚ö†Ô∏è  FOUND MICCAEL: ${staffData.name} - Team: ${staffData.team || 'NOT SET'}`);
                        needsUpdate.push({ docId, staffData, suggestedTeam: 'recruiting' });
                    }
                });
                
                console.log(`\nüéØ RECRUITING TEAM MEMBERS (${recruiters.length}):`);
                recruiters.forEach(r => console.log(`   ‚úÖ ${r.name} (${r.email})`));
                
                if (needsUpdate.length > 0) {
                    console.log(`\n‚ö†Ô∏è  NEEDS UPDATE (${needsUpdate.length}):`);
                    needsUpdate.forEach(item => {
                        console.log(`   ‚ùå ${item.staffData.name} - Current team: ${item.staffData.team || 'NOT SET'}`);
                    });
                    
                    // Ask for confirmation to update
                    const shouldUpdate = confirm(`Found ${needsUpdate.length} staff member(s) that might need recruiting permissions.\n\nUpdate them to 'recruiting' team?`);
                    
                    if (shouldUpdate) {
                        for (const item of needsUpdate) {
                            await db.collection('staff').doc(item.docId).update({
                                team: item.suggestedTeam,
                                updatedAt: new Date().toISOString()
                            });
                            console.log(`‚úÖ Updated ${item.staffData.name} to recruiting team`);
                        }
                        alert(`Updated ${needsUpdate.length} staff member(s) to recruiting team!`);
                    }
                }
                
                return {
                    totalStaff: staffSnapshot.size,
                    recruiters: recruiters,
                    needsUpdate: needsUpdate
                };
                
            } catch (error) {
                console.error('‚ùå Error checking recruiter permissions:', error);
                alert('Error checking permissions: ' + error.message);
            }
        }
        
        window.checkRecruiterPermissions = checkRecruiterPermissions;

        // DEBUG FUNCTION FOR STAFF - Check recent document completions
        async function debugRecentCompletions() {
            try {
                console.log('üîç === DEBUG: Recent Document Completions ===');
                
                const today = new Date().toISOString().split('T')[0];
                console.log('üîç Checking date:', today);
                
                // Get all document completions from today, ordered by most recent
                const snapshot = await db.collection('document-queue')
                    .where('date', '==', today)
                    .orderBy('timestamp', 'desc')
                    .limit(10)
                    .get();
                
                console.log('üîç Found', snapshot.size, 'completions for today');
                
                snapshot.forEach((doc, index) => {
                    const data = doc.data();
                    console.log(`üîç ${index + 1}. ID: ${doc.id}`);
                    console.log(`   Name: ${data.name}`);
                    console.log(`   Queue: ${data.queueNumber}`);
                    console.log(`   Time: ${data.time}`);
                    console.log(`   Version: ${data.version || 'old'}`);
                    console.log(`   Simplified: ${data.simplified || false}`);
                    console.log(`   ---`);
                });
                
                // Also try without date filter
                const allRecent = await db.collection('document-queue')
                    .orderBy('timestamp', 'desc')
                    .limit(5)
                    .get();
                    
                console.log('üîç Last 5 submissions (any date):');
                allRecent.forEach((doc, index) => {
                    const data = doc.data();
                    console.log(`üîç ${index + 1}. ${data.name} - Queue: ${data.queueNumber} - Date: ${data.date}`);
                });
                
            } catch (error) {
                console.error('‚ùå Debug error:', error);
            }
        }
        
        window.debugRecentCompletions = debugRecentCompletions;

        // LOAD DOCUMENT COMPLETIONS FOR STAFF - REAL TIME
        let documentCompletionsListener = null;
        
        async function loadStaffDocumentCompletions() {
            if (!currentUser) return;
            
            console.log('üìã === LOADING STAFF DOCUMENT COMPLETIONS ===');
            const listContainer = document.getElementById('simple-completions-display') || 
                                document.getElementById('simple-document-completions-list') || 
                                document.getElementById('document-completions-list') ||
                                document.querySelector('#simple-document-completions .dashboard-content');
            
            if (!listContainer) {
                console.error('‚ùå No container found for document completions');
                return;
            }
            
            listContainer.innerHTML = '<div style="text-align: center; padding: 20px;">Loading document completions...</div>';
            
            try {
                const today = new Date().toISOString().split('T')[0];
                console.log('üìã Loading completions for date:', today);
                
                // Clean up existing listener
                if (documentCompletionsListener) {
                    documentCompletionsListener();
                }
                
                // TEMPORARY FIX: Simple query without orderBy to avoid index requirement
                documentCompletionsListener = db.collection('document-queue')
                    .where('date', '==', today)
                    .onSnapshot((snapshot) => {
                        console.log('üìã Real-time update: Found', snapshot.size, 'completions');
                        
                        if (snapshot.empty) {
                            listContainer.innerHTML = `
                                <div style="text-align: center; padding: 40px; color: #666;">
                                    <div style="font-size: 48px; margin-bottom: 20px;">üìã</div>
                                    <h3>No document completions today</h3>
                                    <p>Completed documents will appear here in real-time</p>
                                    <p style="font-size: 14px; color: #999;">Date: ${today}</p>
                                </div>
                            `;
                            return;
                        }
                        
                        let html = `
                            <div style="background: #e8f5e8; padding: 15px; margin-bottom: 20px; border-radius: 8px;">
                                <h4 style="margin: 0; color: #2e7d32;">üìä Today's Summary</h4>
                                <p style="margin: 5px 0 0 0;"><strong>${snapshot.size}</strong> document completions ‚Ä¢ Date: ${today}</p>
                            </div>
                        `;
                        
                        // Convert to array and sort manually since we can't use orderBy
                        const completions = [];
                        snapshot.forEach((doc) => {
                            completions.push({ id: doc.id, ...doc.data() });
                        });
                        
                        // Sort by timestamp (newest first)
                        completions.sort((a, b) => {
                            const timeA = a.timestamp?.toDate?.() || new Date(a.time || a.completedAt || 0);
                            const timeB = b.timestamp?.toDate?.() || new Date(b.time || b.completedAt || 0);
                            return timeB.getTime() - timeA.getTime(); // Descending order (newest first)
                        });
                        
                        // Create HTML for sorted completions
                        completions.forEach((completion) => {
                            html += createCompletionCard(completion);
                        });
                        
                        listContainer.innerHTML = html;
                    }, (error) => {
                        console.error('‚ùå Error loading completions:', error);
                        listContainer.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #dc3545;">
                                <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
                                <h3>Error Loading Completions</h3>
                                <p>Error: ${error.message}</p>
                                <button onclick="loadStaffDocumentCompletions()" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Retry</button>
                            </div>
                        `;
                    });
                    
            } catch (error) {
                console.error('‚ùå Setup error:', error);
                listContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #dc3545;">
                        <h3>Setup Error</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }
        
        // Create completion card HTML
        function createCompletionCard(completion) {
            const time = completion.time || completion.completedAt || 'Unknown time';
            const version = completion.version || 'old';
            const isSimplified = completion.simplified || false;
            
            // Check exclusion list for staff members (same as info sessions)
            let exclusionWarning = '';
            if (currentUser && (isAdmin || (currentUser.role === 'staff'))) {
                const matches = checkNameInExclusionList(completion.name);
                if (matches.length > 0) {
                    exclusionWarning = `
                        <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; padding: 10px; margin: 10px 0;">
                            <h5 style="color: #856404; margin: 0 0 5px 0;">‚ö†Ô∏è Possible PC or RR List</h5>
                            <p style="color: #856404; margin: 5px 0; font-size: 13px;">This name appears on the exclusion list. Verify with SSN.</p>
                            ${matches.map(match => `
                                <div style="font-size: 12px; color: #856404;">
                                    Code: <strong>${match.code}</strong> - DOB: ${match.dob} - SSN: ***${match.ssn.slice(-4)}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
            }
            
            return `
                <div style="background: white; border: 1px solid #ddd; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <div style="display: flex; justify-content: between; align-items: start; margin-bottom: 15px;">
                        <div style="flex: 1;">
                            <h4 style="margin: 0 0 5px 0; color: #333; font-size: 18px;">
                                üë§ ${completion.name}
                            </h4>
                            <p style="margin: 0; color: #666; font-size: 14px;">
                                üïí ${time}
                            </p>
                        </div>
                        <div style="text-align: right;">
                            <div style="background: #28a745; color: white; padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 16px;">
                                Queue #${completion.queueNumber}
                            </div>
                            <div style="margin-top: 5px; font-size: 12px; color: #666;">
                                v${version} ${isSimplified ? '‚Ä¢ Simplified' : ''}
                            </div>
                        </div>
                    </div>
                    
                    ${exclusionWarning}
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
                            <div><strong>üë®‚Äçüíº Assigned:</strong> ${completion.assignedRecruiter || 'Not assigned'}</div>
                            <div><strong>üìß Email:</strong> ${completion.recruiterEmail || 'No email'}</div>
                            <div><strong>üìÖ Date:</strong> ${completion.date}</div>
                            <div><strong>üÜî ID:</strong> ${completion.id.substring(0, 8)}...</div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        ${completion.status === 'contacted' ? `
                            <div style="background: #d4edda; color: #155724; padding: 8px 16px; border-radius: 5px; font-size: 14px; font-weight: bold; border: 1px solid #c3e6cb;">
                                ‚úÖ Contacted by ${completion.contactedByName || completion.contactedBy || 'Staff'}
                            </div>
                        ` : `
                            <button onclick="markCompleted('${completion.id}')" 
                                    style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 14px;">
                                ‚úÖ Mark as Contacted
                            </button>
                        `}
                        <button onclick="deleteCompletion('${completion.id}', '${completion.name}')" 
                                style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 14px;">
                            üóëÔ∏è Delete
                        </button>
                    </div>
                </div>
            `;
        }
        
        // Make function available globally
        window.loadStaffDocumentCompletions = loadStaffDocumentCompletions;
        
        // Placeholder functions for completion management
        window.markCompleted = async function(completionId) {
            if (!currentUser) {
                showErrorMessage('You must be logged in to mark completions as contacted.');
                return;
            }
            
            try {
                console.log('üìû Marking completion as contacted:', completionId);
                
                // Update the document status
                await db.collection('document-queue').doc(completionId).update({
                    status: 'contacted',
                    contactedAt: new Date().toISOString(),
                    contactedBy: currentUser.email,
                    contactedByName: currentUser.displayName || currentUser.email
                });
                
                console.log('‚úÖ Completion marked as contacted successfully');
                showSuccessMessage('Document completion marked as contacted.');
                
                // The real-time listener will automatically update the display
                
            } catch (error) {
                console.error('‚ùå Error marking completion as contacted:', error);
                showErrorMessage('Error updating completion status. Please try again.');
            }
        }


        // Mark completion back to pending
        async function markAsPending(completionId) {
            try {
                await db.collection('document-queue').doc(completionId).update({
                    status: 'pending-recruiter-contact',
                    // Remove contacted/attended fields
                    contactedBy: firebase.firestore.FieldValue.delete(),
                    contactedAt: firebase.firestore.FieldValue.delete(),
                    attendedBy: firebase.firestore.FieldValue.delete(),
                    attendedByName: firebase.firestore.FieldValue.delete(),
                    attendedAt: firebase.firestore.FieldValue.delete()
                });
                
                showSuccessMessage('Completion moved back to pending status!');
                
            } catch (error) {
                console.error('Error marking completion as pending:', error);
                showErrorMessage('Error updating completion status. Please try again.');
            }
        };

        // Delete document completion
        async function deleteCompletion(completionId, candidateName) {
            if (!currentUser) {
                showErrorMessage('You must be logged in to delete completions.');
                return;
            }

            // Enhanced deletion confirmation with safety measures
            console.log('‚ö†Ô∏è Delete request for:', candidateName);
            
            // First confirmation
            if (!confirm(`‚ö†Ô∏è CONFIRMACI√ìN DE ELIMINACI√ìN\n\n¬øEst√°s seguro de que quieres eliminar el registro de ${candidateName}?\n\n‚ö†Ô∏è IMPORTANTE: Esta acci√≥n no se puede deshacer.`)) {
                console.log('‚ùå Delete cancelled by user');
                return;
            }
            
            // Save current state before deletion
            await saveCurrentSession();
            console.log('üíæ Current session saved before deletion');
            
            // Second confirmation with more details
            if (!confirm(`üö® CONFIRMACI√ìN FINAL\n\nEst√°s a punto de eliminar PERMANENTEMENTE:\n‚Ä¢ Nombre: ${candidateName}\n‚Ä¢ Todos sus datos asociados\n\nüíæ Se ha guardado una copia de respaldo autom√°ticamente.\n\n¬øProceder con la eliminaci√≥n?`)) {
                console.log('‚ùå Final delete confirmation cancelled');
                return;
            }

            try {
                console.log('üóëÔ∏è Deleting completion:', completionId, 'for candidate:', candidateName);
                
                await db.collection('document-queue').doc(completionId).delete();
                
                showSuccessMessage(`Registro de ${candidateName} eliminado exitosamente.`);
                
                // Refresh all views
                loadDocumentCompletions();
                if (typeof loadStatusDocumentCompletions === 'function') {
                    loadStatusDocumentCompletions();
                }
                
            } catch (error) {
                console.error('Error deleting completion:', error);
                showErrorMessage('Error al eliminar el registro. Int√©ntalo de nuevo.');
            }
        }
        
        window.assignToRecruiter = function(completionId) {
            console.log('Reassigning:', completionId);
            // TODO: Implement recruiter reassignment
        };
        
        window.viewDetails = function(completionId) {
            console.log('Viewing details:', completionId);
            debugRecentCompletions(); // Show details in console for now
        };
        
        // Delete completion function
        window.deleteCompletion = async function(completionId, completionName) {
            if (!currentUser) {
                showErrorMessage('You must be logged in to delete completions.');
                return;
            }
            
            try {
                console.log('üîç Checking for potential conflicts before deleting:', completionName);
                
                // Check for potential matches in other collections
                const conflicts = await checkForPCRRConflicts(completionName);
                
                let warningMessage = `‚ö†Ô∏è WARNING: About to delete "${completionName}"\n\n`;
                
                if (conflicts.length > 0) {
                    warningMessage += `üö® POTENTIAL CONFLICTS FOUND:\n\n`;
                    conflicts.forEach(conflict => {
                        warningMessage += `‚Ä¢ ${conflict.type}: "${conflict.name}" (${conflict.collection})\n`;
                    });
                    warningMessage += `\n‚ö†Ô∏è These records might be the same person!\n`;
                    warningMessage += `Please verify these are not the same person before deleting.\n\n`;
                } else {
                    warningMessage += `‚úÖ No potential conflicts found in other queues.\n\n`;
                }
                
                warningMessage += `‚Ä¢ This deletion cannot be undone\n\n`;
                warningMessage += `Are you sure you want to permanently delete this record?`;
                
                const confirmed = confirm(warningMessage);
                
                if (!confirmed) {
                    return;
                }
                
                console.log('üóëÔ∏è Deleting completion:', completionId, 'for', completionName);
                
                // Delete the document from Firestore
                await db.collection('document-queue').doc(completionId).delete();
                
                console.log('‚úÖ Completion deleted successfully');
                showSuccessMessage(`Document completion record for "${completionName}" has been deleted.`);
                
                // The real-time listener will automatically update the list
                
            } catch (error) {
                console.error('‚ùå Error deleting completion:', error);
                showErrorMessage('Error deleting the completion record. Please try again.');
            }
        };
        
        // Check for potential conflicts in PC/RR related collections
        async function checkForPCRRConflicts(targetName) {
            const conflicts = [];
            const today = new Date().toISOString().split('T')[0];
            
            console.log('üîç Checking for conflicts for:', targetName, 'on date:', today);
            
            try {
                // Collections that might contain the same person (PC/RR related)
                const collectionsToCheck = [
                    { name: 'visits', label: 'Visits/PC Queue' },
                    { name: 'fingerprints', label: 'Fingerprints' },
                    { name: 'badges', label: 'Badges' },
                    { name: 'info-sessions', label: 'Info Sessions' },
                    { name: 'new-hire-orientations', label: 'New Hire Orientations' }
                ];
                
                for (const collection of collectionsToCheck) {
                    console.log(`üîç Checking ${collection.name} collection...`);
                    
                    // Search for similar names in today's records
                    const snapshot = await db.collection(collection.name)
                        .where('date', '==', today)
                        .get();
                    
                    console.log(`üìã Found ${snapshot.size} records in ${collection.name} for today`);
                    
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const recordName = data.name || data.fullName || '';
                        
                        console.log(`   Comparing "${targetName}" with "${recordName}"`);
                        
                        // Check for potential name matches (case insensitive, partial matches)
                        if (recordName && isNameSimilar(targetName, recordName)) {
                            console.log(`üö® CONFLICT FOUND: "${recordName}" in ${collection.name}`);
                            conflicts.push({
                                type: `${collection.label}`,
                                name: recordName,
                                collection: collection.name,
                                id: doc.id
                            });
                        }
                    });
                }
                
                console.log(`üîç Total conflicts found: ${conflicts.length}`);
                
            } catch (error) {
                console.error('‚ùå Error checking for conflicts:', error);
            }
            
            return conflicts;
        }
        
        // Check if two names are similar (potential same person)
        function isNameSimilar(name1, name2) {
            if (!name1 || !name2) return false;
            
            const normalize = (name) => name.toLowerCase().trim().replace(/[^\w\s]/g, '');
            
            const n1 = normalize(name1);
            const n2 = normalize(name2);
            
            console.log(`     üìù Normalized: "${n1}" vs "${n2}"`);
            
            // Exact match
            if (n1 === n2) {
                console.log('     ‚úÖ Exact match found!');
                return true;
            }
            
            // Split names and check for matches
            const parts1 = n1.split(/\s+/);
            const parts2 = n2.split(/\s+/);
            
            console.log(`     üîç Parts: [${parts1.join(', ')}] vs [${parts2.join(', ')}]`);
            
            // Check if any part of one name appears in the other
            for (const part1 of parts1) {
                if (part1.length >= 3) { // Only check meaningful parts
                    for (const part2 of parts2) {
                        if (part2.includes(part1) || part1.includes(part2)) {
                            console.log(`     ‚úÖ Partial match: "${part1}" matches "${part2}"`);
                            return true;
                        }
                    }
                }
            }
            
            console.log('     ‚ùå No match found');
            return false;
        }
        
        // Show today's stats function
        // Test function to check document completions without complex query
        window.testSimpleDocQuery = async function() {
            try {
                console.log('üß™ Testing simple document completions query...');
                
                // First, try to get all documents without date filter
                const allDocs = await db.collection('document-queue').limit(5).get();
                console.log('‚úÖ Found', allDocs.size, 'total documents');
                
                allDocs.forEach(doc => {
                    const data = doc.data();
                    console.log('Document fields:', Object.keys(data));
                    console.log('timestamp:', data.timestamp);
                    console.log('submissionTime:', data.submissionTime);
                    console.log('date:', data.date);
                });
                
                // Try with just date filter
                const today = new Date().toISOString().split('T')[0];
                const todayDocs = await db.collection('document-queue')
                    .where('date', '==', today)
                    .limit(5)
                    .get();
                console.log('‚úÖ Found', todayDocs.size, 'documents for today');
                
            } catch (error) {
                console.error('‚ùå Test query error:', error);
            }
        };
        
        window.showTodayStats = async function() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const snapshot = await db.collection('document-queue')
                    .where('date', '==', today)
                    .get();
                    
                alert(`üìä Today's Document Completions\n\nDate: ${today}\nTotal: ${snapshot.size}\n\nClick "Debug Console" to see details in console.`);
            } catch (error) {
                alert(`Error loading stats: ${error.message}`);
            }
        };

        // SIMPLIFIED DOCUMENT COMPLETION FUNCTION - MOVED TO simplified-doc-completion.js
        // This function is now loaded from external file for better maintenance
        /* LEGACY FUNCTION REMOVED - async function submitDocumentCompletionSimplified(event) {
            event.preventDefault();
            
            // Disable submit button to prevent double submission
            const submitButton = event.target.querySelector('button[type="submit"]');
            const originalText = submitButton.textContent;
            
            // Mobile Debug: Show debug info on screen for mobile debugging
            // Use global mobile detection variables
            let debugDiv = null;
            
            if (window.isIOS || (window.isAndroid && window.isChrome)) {
                debugDiv = document.createElement('div');
                debugDiv.id = 'mobile-debug';
                debugDiv.style.cssText = 'position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; font-size: 12px; z-index: 9999; max-width: 90%; max-height: 200px; overflow-y: scroll;';
                debugDiv.innerHTML = `${isIOS ? 'iOS' : 'Android Chrome'} SIMPLIFIED Debug:<br>`;
                document.body.appendChild(debugDiv);
                
                function mobileLog(message) {
                    console.log(message);
                    debugDiv.innerHTML += message + '<br>';
                    debugDiv.scrollTop = debugDiv.scrollHeight;
                }
                
                mobileLog(`üì± SIMPLIFIED Document Completion Started - v2.2`);
            }
            
            if (submitButton.disabled) {
                const msg = '‚è≥ Submit already in progress';
                console.log(msg);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(msg);
                return;
            }
            
            submitButton.disabled = true;
            submitButton.textContent = '‚è≥ Processing...';
            submitButton.style.opacity = '0.6';
            submitButton.style.cursor = 'not-allowed';
            
            try {
                const startMsg = 'üöÄ SIMPLIFIED: Starting document completion...';
                console.log(startMsg);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(startMsg);
                
                const name = document.getElementById('doc-name').value.trim();
                const nameMsg = `üìù Name: ${name}`;
                console.log(nameMsg);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(nameMsg);
                
                // Basic validation
                if (!name) {
                    showErrorMessage('Please enter your full name.');
                    return;
                }
                
                // Get atomic queue number using Firestore transaction
                const now = new Date();
                const today = now.toISOString().split('T')[0];
                
                const queueMsg2 = 'üî¢ Starting atomic queue number transaction...';
                console.log(queueMsg2);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(queueMsg2);
                
                let queueNumber;
                try {
                    // Use Firestore transaction for true atomicity
                    queueNumber = await db.runTransaction(async (transaction) => {
                        const counterRef = db.collection('daily-counters').doc(today);
                        const counterDoc = await transaction.get(counterRef);
                        
                        let newNumber;
                        if (counterDoc.exists) {
                            const currentCount = counterDoc.data().count || 0;
                            newNumber = currentCount + 1;
                            transaction.update(counterRef, {
                                count: newNumber,
                                lastUpdated: new Date().toISOString()
                            });
                        } else {
                            newNumber = 1;
                            transaction.set(counterRef, {
                                count: newNumber,
                                date: today,
                                lastUpdated: new Date().toISOString()
                            });
                        }
                        
                        const transactionMsg = `üî¢ Transaction assigned number: ${newNumber}`;
                        console.log(transactionMsg);
                        return newNumber;
                    });
                    
                    const atomicMsg = `‚úÖ Atomic queue number: ${queueNumber}`;
                    console.log(atomicMsg);
                    if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(atomicMsg);
                    
                } catch (counterError) {
                    const errorMsg = `‚ö†Ô∏è Queue transaction failed: ${counterError.message}`;
                    console.log(errorMsg);
                    if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(errorMsg);
                    
                    // Fallback to timestamp-based unique number
                    queueNumber = Math.floor(Date.now() / 1000) % 1000; // Last 3 digits of timestamp
                    
                    const fallbackMsg = `üîÑ Using fallback number: ${queueNumber}`;
                    console.log(fallbackMsg);
                    if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(fallbackMsg);
                }
                
                const queueMsg = `üî¢ Queue number: ${queueNumber}`;
                console.log(queueMsg);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(queueMsg);
                
                // Create simple completion data (no recruiter assignment needed)
                const completionData = {
                    type: 'document-completion',
                    name: name,
                    queueNumber: queueNumber,
                    assignedRecruiter: 'Front Desk Administrator',
                    recruiterEmail: 'admin@kellyeducation.com',
                    timestamp: new Date().toISOString(),
                    date: today, // Use the same date variable
                    time: now.toLocaleString(),
                    completedAt: new Date().toLocaleString(),
                    simplified: true, // Flag to indicate this is simplified version
                    version: '2.2', // Version tracking
                    userAgent: navigator.userAgent.substring(0, 100), // Track device type
                    submissionTime: Date.now() // Numeric timestamp for sorting
                };
                
                const dataMsg = `üìã Data prepared: ${JSON.stringify({...completionData, userAgent: 'truncated'}, null, 2)}`;
                console.log(dataMsg);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(`üìã Data: ${name}, Queue: ${queueNumber}, Date: ${today}`);
                
                const saveMsg = 'üíæ Saving to database...';
                console.log(saveMsg);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(saveMsg);
                
                // Save to database - ONLY document-completions collection which allows public writes
                const docRef = await db.collection('document-queue').add(completionData);
                
                const docIdMsg = `üìÑ Document saved with ID: ${docRef.id}`;
                console.log(docIdMsg);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(docIdMsg);
                
                const savedMsg = '‚úÖ Saved successfully!';
                console.log(savedMsg);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(savedMsg);
                
                // Update completion screen
                document.getElementById('completion-name').textContent = name;
                document.getElementById('completion-queue').textContent = `#${queueNumber}`;
                document.getElementById('completion-time').textContent = now.toLocaleString();
                
                const showScreenMsg = 'üîÑ Showing success screen...';
                console.log(showScreenMsg);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(showScreenMsg);
                
                // Force scroll to top and hide all other content
                window.scrollTo(0, 0);
                document.body.scrollTop = 0;
                document.documentElement.scrollTop = 0;
                
                // Hide all screens first to prevent confusion
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.remove('active');
                    screen.style.display = 'none';
                });
                
                // Show ONLY the success screen
                const successScreen = document.getElementById('document-completion-success');
                successScreen.classList.add('active');
                successScreen.style.display = 'block';
                successScreen.style.position = 'fixed';
                successScreen.style.top = '0';
                successScreen.style.left = '0';
                successScreen.style.width = '100%';
                successScreen.style.height = '100%';
                successScreen.style.zIndex = '9999';
                successScreen.style.backgroundColor = 'white';
                successScreen.style.overflow = 'auto';
                
                // Hide navigation and other UI elements
                const nav = document.querySelector('nav');
                if (nav) nav.style.display = 'none';
                
                if (window.isIOS || (window.isAndroid && window.isChrome)) {
                    mobileLog('‚úÖ SUCCESS! Full-screen confirmation shown');
                    // Hide debug after 3 seconds since success is obvious now
                    setTimeout(() => {
                        if (debugDiv && debugDiv.parentNode) {
                            debugDiv.style.display = 'none';
                        }
                    }, 3000);
                }
                
                // Additional scroll to ensure visibility
                setTimeout(() => {
                    window.scrollTo(0, 0);
                    successScreen.scrollTop = 0;
                }, 200);
                
                // Play success sound
                playSuccessSound();
                
                // Clear form
                document.querySelector('#document-completion-form form').reset();
                
            } catch (error) {
                const errorMsg = `‚ùå Error: ${error.message}`;
                console.error(errorMsg, error);
                if (window.isIOS || (window.isAndroid && window.isChrome)) mobileLog(errorMsg);
                
                showErrorMessage('Error submitting completion. Please try again.');
                
                // Re-enable submit button on error
                if (submitButton) {
                    submitButton.disabled = false;
                    submitButton.textContent = originalText;
                    submitButton.style.opacity = '1';
                    submitButton.style.cursor = 'pointer';
                }
            }
        } LEGACY FUNCTION REMOVED */

        // Function to return to main menu from success screen
        function returnToMainFromSuccess() {
            // Restore normal layout
            const successScreen = document.getElementById('document-completion-success');
            successScreen.style.position = '';
            successScreen.style.top = '';
            successScreen.style.left = '';
            successScreen.style.width = '';
            successScreen.style.height = '';
            successScreen.style.zIndex = '';
            successScreen.style.backgroundColor = '';
            
            // Show navigation again
            const nav = document.querySelector('nav');
            if (nav) nav.style.display = '';
            
            // Reset all screens display
            document.querySelectorAll('.screen').forEach(screen => {
                screen.style.display = '';
            });
            
            // Go to main screen
            showScreen('visitor');
        }

    </script>

    <!-- Footer -->
    <footer style="background-color: #2E7D32; color: white; text-align: center; padding: 20px; margin-top: 40px; font-size: 14px;">
        <p>&copy; 2025 Rodrigo Bermudez Cafe Cultura LLC. All rights reserved.</p>
    </footer>

    <!-- Include new features -->
    <script src="persistent-checklist.js"></script>
    <script src="queue-manager.js"></script>
    <script src="admin-dashboard.js"></script>
    <script src="simplified-doc-completion.js"></script>
    
    
    <!-- Initialize new features when document is ready -->
    <script>
        // Mobile form optimization
        function optimizeMobileDocumentCompletion() {
            if (!/iPad|iPhone|iPod|Android/i.test(navigator.userAgent)) return;
            if (!window.location.hash.includes('document-completion-form')) return;
            
            // Find the container
            const container = document.getElementById('document-completion-checklist-container');
            
            if (container) {
                container.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <h3>üìÑ Document Completion</h3>
                        <form onsubmit="emergencyMobileSubmit(event)">
                            <div style="margin: 20px 0;">
                                <label>Your Full Name:</label><br>
                                <input type="text" id="emergency-name" required style="width: 100%; max-width: 300px; padding: 10px; margin: 10px 0;">
                            </div>
                            <button type="submit" style="background: #4CAF50; color: white; padding: 15px 30px; border: none; border-radius: 5px; font-size: 16px;">
                                ‚úÖ Submit Document Completion
                            </button>
                        </form>
                    </div>
                `;
            } else {
                // Try to find the document-completion-form screen
                const screen = document.getElementById('document-completion-form');
                
                if (screen) {
                    // Replace entire screen content
                    screen.innerHTML = `
                        <div style="padding: 20px; text-align: center;">
                            <h2>üìÑ Document Completion</h2>
                            <p>Mobile-optimized simple form</p>
                            <form onsubmit="emergencyMobileSubmit(event)">
                                <div style="margin: 20px 0;">
                                    <label>Your Full Name:</label><br>
                                    <input type="text" id="emergency-name" required style="width: 100%; max-width: 300px; padding: 10px; margin: 10px 0;">
                                </div>
                                <button type="submit" style="background: #4CAF50; color: white; padding: 15px 30px; border: none; border-radius: 5px; font-size: 16px;">
                                    ‚úÖ Submit Document Completion
                                </button>
                            </form>
                        </div>
                    `;
                }
            }
        }
        
        // Mobile submit function
        window.emergencyMobileSubmit = async function(event) {
            event.preventDefault();
            
            const name = document.getElementById('emergency-name').value.trim();
            
            if (!name) {
                alert('Please enter your name');
                return;
            }
            
            const btn = event.target.querySelector('button');
            btn.disabled = true;
            btn.textContent = '‚è≥ Submitting...';
            
            try {
                const simpleData = {
                    type: 'document-completion',
                    name: name,
                    queueNumber: Math.floor(Date.now() / 1000) % 10000,
                    timestamp: new Date().toISOString(),
                    date: new Date().toISOString().split('T')[0],
                    time: new Date().toLocaleString(),
                    mobileOptimized: true
                };
                
                // Initialize Firebase if not available
                if (!window.db) {
                    if (window.firebase && window.firebase.firestore) {
                        window.db = window.firebase.firestore();
                    } else {
                        throw new Error('Firebase not available');
                    }
                }
                
                const docRef = await window.db.collection('document-queue').add(simpleData);
                
                alert(`‚úÖ Success! ${name}, your queue number is ${simpleData.queueNumber}. Please proceed to the front desk.`);
                
                // Reset form
                event.target.reset();
                btn.disabled = false;
                btn.textContent = '‚úÖ Submit Document Completion';
                
            } catch (error) {
                // Fallback to localStorage
                try {
                    const backupData = {
                        type: 'document-completion',
                        name: name,
                        queueNumber: Math.floor(Date.now() / 1000) % 10000,
                        timestamp: new Date().toISOString(),
                        needsSync: true,
                        error: error.message
                    };
                    
                    const backups = JSON.parse(localStorage.getItem('document_completions_backup') || '[]');
                    backups.push(backupData);
                    localStorage.setItem('document_completions_backup', JSON.stringify(backups));
                    
                    alert(`‚ö†Ô∏è ${name}, your queue number is ${backupData.queueNumber}. Data saved locally - please inform front desk.`);
                    
                    event.target.reset();
                    btn.disabled = false;
                    btn.textContent = '‚úÖ Submit Document Completion';
                    
                } catch (fallbackError) {
                    alert(`‚ùå Submission failed: ${error.message}`);
                    btn.disabled = false;
                    btn.textContent = '‚úÖ Submit Document Completion';
                }
            }
        };
        
        // SIMPLIFIED FIREBASE SYNC - NO TIMEOUTS, JUST DIRECT APPROACH
        window.syncToFirebase = async function(submissionData) {
            console.log('üîÑ SIMPLIFIED sync attempt for:', submissionData.name);
            
            try {
                // Use existing global Firebase connection if available
                let db;
                if (window.db) {
                    db = window.db;
                    console.log('‚úÖ Using existing global Firebase db');
                } else if (typeof firebase !== 'undefined' && firebase.firestore) {
                    db = firebase.firestore();
                    console.log('‚úÖ Created new Firebase db instance');
                } else {
                    throw new Error('Firebase not available');
                }
                
                console.log('üìù Attempting direct write to document-queue...');
                
                // Simple direct write - no Promise.race, no timeouts
                const docRef = await db.collection('document-queue').add({
                    type: 'document-completion',
                    name: submissionData.name,
                    queueNumber: submissionData.queueNumber,
                    timestamp: submissionData.timestamp,
                    date: submissionData.date,
                    time: submissionData.time,
                    status: 'pending-recruiter-contact',
                    assignedRecruiter: 'Front Desk Administrator',
                    recruiterEmail: 'admin@kellyeducation.com',
                    drugScreening: submissionData.drugScreening,
                    onboarding365: submissionData.onboarding365,
                    i9Form: submissionData.i9Form,
                    fieldprint: submissionData.fieldprint,
                    completedAt: submissionData.timestamp,
                    source: 'document-completion-form'
                });
                
                console.log('üéâ DIRECT SUCCESS! Document ID:', docRef.id);
                console.log('‚úÖ CONFIRMED: Data is now in document-queue collection');
                
                // Mark as synced
                window.markAsSynced(submissionData.queueNumber);
                return true;
                
            } catch (error) {
                console.log('‚ùå Direct sync failed:', error.message);
                console.log('üìä Error details:', error);
                
                // Try one more time with document-completions
                try {
                    console.log('üîÑ Trying document-queue as last resort...');
                    const db2 = firebase.firestore();
                    const docRef2 = await db2.collection('document-queue').add({
                        type: 'document-completion',
                        name: submissionData.name,
                        queueNumber: submissionData.queueNumber,
                        timestamp: submissionData.timestamp,
                        date: submissionData.date,
                        time: submissionData.time,
                        status: 'pending-recruiter-contact',
                        assignedRecruiter: 'Front Desk Administrator',
                        recruiterEmail: 'admin@kellyeducation.com',
                        drugScreening: submissionData.drugScreening,
                        onboarding365: submissionData.onboarding365,
                        i9Form: submissionData.i9Form,
                        fieldprint: submissionData.fieldprint,
                        completedAt: submissionData.timestamp,
                        source: 'document-completion-form-fallback'
                    });
                    console.log('üéâ BACKUP SUCCESS! Document ID:', docRef2.id);
                    console.log('‚úÖ Data saved to document-queue collection (fallback)');
                    
                    window.markAsSynced(submissionData.queueNumber);
                    return true;
                } catch (backupError) {
                    console.log('‚ùå Both collections failed:', backupError.message);
                    return false;
                }
            }
        };
        
        // Mark submission as successfully synced
        window.markAsSynced = function(queueNumber) {
            try {
                const submissions = JSON.parse(localStorage.getItem('document_queue_submissions') || '[]');
                const updated = submissions.map(sub => {
                    if (sub.queueNumber === queueNumber) {
                        sub.syncStatus = 'synced';
                        sub.syncedAt = new Date().toISOString();
                    }
                    return sub;
                });
                localStorage.setItem('document_queue_submissions', JSON.stringify(updated));
                console.log('‚úÖ Marked as synced:', queueNumber);
            } catch (e) {
                console.log('‚ö†Ô∏è Failed to update sync status');
            }
        };
        
        // Update localStorage record
        window.updateLocalStorageRecord = function(submissionData) {
            try {
                const submissions = JSON.parse(localStorage.getItem('document_queue_submissions') || '[]');
                const updated = submissions.map(sub => {
                    if (sub.queueNumber === submissionData.queueNumber) {
                        return { ...sub, ...submissionData };
                    }
                    return sub;
                });
                localStorage.setItem('document_queue_submissions', JSON.stringify(updated));
            } catch (e) {
                console.log('‚ö†Ô∏è Failed to update localStorage record');
            }
        };
        
        // Manual sync function for all pending submissions
        window.syncAllPendingSubmissions = function() {
            console.log('üîÑ MANUAL SYNC: Starting sync of all pending submissions...');
            
            try {
                const submissions = JSON.parse(localStorage.getItem('document_queue_submissions') || '[]');
                const pending = submissions.filter(sub => sub.syncStatus !== 'synced');
                
                console.log(`üìä Found ${pending.length} pending submissions to sync`);
                console.log('üìã Pending submissions:', pending.map(s => `${s.name} (#${s.queueNumber})`));
                
                if (pending.length === 0) {
                    console.log('‚úÖ No pending submissions to sync');
                    return;
                }
                
                pending.forEach((submission, index) => {
                    console.log(`üîÑ Syncing ${index + 1}/${pending.length}: ${submission.name}`);
                    
                    // Sync immediately, no delays
                    window.syncToFirebase(submission);
                });
                
            } catch (e) {
                console.log('‚ö†Ô∏è Failed to read localStorage for sync:', e.message);
            }
        };
        
        // Quick debug function to see localStorage data
        window.showLocalStorageData = function() {
            try {
                const submissions = JSON.parse(localStorage.getItem('document_queue_submissions') || '[]');
                console.log('üìä Total submissions in localStorage:', submissions.length);
                console.table(submissions.map(s => ({
                    name: s.name,
                    queueNumber: s.queueNumber,
                    syncStatus: s.syncStatus || 'pending',
                    timestamp: s.timestamp
                })));
            } catch (e) {
                console.log('‚ùå Error reading localStorage:', e.message);
            }
        };
        
        // TEST FUNCTION - Direct Firebase write with verification
        window.testFirebaseWrite = async function() {
            console.log('üß™ TESTING: Direct Firebase write to document-queue...');
            
            try {
                const db = firebase.firestore();
                
                const testData = {
                    name: 'TEST USER - ' + new Date().toLocaleTimeString(),
                    queueNumber: 9999,
                    timestamp: new Date().toISOString(),
                    date: new Date().toISOString().split('T')[0],
                    source: 'manual-test',
                    testRecord: true
                };
                
                console.log('üìù Writing test data:', testData);
                
                const docRef = await db.collection('document-queue').add(testData);
                
                console.log('üéâ TEST SUCCESS! Document ID:', docRef.id);
                console.log('‚úÖ Check Firebase Console for document-queue collection');
                
                // Try to read it back immediately
                setTimeout(async () => {
                    try {
                        const doc = await db.collection('document-queue').doc(docRef.id).get();
                        if (doc.exists) {
                            console.log('‚úÖ VERIFICATION: Document exists in Firebase:', doc.data());
                        } else {
                            console.log('‚ùå VERIFICATION: Document not found after write');
                        }
                    } catch (readError) {
                        console.log('‚ùå VERIFICATION ERROR:', readError.message);
                    }
                }, 2000);
                
            } catch (error) {
                console.log('‚ùå TEST FAILED:', error.message);
                console.log('üìä Full error:', error);
            }
        };
        
        // VERIFY FIREBASE CONNECTION
        window.testFirebaseConnection = async function() {
            console.log('üîç TESTING: Firebase connection and permissions...');
            
            try {
                const db = firebase.firestore();
                
                // Test read access
                console.log('üìñ Testing read access...');
                const testRead = await db.collection('document-queue').limit(1).get();
                console.log('‚úÖ Read access works. Documents found:', testRead.size);
                
                // Test write access  
                console.log('‚úçÔ∏è Testing write access...');
                await window.testFirebaseWrite();
                
            } catch (error) {
                console.log('‚ùå CONNECTION TEST FAILED:', error.message);
                console.log('üìä Error code:', error.code);
                console.log('üìä Full error:', error);
            }
        };
        
        // Auto-sync pending submissions on page load
        setTimeout(() => {
            console.log('üîÑ Auto-syncing pending submissions...');
            window.syncAllPendingSubmissions();
        }, 5000); // Wait 5 seconds after page load
        
        console.log('‚úÖ Firebase sync system initialized');
    </script>
</body>
</html>
<script>
async function submitDirectForm(event) {
    event.preventDefault();
    console.log('üöÄ Direct form submitted\!');
    
    const submitBtn = document.getElementById('direct-submit-btn');
    const name = document.getElementById('direct-name').value.trim();
    const statusDiv = document.getElementById('direct-status');
    
    if (!name) {
        statusDiv.innerHTML = '<div style="background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 15px; border-radius: 8px;">Please enter your full name</div>';
        return;
    }
    
    submitBtn.disabled = true;
    submitBtn.textContent = '‚è≥ Processing...';
    statusDiv.innerHTML = '';
    
    try {
        const now = new Date();
        const queueNumber = Math.floor(now.getTime() / 1000) % 10000;
        
        const submissionData = {
            type: 'document-completion',
            name: name,
            queueNumber: queueNumber,
            timestamp: now.toISOString(),
            date: now.toISOString().split('T')[0],
            time: now.toLocaleString(),
            status: 'pending-recruiter-contact',
            assignedRecruiter: 'Front Desk Administrator',
            recruiterEmail: 'admin@kellyeducation.com',
            drugScreening: document.getElementById('direct-drug-screening')?.checked || false,
            onboarding365: document.getElementById('direct-onboarding-365')?.checked || false,
            i9Form: document.getElementById('direct-i9-form')?.checked || false,
            fieldprint: document.getElementById('direct-fieldprint')?.checked || false,
            completedAt: now.toISOString(),
            source: 'direct-document-completion-form'
        };
        
        console.log('üìù Sending to document-queue:', submissionData);
        
        let db;
        if (window.db) {
            db = window.db;
        } else if (typeof firebase !== 'undefined' && firebase.firestore) {
            db = firebase.firestore();
        } else {
            throw new Error('Firebase not available');
        }
        
        const docRef = await db.collection('document-queue').add(submissionData);
        console.log('‚úÖ SUCCESS! Document ID:', docRef.id);
        
        statusDiv.innerHTML = `
            <div style="background: #d4edda; border: 1px solid #c3e6cb; color: #155724; padding: 15px; border-radius: 8px;">
                <h3>üéâ Success!</h3>
                <p><strong>${name}</strong></p>
                <p>Your queue number is: <strong>#${queueNumber}</strong></p>
                <p style="margin-top: 15px; font-weight: bold;">Please proceed to the front desk.</p>
            </div>
        `;
        
        document.getElementById('direct-completion-form').reset();
        
    } catch (error) {
        console.error('‚ùå Error:', error);
        statusDiv.innerHTML = `
            <div style="background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 15px; border-radius: 8px;">
                ‚ùå Error: ${error.message}
            </div>
        `;
    } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = '‚úÖ Submit Document Completion';
    }
}

// üìä ADVANCED ANALYTICS FUNCTIONS - PYTHON API INTEGRATION
const API_BASE_URL = 'http://localhost:8000/api/v1';

async function loadAdvancedAnalytics() {
    console.log('üìä Loading Advanced Analytics...');
    const container = document.getElementById('admin-dashboard-container');
    
    // Show loading state
    container.innerHTML = `
        <div style="text-align: center; padding: 40px;">
            <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            <p style="margin-top: 20px; color: #666;">Loading Advanced Analytics...</p>
        </div>
        <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        </style>
    `;

    try {
        // Fetch analytics data from Python API
        const [summaryResponse, widgetsResponse] = await Promise.all([
            fetch(`${API_BASE_URL}/analytics/summary`),
            fetch(`${API_BASE_URL}/dashboard/widgets`)
        ]);

        if (!summaryResponse.ok || !widgetsResponse.ok) {
            throw new Error('Failed to fetch analytics data');
        }

        const summaryData = await summaryResponse.json();
        const widgetsData = await widgetsResponse.json();

        // Render advanced analytics dashboard
        container.innerHTML = `
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; margin-bottom: 30px;">
                <h2 style="margin: 0; font-size: 24px;">üìä Advanced Analytics Dashboard</h2>
                <p style="margin: 5px 0 0 0; opacity: 0.9;">Powered by Python Analytics API</p>
            </div>

            <!-- Summary Cards -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">
                ${widgetsData.summary_cards.map(card => `
                    <div style="background: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); border-left: 4px solid ${getCardColor(card.color)};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h3 style="margin: 0; color: #333; font-size: 14px; font-weight: 600;">${card.title}</h3>
                                <p style="margin: 8px 0 0 0; font-size: 24px; font-weight: bold; color: ${getCardColor(card.color)};">${card.value}</p>
                                <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">${card.trend}</p>
                            </div>
                            <div style="font-size: 30px; opacity: 0.7;">${card.icon}</div>
                        </div>
                    </div>
                `).join('')}
            </div>

            <!-- Charts Section -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
                <!-- Visits Trend Chart -->
                <div style="background: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                    <h3 style="margin: 0 0 20px 0; color: #333;">üìà Visits Trend (30 days)</h3>
                    <div id="visits-trend-chart" style="height: 300px; background: #f8f9fa; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666;">
                        <div>Chart will load here</div>
                    </div>
                </div>

                <!-- Visit Types Chart -->
                <div style="background: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                    <h3 style="margin: 0 0 20px 0; color: #333;">üç∞ Visit Types Distribution</h3>
                    <div id="visit-types-chart" style="height: 300px; background: #f8f9fa; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666;">
                        <div>Chart will load here</div>
                    </div>
                </div>
            </div>

            <!-- Export Section -->
            <div style="background: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="margin: 0 0 20px 0; color: #333;">üìã Export Data</h3>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <button onclick="exportData('visits', 'excel')" class="btn" style="background: #28a745; color: white;">
                        üìä Export Visits (Excel)
                    </button>
                    <button onclick="exportData('staff', 'excel')" class="btn" style="background: #17a2b8; color: white;">
                        üë• Export Staff (Excel)
                    </button>
                    <button onclick="exportData('document-queue', 'csv')" class="btn" style="background: #fd7e14; color: white;">
                        üìÑ Export Documents (CSV)
                    </button>
                    <button onclick="generateReport('daily')" class="btn" style="background: #6f42c1; color: white;">
                        üìà Generate Daily Report
                    </button>
                </div>
            </div>

            <!-- API Status -->
            <div style="margin-top: 20px; padding: 15px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; color: #155724;">
                ‚úÖ <strong>API Connected:</strong> Data updated at ${new Date().toLocaleString()}
                <br>üì° <strong>Backend:</strong> Python FastAPI running on localhost:8000
            </div>
        `;

        // Load charts after a short delay to ensure DOM is ready
        setTimeout(() => {
            loadVisitsTrendChart();
            loadVisitTypesChart();
        }, 500);

    } catch (error) {
        console.error('‚ùå Error loading analytics:', error);
        container.innerHTML = `
            <div style="text-align: center; padding: 40px;">
                <div style="background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 20px; border-radius: 8px; display: inline-block;">
                    <h3 style="margin: 0 0 10px 0;">‚ö†Ô∏è Analytics API Unavailable</h3>
                    <p style="margin: 0;">Unable to connect to Python backend API.</p>
                    <p style="margin: 10px 0 0 0; font-size: 14px;">Make sure the backend server is running on localhost:8000</p>
                    <button onclick="loadAdvancedAnalytics()" class="btn" style="background: #dc3545; color: white; margin-top: 15px;">
                        üîÑ Retry Connection
                    </button>
                </div>
            </div>
        `;
    }
}

function getCardColor(color) {
    const colors = {
        'blue': '#3498db',
        'green': '#28a745',
        'orange': '#fd7e14',
        'purple': '#6f42c1',
        'red': '#dc3545'
    };
    return colors[color] || '#6c757d';
}

async function loadVisitsTrendChart() {
    try {
        const response = await fetch(`${API_BASE_URL}/dashboard/chart/visits-trend?chart_type=line`);
        const data = await response.json();
        
        const chartContainer = document.getElementById('visits-trend-chart');
        if (data.raw_data && data.raw_data.dates.length > 0) {
            // Simple chart representation
            const maxValue = Math.max(...data.raw_data.visits);
            const chartHTML = data.raw_data.dates.slice(-7).map((date, index) => {
                const value = data.raw_data.visits[data.raw_data.visits.length - 7 + index] || 0;
                const height = maxValue > 0 ? (value / maxValue) * 100 : 0;
                return `
                    <div style="display: inline-block; margin: 0 2px; text-align: center; flex: 1;">
                        <div style="height: 200px; display: flex; align-items: end;">
                            <div style="width: 100%; background: #3498db; height: ${height}%; min-height: 2px; border-radius: 4px;"></div>
                        </div>
                        <div style="font-size: 10px; margin-top: 5px; color: #666;">${new Date(date).toLocaleDateString('en-US', {month: 'numeric', day: 'numeric'})}</div>
                        <div style="font-size: 12px; font-weight: bold; color: #333;">${value}</div>
                    </div>
                `;
            }).join('');
            
            chartContainer.innerHTML = `
                <div style="display: flex; align-items: end; height: 100%; padding: 20px;">
                    ${chartHTML}
                </div>
            `;
        } else {
            chartContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">No data available</div>';
        }
    } catch (error) {
        console.error('Error loading visits chart:', error);
    }
}

async function loadVisitTypesChart() {
    try {
        const response = await fetch(`${API_BASE_URL}/analytics/visits/types`);
        const data = await response.json();
        
        const chartContainer = document.getElementById('visit-types-chart');
        if (data.labels && data.labels.length > 0) {
            const total = data.values.reduce((sum, val) => sum + val, 0);
            const colors = ['#3498db', '#e74c3c', '#f39c12', '#2ecc71', '#9b59b6', '#1abc9c'];
            
            const chartHTML = data.labels.map((label, index) => {
                const value = data.values[index];
                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                const color = colors[index % colors.length];
                
                return `
                    <div style="display: flex; align-items: center; margin: 10px 0; padding: 8px; border-radius: 6px; background: ${color}15;">
                        <div style="width: 16px; height: 16px; background: ${color}; border-radius: 50%; margin-right: 10px;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: #333;">${label}</div>
                            <div style="font-size: 14px; color: #666;">${value} visits (${percentage}%)</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            chartContainer.innerHTML = `
                <div style="padding: 20px;">
                    ${chartHTML}
                </div>
            `;
        } else {
            chartContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">No visit types data available</div>';
        }
    } catch (error) {
        console.error('Error loading visit types chart:', error);
    }
}

async function exportData(collection, format) {
    try {
        const response = await fetch(`${API_BASE_URL}/reports/export`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                collection: collection,
                format: format
            })
        });

        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${collection}_export_${new Date().toISOString().split('T')[0]}.${format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            showSuccessMessage(`‚úÖ ${collection} data exported successfully!`);
        } else {
            throw new Error('Export failed');
        }
    } catch (error) {
        console.error('Export error:', error);
        showErrorMessage(`‚ùå Failed to export ${collection} data. Make sure the API server is running.`);
    }
}

async function generateReport(reportType) {
    try {
        const response = await fetch(`${API_BASE_URL}/reports/generate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                report_type: 'visits',
                format: 'excel',
                include_charts: true
            })
        });

        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${reportType}_report_${new Date().toISOString().split('T')[0]}.xlsx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            showSuccessMessage(`‚úÖ ${reportType} report generated successfully!`);
        } else {
            throw new Error('Report generation failed');
        }
    } catch (error) {
        console.error('Report generation error:', error);
        showErrorMessage(`‚ùå Failed to generate ${reportType} report. Make sure the API server is running.`);
    }
}

// üìä STAFF ADVANCED ANALYTICS FUNCTION
async function loadStaffAdvancedAnalytics() {
    console.log('üìä Loading Staff Advanced Analytics...');
    const container = document.getElementById('staff-analytics-container');
    
    // Show loading state
    container.innerHTML = `
        <div style="text-align: center; padding: 40px;">
            <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            <p style="margin-top: 20px; color: #666;">Loading Analytics Dashboard...</p>
        </div>
        <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        </style>
    `;

    try {
        // Fetch analytics data from Python API
        const [summaryResponse, widgetsResponse] = await Promise.all([
            fetch(`${API_BASE_URL}/analytics/summary`),
            fetch(`${API_BASE_URL}/dashboard/widgets`)
        ]);

        if (!summaryResponse.ok || !widgetsResponse.ok) {
            throw new Error('Failed to fetch analytics data');
        }

        const summaryData = await summaryResponse.json();
        const widgetsData = await widgetsResponse.json();

        // Render staff analytics dashboard (similar to admin but with staff styling)
        container.innerHTML = `
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; margin-bottom: 30px;">
                <h2 style="margin: 0; font-size: 24px;">üìä Staff Analytics Dashboard</h2>
                <p style="margin: 5px 0 0 0; opacity: 0.9;">Real-time data powered by Python Analytics API</p>
            </div>

            <!-- Summary Cards -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">
                ${widgetsData.summary_cards.map(card => `
                    <div style="background: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); border-left: 4px solid ${getCardColor(card.color)};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h3 style="margin: 0; color: #333; font-size: 14px; font-weight: 600;">${card.title}</h3>
                                <p style="margin: 8px 0 0 0; font-size: 24px; font-weight: bold; color: ${getCardColor(card.color)};">${card.value}</p>
                                <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">${card.trend}</p>
                            </div>
                            <div style="font-size: 30px; opacity: 0.7;">${card.icon}</div>
                        </div>
                    </div>
                `).join('')}
            </div>

            <!-- Charts Section -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
                <!-- Visits Trend Chart -->
                <div style="background: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                    <h3 style="margin: 0 0 20px 0; color: #333;">üìà Visits Trend (Last 7 days)</h3>
                    <div id="staff-visits-trend-chart" style="height: 300px; background: #f8f9fa; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666;">
                        <div>Loading chart...</div>
                    </div>
                </div>

                <!-- Visit Types Chart -->
                <div style="background: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                    <h3 style="margin: 0 0 20px 0; color: #333;">üç∞ Visit Types Distribution</h3>
                    <div id="staff-visit-types-chart" style="height: 300px; background: #f8f9fa; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666;">
                        <div>Loading chart...</div>
                    </div>
                </div>
            </div>

            <!-- Quick Actions for Staff -->
            <div style="background: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="margin: 0 0 20px 0; color: #333;">‚ö° Quick Actions</h3>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <button onclick="exportData('visits', 'excel')" class="btn" style="background: #28a745; color: white;">
                        üìä Export Visits Data
                    </button>
                    <button onclick="exportData('document-queue', 'csv')" class="btn" style="background: #fd7e14; color: white;">
                        üìÑ Export Document Queue
                    </button>
                    <button onclick="generateReport('daily')" class="btn" style="background: #6f42c1; color: white;">
                        üìà Generate Daily Report
                    </button>
                    <button onclick="loadStaffAdvancedAnalytics()" class="btn" style="background: #17a2b8; color: white;">
                        üîÑ Refresh Data
                    </button>
                </div>
            </div>

            <!-- API Status -->
            <div style="margin-top: 20px; padding: 15px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; color: #155724;">
                ‚úÖ <strong>Analytics Connected:</strong> Data last updated at ${new Date().toLocaleString()}
                <br>üì° <strong>Source:</strong> Python FastAPI ‚Ä¢ Real-time database sync
            </div>
        `;

        // Load charts after a short delay to ensure DOM is ready
        setTimeout(() => {
            loadStaffVisitsTrendChart();
            loadStaffVisitTypesChart();
        }, 500);

    } catch (error) {
        console.error('‚ùå Error loading staff analytics:', error);
        container.innerHTML = `
            <div style="text-align: center; padding: 40px;">
                <div style="background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 20px; border-radius: 8px; display: inline-block;">
                    <h3 style="margin: 0 0 10px 0;">‚ö†Ô∏è Analytics Temporarily Unavailable</h3>
                    <p style="margin: 0;">Unable to connect to the analytics backend.</p>
                    <p style="margin: 10px 0 0 0; font-size: 14px;">The analytics server may be starting up or temporarily offline.</p>
                    <button onclick="loadStaffAdvancedAnalytics()" class="btn" style="background: #dc3545; color: white; margin-top: 15px;">
                        üîÑ Try Again
                    </button>
                </div>
            </div>
        `;
    }
}

async function loadStaffVisitsTrendChart() {
    try {
        const response = await fetch(`${API_BASE_URL}/dashboard/chart/visits-trend?chart_type=line`);
        const data = await response.json();
        
        const chartContainer = document.getElementById('staff-visits-trend-chart');
        if (data.raw_data && data.raw_data.dates.length > 0) {
            // Simple chart representation (last 7 days for staff view)
            const maxValue = Math.max(...data.raw_data.visits);
            const chartHTML = data.raw_data.dates.slice(-7).map((date, index) => {
                const value = data.raw_data.visits[data.raw_data.visits.length - 7 + index] || 0;
                const height = maxValue > 0 ? (value / maxValue) * 100 : 0;
                return `
                    <div style="display: inline-block; margin: 0 2px; text-align: center; flex: 1;">
                        <div style="height: 200px; display: flex; align-items: end;">
                            <div style="width: 100%; background: #667eea; height: ${height}%; min-height: 2px; border-radius: 4px;"></div>
                        </div>
                        <div style="font-size: 10px; margin-top: 5px; color: #666;">${new Date(date).toLocaleDateString('en-US', {month: 'numeric', day: 'numeric'})}</div>
                        <div style="font-size: 12px; font-weight: bold; color: #333;">${value}</div>
                    </div>
                `;
            }).join('');
            
            chartContainer.innerHTML = `
                <div style="display: flex; align-items: end; height: 100%; padding: 20px;">
                    ${chartHTML}
                </div>
            `;
        } else {
            chartContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">No visit data available</div>';
        }
    } catch (error) {
        console.error('Error loading staff visits chart:', error);
        document.getElementById('staff-visits-trend-chart').innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">Chart unavailable</div>';
    }
}

async function loadStaffVisitTypesChart() {
    try {
        const response = await fetch(`${API_BASE_URL}/analytics/visits/types`);
        const data = await response.json();
        
        const chartContainer = document.getElementById('staff-visit-types-chart');
        if (data.labels && data.labels.length > 0) {
            const total = data.values.reduce((sum, val) => sum + val, 0);
            const colors = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#00f2fe'];
            
            const chartHTML = data.labels.map((label, index) => {
                const value = data.values[index];
                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                const color = colors[index % colors.length];
                
                return `
                    <div style="display: flex; align-items: center; margin: 10px 0; padding: 8px; border-radius: 6px; background: ${color}15;">
                        <div style="width: 16px; height: 16px; background: ${color}; border-radius: 50%; margin-right: 10px;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: #333;">${label}</div>
                            <div style="font-size: 14px; color: #666;">${value} visits (${percentage}%)</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            chartContainer.innerHTML = `
                <div style="padding: 20px;">
                    ${chartHTML}
                </div>
            `;
        } else {
            chartContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">No visit types data available</div>';
        }
    } catch (error) {
        console.error('Error loading staff visit types chart:', error);
        document.getElementById('staff-visit-types-chart').innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">Chart unavailable</div>';
    }
}
</script>
EOF < /dev/null